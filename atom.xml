<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dirac Sea</title>
  
  <subtitle>where the water tastes like wine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://accepted.org.cn/"/>
  <updated>2021-06-27T10:32:47.063Z</updated>
  <id>https://accepted.org.cn/</id>
  
  <author>
    <name>etoa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 909. 蛇梯棋</title>
    <link href="https://accepted.org.cn/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/"/>
    <id>https://accepted.org.cn/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/</id>
    <published>2021-06-27T09:48:05.000Z</published>
    <updated>2021-06-27T10:32:47.063Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS魔改题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$N \times N$ 的棋盘 $board$ 上，按从 $1$ 到 $N \times N$ 的数字给方格编号，编号 <strong>从左下角开始</strong>，每一行交替方向。</p><p>例如，一块 $6 \times 6$ 大小的棋盘，编号如下：</p><p><img src="0.png" alt="0x0"></p><p>$r$ 行 $c$ 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 $board[r][c] != -1$，那个蛇或梯子的目的地将会是 $board[r][c]$。</p><p>玩家从棋盘上的方格 $1$ （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 $x$ 开始出发，按下述要求前进：</p><ul><li><p>选定目标方格：选择从编号 $x+1$，$x+2$，$x+3$，$x+4$，$x+5$，或者 $x+6$ 的方格中选出一个目标方格 $s$ ，目标方格的编号 $&lt;= N \times N$。</p><ul><li>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 $[x+1, x+6]$ 之间。</li></ul></li><li><p>传送玩家：如果目标方格 $S$ 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 $S$。<br>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p></li></ul><p>返回达到方格 $N \times N$ 所需的最少移动次数，如果不可能，则返回 $-1$。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong><br>[[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,35,-1,-1,13,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,15,-1,-1,-1,-1]]<br><strong>输出：</strong> 4<br><strong>解释：</strong><br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</p></blockquote><p><strong>提示：</strong></p><ul><li>$2 &lt;= board.length = board[0].length &lt;= 20$</li><li>$board[i][j]$ 介于 $1$ 和 $N \times N$ 之间或者等于 $-1$。</li><li>编号为 $1$ 的方格上没有蛇或梯子。</li><li>编号为 $N \times N$ 的方格上没有蛇或梯子。</li></ul><hr><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>这道题很容易看出来是一道利用BFS找到最短路径步数的题目。和一般的BFS题不同之处在于引入了「传送门」的概念，以及搜索方向是蛇形的。<br>引入「传送门」的概念并不妨碍最先BFS到终点的路径一定最短这一BFS特性。<br>重要的是，我们还是要标记出已经到达的位置，以避免重复入队。<br>把棋盘上非 $-1$ 的数字看成一个位置指针，也不必考虑到循环指针的问题。因为只要做好重复标记，可以避免所有循环指针入队。</p><p>我和yxc解法的区别主要在于路径长度记录和重复标记方法。<br>对于路径长度记录，我是将路径长度和路径点坐标放在一起入队，每次搜索下一个点，将路径 $+1$；而yxc是维护一个和原棋盘大小相同的每个值初始化为无穷大的 <code>dist</code> 二维数组，将起点设为 $0$，每搜索到一个点，如果是新的点，就在当前点的距离上 $+1$。</p><p>对于重复标记，我是将已入队的位置在原棋盘上更改为一个特定值 <code>0x3f3f3f3f</code>；而yxc的解法利用记录路径长度的二维数组，如果搜索到的新点对应值是无穷大，说明确实是一个新的点，如果不是，则之前已被搜过。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-27 18:12:16</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">404</span>;</span><br><span class="line">    pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = board.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = R - <span class="number">1</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ((-r + R) &amp; <span class="number">1</span>) ? <span class="number">0</span> : C - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; C; last++) &#123;</span><br><span class="line">                grid[r][c] = last + <span class="number">1</span>;</span><br><span class="line">                heap[last + <span class="number">1</span>] = &#123;r, c&#125;;</span><br><span class="line">                <span class="keyword">if</span> ((-r + R) &amp; <span class="number">1</span>) c++;</span><br><span class="line">                <span class="keyword">else</span> c--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = R * C;</span><br><span class="line">        q[++tt] = &#123;&#123;R - <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">        board[R - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; hh++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first.first, c = q[hh].first.second;</span><br><span class="line">            <span class="keyword">int</span> x = grid[r][c];</span><br><span class="line">            <span class="keyword">int</span> cnt = q[hh].second;</span><br><span class="line">            </span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = x + i;</span><br><span class="line">                <span class="keyword">int</span> ner = heap[nex].first, nec = heap[nex].second;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "ner: " &lt;&lt; ner &lt;&lt; " nec: " &lt;&lt; nec &lt;&lt; " nex: " &lt;&lt; nex &lt;&lt; " cnt: " &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (nex == target || board[ner][nec] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nex &gt; target || board[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// determine teleport beacon</span></span><br><span class="line">                <span class="keyword">if</span> (board[ner][nec] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q[++tt] = &#123;heap[board[ner][nec]], cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                board[ner][nec] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; cor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        id = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        cor = <span class="built_in">vector</span>&lt;PII&gt;(n * m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, k = <span class="number">1</span>, s = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --, s ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">1e9</span>))</span></span>;</span><br><span class="line">        q.push(&#123;n - <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        dist[n - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> k = id[t.x][t.y];</span><br><span class="line">            <span class="keyword">if</span> (k == n * m) <span class="keyword">return</span> dist[t.x][t.y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= k + <span class="number">6</span> &amp;&amp; i &lt;= n * m; i ++ ) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = cor[i].x, y = cor[i].y;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = board[x][y];</span><br><span class="line">                    x = cor[r].x, y = cor[r].y;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode 909. 蛇梯棋</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS魔改题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊递归</title>
    <link href="https://accepted.org.cn/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/"/>
    <id>https://accepted.org.cn/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/</id>
    <published>2021-06-25T10:10:29.000Z</published>
    <updated>2021-06-25T13:58:17.079Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>递归、回溯、DFS，都聊一聊。</p><a id="more"></a><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>很简单，就是指一段函数内部调用自己。细一点，它分为「递」和「归」两个过程。<br>这些都是大家都知道的东西，今天我想聊一聊如何构建一段标准的递归代码。</p><p>首先是递归进入条件。<br>首次在递归函数外部调用递归函数的条件，需要和递归函数内部调用自身的条件一致。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;递归、回溯、DFS，都聊一聊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://accepted.org.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 149. 直线上最多的点数</title>
    <link href="https://accepted.org.cn/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</id>
    <published>2021-06-24T09:45:27.000Z</published>
    <updated>2021-06-24T10:16:13.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>主要是考虑从哪个角度入手暴搜。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</p><p><strong>示例1:</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：points = [[1,1],[2,2],[3,3]]<br>输出：3</p></blockquote><p><strong>示例2:</strong></p><p><img src="1.jpg" alt="0x1"></p><blockquote><p>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>输出：4</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= points.length &lt;= 300$</li><li>$points[i].length == 2$</li><li>$-10^4 &lt;= xi, yi &lt;= 10^4$</li><li>$points$ 中的所有点 <strong>互不相同</strong></li></ul><hr><h3 id="暴搜"><a href="#暴搜" class="headerlink" title="暴搜"></a>暴搜</h3><p>对于某一个点，把它看成中心点，平面上会有无穷多条直线经过它。对于一个中心点，剩余点的每个点都和它构成一条直线。我们统计剩余点和中心点构成直线的数量。</p><p>注意剩余点和中心点垂直的情况，此时可以用一个额外的变量来统计和中心点垂直的点的数量。<br>注意相同点的情况，即剩余点和中心点重合，虽然题目条件说明所有点互不相同，但是这里依旧考虑这一情况。<br>注意本题精度要求较高，计算斜率使用 long double 变量。<br>如果精度要求更高，可以考虑用分数来存放斜率，这时候需要求分子分母最大公约数。</p><div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-24 17:54:50</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> center = <span class="number">0</span>, vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">double</span> ratio = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[j] == points[i]) center++;   <span class="comment">// 至少包含一个中心点 points[i]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (points[j][<span class="number">0</span>] == points[i][<span class="number">0</span>]) vertical++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ratio = (<span class="keyword">long</span> <span class="keyword">double</span>)(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]) / (points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    cnt[ratio]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 垂线和斜线数量取较大者</span></span><br><span class="line">            <span class="keyword">int</span> mxratio = vertical;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : cnt) &#123;</span><br><span class="line">                mxratio = <span class="built_in">max</span>(mxratio, value);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mxratio + center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">LeetCode 149. 直线上最多的点数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;主要是考虑从哪个角度入手暴搜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1162. 地图分析</title>
    <link href="https://accepted.org.cn/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <id>https://accepted.org.cn/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</id>
    <published>2021-06-23T10:38:43.000Z</published>
    <updated>2021-06-26T03:28:20.766Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道经典的多源BFS题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你现在手里有一份大小为 $N*N$ 的 网格 $grid$，上面的每个 单元格 都用 $0$ 和 $1$ 标记好了。其中 $0$ 代表海洋，$1$ 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：$(x0, y0)$ 和 $(x1, y1)$ 这两个单元格之间的距离是 $|x0 - x1| + |y0 - y1|$ 。</p><p>如果网格上只有陆地或者海洋，请返回 $-1$。</p><p><strong>示例 1：</strong></p><p><img src="1.jpeg" alt="0x0"></p><blockquote><p>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="2.jpeg" alt="0x1"></p><blockquote><p>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</p></blockquote><p><strong>提示：</strong></p><ol><li>$1 &lt;= grid.length == grid[0].length &lt;= 100$</li><li>$grid[i][j]$ 不是 $0$ 就是 $1$</li></ol><hr><h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p>遍历数组，将所有岛屿入队，每次根据当前结点计算出下一个海洋结点，就将海洋结点值设为父结点的值加一。<br>于是，就像水中的多点扰动水面一样，最终涟漪交汇的地方就是最远海洋结点。</p><div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-23 18:47:28</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) q[++tt] = &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// determine special situation</span></span><br><span class="line">        <span class="keyword">int</span> qsize = tt - hh + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qsize == R * C || !qsize) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; ++hh) &#123;                         <span class="comment">// pop head</span></span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first, c = q[hh].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || grid[ner][nec]) <span class="keyword">continue</span>;</span><br><span class="line">                grid[ner][nec] = grid[r][c] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;ner, nec&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, grid[i][j]);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; grid[i][j] &lt;&lt; ' ';</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">LeetCode 1162. 地图分析</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道经典的多源BFS题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】D LeetCode 1906. 查询差绝对值的最小值</title>
    <link href="https://accepted.org.cn/2021/06/23/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91D-LeetCode-1906-%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://accepted.org.cn/2021/06/23/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91D-LeetCode-1906-%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2021-06-23T03:09:06.000Z</published>
    <updated>2021-06-26T09:05:27.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>前缀和配合计数排序，妙哉~！</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 相同 ，那么差绝对值的最小值为 <code>-1</code> 。</p><ul><li>比方说，数组 <code>[5,2,3,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li></ul><p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[li...ri]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[li...ri]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>li</code> 和 <code>ri</code> 之间的所有元素（包含 <code>li</code> 和 <code>ri</code> 在内）。</p><p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p><strong>子数组</strong> 是一个数组中连续的一段元素。</p><p><code>|x|</code> 的值定义为：</p><p>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。<br>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]<br>输出：[2,1,4,1]<br>解释：查询结果如下：<br>– queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。<br>– queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。<br>– queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。<br>– queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]<br>输出：[-1,1,1,3]<br>解释：查询结果如下：<br>– queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。<br>– queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。<br>– queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。<br>– queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 10^5$</li><li>$1 &lt;= nums[i] &lt;= 100$</li><li>$1 &lt;= queries.length &lt;= 2 * 10^4$</li><li>$0 &lt;= li &lt; ri &lt; nums.length$</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>先想想朴素做法，我们可以对于每一段查询获取一个子数组，对子数组排序，找到相邻数字差绝对值最小的数。</p><p>注意到数组元素的取值范围是 $1 &lt;= nums[i] &lt;= 100$, 因为范围很小所以很容易联想到计数排序。既然需要对子数组元素计数，自然联想到前缀和。</p><p>可以开一个二维数组，行表示为数组下标$+1$(因为前缀和需要考虑0的情况，避免出现值-1的下标)；列表示数组元素值在 $[1,100]$ 中的某个数。</p><p>遍历数组中的每个元素，再以当前元素为结束的前缀数组中，遍历 $[1,100]$ 中的每个数，对前缀数组进行计数。<br>注意当前行需要继承前一行的非零值。</p><p>举例：<br>对于数组 <code>nums = [1,3,4,8]</code> ,预处理出的前缀和数组为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>那么可以在 $O(1)$ 的时间复杂度下得到某一段子数组如第2到3的所有元素计数情况。接着，可以在 $O(N)$ 的复杂度下得到这段子数组的 最小差绝对值。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(len + <span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">110</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// presum </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;                    <span class="comment">// 第i行放入数组前0 ~ i - 1项的和，即从1开始数组第某项放在第某行中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (presum[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    presum[i][j] = presum[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            presum[i][nums[i - <span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt;= len; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt;= 100; j++) &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; presum[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++) &#123;          <span class="comment">// 对于每组查询，依次找到子数组中的数，找到最小差绝对值</span></span><br><span class="line">            <span class="keyword">int</span> l = queries[i][<span class="number">0</span>] + <span class="number">1</span>, r = queries[i][<span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 加1是因为l r是数组下标从0记起，而我们的前缀和是从1记起</span></span><br><span class="line">            <span class="keyword">int</span> tres = <span class="number">110</span>, last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;                <span class="comment">// 从小到大遍历子数组中的数</span></span><br><span class="line">                <span class="keyword">if</span> (presum[r][j] - presum[l - <span class="number">1</span>][j] &gt; <span class="number">0</span>) &#123;  <span class="comment">// 找到一个子数组中的数</span></span><br><span class="line">                    <span class="keyword">if</span> (last) &#123;                             <span class="comment">// 如果当前子数组的数不是第一个（可以产生一个差绝对值）</span></span><br><span class="line">                        tres = <span class="built_in">min</span>(tres, j - last);         <span class="comment">// 当前子数组的数和上一个子数组的数绝对值差为 j - last</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    last = j;                               <span class="comment">// 不管当前数字是不是第一个子数组的数，last 都要更新为当前子数组的数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果某段子数组中只包含一种元素，那么31行只会进入一次，且因为是第一个元素第一次进入，那么32行不会进入，那么tres不会得到更新</span></span><br><span class="line">            <span class="keyword">if</span> (tres != <span class="number">110</span>)</span><br><span class="line">                res.push_back(tres);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>下面来思考一下预处理前缀和数组的时候，为什么 <code>i</code> 从 <code>1</code> 开始，前缀和数组第 <code>0</code> 位留空。</p><p>首先我们假设前缀和数组就是从第 <code>0</code> 位开始，即 <code>presum[i]</code> 对应原数组 $[0,i]$ 位元素的和。会发生什么呢？<br>假设求从 <code>0</code> 开始计算的第 <code>4</code> 位到第 <code>5</code> 位子数组和，那么使用这样一个前缀和数组可得：<br><code>int res = presum[5] - presum[4 - 1];</code><br>似乎没有问题，好，那我现在求第 <code>0</code> 位到第 <code>3</code> 位子数组的和：<br><code>int res = presum[3] - presum[0 - 1];</code><br>数组下标出现负数，为了避免这种情况，只能多一次判断，不方便。</p><p>另外，在生成前缀和数组时，递推公式为：<code>presum[i] = presum[i - 1] + nums[i]</code>.<br>问题是，这个递推公式无法适配所有情况。即，当 <code>i</code> 取 <code>0</code> 时，出现异常。<br>为了避免这个情况，只能把 <code>presum[0]</code> 拿出来预设为 <code>nums[0]</code> ，从数组第 <code>1</code> 项接着按照递推公式计算。不方便。</p><p>那么，为了方便地避免以上情况，我们决定将前缀和数组相对原数组向右偏移一位，用 <code>presum[1]</code> 表示原数组第 <code>0</code> 项， <code>presum[2]</code> 表示原数组第 <code>[0,1]</code> 项之和，将 <code>presum[i]</code> 表示为数组中 $[0,i-1]$ 所有数之和。</p><p>那么，如果求原数组从零计第 <code>l</code> 项到 <code>r</code> 项子数组之和，那么<br><code>int res = presum[r + 1] - presum[l + 1 - 1];</code><br>因为 <code>presum[r]</code> 表示的是 $[0, r-1]$ 项之和， <code>presum[l]</code> 表示 $[0,l-1]$ 项之和。<br>另外，如果求原数组从1计算第 <code>l</code> 项到 <code>r</code> 项子数组之和，可以直接：<br><code>int res = presum[r] - presum[l - 1];</code></p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/" target="_blank" rel="noopener">LeetCode 1906. 查询差绝对值的最小值</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;前缀和配合计数排序，妙哉~！&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1249. 移除无效的括号</title>
    <link href="https://accepted.org.cn/2021/06/22/LeetCode-1249-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://accepted.org.cn/2021/06/22/LeetCode-1249-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-06-22T14:47:56.000Z</published>
    <updated>2021-06-26T09:16:50.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>华为面试题，时间不够没写出来，面试结束补上了，还是我太菜了。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code> 和小写字母组成的字符串 s。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 任意一条 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li><li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “lee(t(c)o)de)”<br>输出：”lee(t(c)o)de”<br>解释：”lee(t(co)de)” , “lee(t(c)ode)” 也是一个可行答案。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：s = “a)b(c)d”<br>输出：”ab(c)d”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：s = “))((“<br>输出：””<br>解释：空字符串也是有效的</p></blockquote><p><strong>示例 4：</strong></p><p>输入：s = “(a(b(c)d)”<br>输出：”a(b(c)d)”</p><p><strong>提示：</strong></p><ul><li>$ 1 &lt;= s.length &lt;= 10^5$</li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>维护一个栈，将所有有效括号对去除，剩下的就是字符串中多余的目标括号。为了将字符串中多余的括号去除，需要在栈中记录括号对应原字符串下标。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; stk[N];</span><br><span class="line">    <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'('</span>) stk[++tt] = &#123;c, i&#125;;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!tt || stk[tt].first != <span class="string">'('</span>) stk[++tt] = &#123;c, i&#125;;</span><br><span class="line">                    <span class="keyword">else</span> --tt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> (tt) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tt &amp;&amp; i == stk[tt].second) &#123;</span><br><span class="line">                    --tt;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener">LeetCode 1249. 移除无效的括号</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;华为面试题，时间不够没写出来，面试结束补上了，还是我太菜了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="栈" scheme="https://accepted.org.cn/tags/%E6%A0%88/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>HeXo文章分类管理</title>
    <link href="https://accepted.org.cn/2021/06/21/HeXo%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/"/>
    <id>https://accepted.org.cn/2021/06/21/HeXo%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-21T01:47:26.000Z</published>
    <updated>2021-06-21T02:04:08.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单记录下HeXo博客的文章分类管理。</p><a id="more"></a><h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><h4 id="单级分类"><a href="#单级分类" class="headerlink" title="单级分类"></a>单级分类</h4><p>对于一篇文章，在顶部的位置加上：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>A</span><br></pre></td></tr></table></figure><p>那么这篇文章就属于分类 <code>A</code>.</p><h4 id="多级分类"><a href="#多级分类" class="headerlink" title="多级分类"></a>多级分类</h4><p>如果再加上 <code>- B</code></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>A</span><br><span class="line"><span class="bullet">    - </span>B</span><br></pre></td></tr></table></figure><p>那么 <code>B</code> 是 <code>A</code> 的子类，文章属于 <code>A</code> 分类下的 <code>B</code> 分类。以此类推。</p><p>同样的，我们可以以一个列表形式展现文章的多级分类：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>[A, B]</span><br></pre></td></tr></table></figure><h4 id="共存的多级分类"><a href="#共存的多级分类" class="headerlink" title="共存的多级分类"></a>共存的多级分类</h4><p>那么，如果一篇文章既属于A又属于D，我们可以以多个列表同时分类：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>[A, B, C]</span><br><span class="line"><span class="bullet">    - </span>[D, E, F]</span><br></pre></td></tr></table></figure><p>文章既属于A类下的B类下的C类，又属于D分类下的E分类下的F分类。</p><div class="note primary">            <p><strong>相关链接：</strong> <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">HeXo Doc</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单记录下HeXo博客的文章分类管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
      <category term="博客" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://accepted.org.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="HeXo" scheme="https://accepted.org.cn/tags/HeXo/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】C LeetCode 5791. 统计子岛屿</title>
    <link href="https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91C-LeetCode-5791-%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/"/>
    <id>https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91C-LeetCode-5791-%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/</id>
    <published>2021-06-20T08:11:33.000Z</published>
    <updated>2021-06-26T09:20:22.788Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>洪水灌溉算法经典题型。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p><p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p><p><strong>示例 1：</strong><br><img src="test1.png" alt="0x0"></p><blockquote><p>输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]<br>输出：3<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。</p></blockquote><p><strong>示例 2：</strong><br><img src="testcasex2.png" alt="0x1"></p><blockquote><p>输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]<br>输出：2<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>m == grid1.length == grid2.length</code></li><li><code>n == grid1[i].length == grid2[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在 <code>grid2</code> 中找到所有岛屿，并且在寻找的过程中判断每一个块是否和 <code>grid1</code> 中对应块相等，不等必然不是子岛屿。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid2, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">bool</span> &amp;issub)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid2[r][c] != grid1[r][c]) issub = <span class="literal">false</span>;</span><br><span class="line">        grid2[r][c] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">            <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || !grid2[ner][nec] || grid2[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(grid1, grid2, ner, nec, issub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid2.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid2[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid2[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> issub = <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid1, grid2, i, j, issub);</span><br><span class="line">                    <span class="keyword">if</span> (issub) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>本题是 <a href="https://eetoa.github.io/2020/04/21/LeetCode-200-岛屿数量" target="_blank" rel="noopener">岛屿数量</a> 的升级版。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-sub-islands/" target="_blank" rel="noopener">5791. 统计子岛屿</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;洪水灌溉算法经典题型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
      <category term="Flood Fill" scheme="https://accepted.org.cn/tags/Flood-Fill/"/>
    
      <category term="洪水灌溉算法" scheme="https://accepted.org.cn/tags/%E6%B4%AA%E6%B0%B4%E7%81%8C%E6%BA%89%E7%AE%97%E6%B3%95/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】B LeetCode 5789. 你完成的完整对局数</title>
    <link href="https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91B-LeetCode-5789-%E4%BD%A0%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E5%B1%80%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91B-LeetCode-5789-%E4%BD%A0%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E5%B1%80%E6%95%B0/</id>
    <published>2021-06-20T06:26:47.000Z</published>
    <updated>2021-06-26T09:20:06.053Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道关于时间的题目。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <code>24</code> 小时制的时钟 ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p><p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>&quot;HH:MM&quot;</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p><ul><li>例如，如果 <code>startTime = &quot;05:20&quot;</code> 且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li></ul><p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code> ）。</p><p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：startTime = “12:01”, finishTime = “12:44”<br>输出：1<br>解释：你完成了从 12:15 到 12:30 的一个完整对局。<br>你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。<br>你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。</p></blockquote><p><strong>示例 2：</strong></p><p>输入：startTime = “20:00”, finishTime = “06:00”<br>输出：40<br>解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。<br>16 + 24 = 40</p><p><strong>示例 3：</strong></p><blockquote><p>输入：startTime = “00:00”, finishTime = “23:59”<br>输出：95<br>解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li><li>$00 &lt;= HH &lt;= 23$</li><li>$00 &lt;= MM &lt;= 59$</li><li><code>startTime</code> 和 <code>finishTime</code> 不相等</li></ul><hr><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>将时间转换为分钟数表示，如果结束时间小于开始时间，则将结束时间加上24小时。<br>问题就变成了求开始分钟数后的第一个15的倍数，以及结束时间分钟数前一个15的倍数。再求二者之间的长度共是15的倍数。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ctoi</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = (ctoi(s[<span class="number">0</span>]) * <span class="number">10</span> + ctoi(s[<span class="number">1</span>])) * <span class="number">60</span> + ctoi(s[<span class="number">3</span>]) * <span class="number">10</span> + ctoi(s[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">int</span> b = (ctoi(f[<span class="number">0</span>]) * <span class="number">10</span> + ctoi(f[<span class="number">1</span>])) * <span class="number">60</span> + ctoi(f[<span class="number">3</span>]) * <span class="number">10</span> + ctoi(f[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) b += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        <span class="comment">// 找到a右边第一个15的倍数和b左边第一个15的倍数</span></span><br><span class="line">        <span class="keyword">int</span> l = (<span class="keyword">int</span>)((a + <span class="number">14</span>) / <span class="number">15</span>) * <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (<span class="keyword">int</span>)(b / <span class="number">15</span>) * <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l)                  <span class="comment">// 当r 和 l之间至少有一个完整对局时或者二者不构成一个完整对局且分别某个对局时间点左右</span></span><br><span class="line">            <span class="keyword">return</span> (r - l) / <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">else</span>                       <span class="comment">// 当r和l同在一个完整对局区间内，会出现r &lt; l的情况</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>注意到c++是向零取整，<code>int c = b / a</code>;<br>如果想计算 <code>b / a</code> 向上取整，可以 <code>int c = (b + a - 1) / a</code>.<br>因为 <code>c = (b + a) / a</code> 刚好等于 <code>b / a向下取整 + 1</code>.</p><h3 id="优化：用sscanf将字符串分割为两个数字"><a href="#优化：用sscanf将字符串分割为两个数字" class="headerlink" title="优化：用sscanf将字符串分割为两个数字"></a>优化：用sscanf将字符串分割为两个数字</h3><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: yxc@acwing.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h, m;</span><br><span class="line">        <span class="built_in">sscanf</span>(s.c_str(), <span class="string">"%d:%d"</span>, &amp;h, &amp;m);</span><br><span class="line">        <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">get</span>(s), y = <span class="built_in">get</span>(f);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) y += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        x = (x + <span class="number">14</span>) / <span class="number">15</span>, y /= <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; x)</span><br><span class="line">            <span class="keyword">return</span> y - x;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/" target="_blank" rel="noopener">LeetCode 5789. 你完成的完整对局数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道关于时间的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】A LeetCode 5788. 字符串中的最大奇数</title>
    <link href="https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91A-LeetCode-5788-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%87%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91A-LeetCode-5788-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%87%E6%95%B0/</id>
    <published>2021-06-20T06:03:11.000Z</published>
    <updated>2021-06-26T09:05:54.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>寻找字符串中的最大奇数。</p><a id="more"></a><p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p><p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：num = “52”<br>输出：”5”<br>解释：非空子字符串仅有 “5”、”2” 和 “52” 。”5” 是其中唯一的奇数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：num = “4206”<br>输出：””<br>解释：在 “4206” 中不存在奇数。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：num = “35427”<br>输出：”35427”<br>解释：”35427” 本身就是一个奇数。</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= num.length &lt;= 10^5$</li><li>$num$ 仅由数字组成且不含前导零</li></ul><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>奇数最后一个数字一定是奇数，那么就从右向左找到第一个奇数数字，那么以该字符结尾的原字符串前缀就是最大奇数子串。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestOddNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((num.<span class="built_in">end</span>()[<span class="number">-1</span>]) &amp; <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> len = num.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num[i]) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num.substr(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>注意在判断数字字符的奇偶性时，可以直接判断。因为数字字符和对应的数字具有相同奇偶性。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/largest-odd-number-in-string/" target="_blank" rel="noopener">LeetCode 5788. 字符串中的最大奇数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;寻找字符串中的最大奇数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第五讲-动态规划-背包问题 AcWing 2. 01背包问题</title>
    <link href="https://accepted.org.cn/2021/06/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-AcWing-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://accepted.org.cn/2021/06/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-AcWing-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-18T08:59:36.000Z</published>
    <updated>2021-06-26T03:35:11.465Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>01背包模板题，非常纯粹。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong><br>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong><br>$0 &lt; N,V ≤ 1000$<br>$0 &lt; v_i,w_i ≤ 1000$</p><p><strong>输入样例</strong></p><blockquote><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>8</p></blockquote><hr><p>设 <code>i</code> 为前 <code>i</code> 件物品，<code>j</code> 为背包的最大容量。<br>设 <code>v[i]</code> 为第 <code>i</code> 件物品的体积，<code>w[i]</code> 为第 <code>i</code> 件物品的价值。</p><h3 id="二维dp数组"><a href="#二维dp数组" class="headerlink" title="二维dp数组"></a>二维dp数组</h3><p>题目要求前 $N$ 个物品，放入容量为 $V$ 的背包中，所得到的最大价值。<br>由此可以定义一个二维dp数组 <code>f[i][j]</code> 用以表示状态。</p><p><strong>状态集合：</strong> 前 <code>i</code> 个物品放入容量为 <code>j</code> 的背包中的所有情况所构成的集合。<br>其中 $1 &lt;= i &lt;= N, 1 &lt;= j &lt;= V$，即：<br>对于前 $1$ 件到前 $N$ 件中的每种情况，都分别对应背包容量从 $1$ 到 $V$ 的每种情况。所有情况构成了状态集合。</p><p><strong>状态集合元素属性：</strong> 对于集合中的每个元素，将产生的最大价值定义为它的属性放在二维dp数组中。即：<br><code>f[i][j]</code> 表示前 <code>i</code> 个物品放入容量为 <code>j</code> 的背包中，所对应的最大价值。</p><p><strong>状态计算：</strong> 现在思考如何计算 <code>f[i][j]</code> 的值。<br>对于前 <code>i</code> 件物品的第 <code>i</code> 件物品，只会有 「可放入」背包和「不可放入」背包两种情况。现在考虑哪些情况可放入哪些不可放入。</p><ul><li>不可放入第 <code>i</code> 件物品：很容易想到，当尝试放入第 <code>i</code> 件物品时，遇到背包容量限制的时候，必然不可放入。即：<br>当第 <code>i</code> 件的体积超出背包总体积时，必然不可放入（<code>j &lt; v[i]</code>）。<br>那么， <code>f[i][j]</code> 表示前 <code>i - 1</code> 件物品放入容量为 <code>j</code> 的背包中的最大价值。</li><li>可放入第 <code>i</code> 件物品：反之， <code>j &gt;= v[i]</code> ，即 <code>j - v[i] &gt;= 0</code> ，供前 <code>i - 1</code> 件物品放入的背包容量是大于零的。同时，注意，第 <code>i</code> 件可放可不放，没有条件限制。<br>那么， <code>f[i][j]</code> 表示前 <code>i - 1</code> 件物品放入容量为 <code>j - v[i]</code> 的背包中的最大价值和<br>第 <code>i</code> 件物品放入容量为 <code>j</code> 的背包中的最大价值，二者取较大者。</li></ul><p><strong>状态转移方程：</strong> 根据上述状态计算方式，可以得出状态转移方程分别为：</p><ul><li><code>f[i][j] = f[i - 1][j]</code></li><li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></li></ul><p>其中 <code>v[i]</code> 和 <code>w[i]</code> 分别为第 <code>i</code>件物品的体积和价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[i][j]: 前 i 件放在最大容量为j的包里，最大价值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(mxv + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造二维dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mxv; j++) &#123;    <span class="comment">// 从前 i 件放在最大容量为1的包里，到前 i 件放在最大容量为 mxv 的包里</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) &#123;   <span class="comment">// j - v[i] &gt;= 0，前 i - 1件物品放入容量为 j - v[i]的背包中，同时第i件可放可不放。</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// j &lt; v[i]背包全部容量都不够第i件物品的体积，必然不可放入</span></span><br><span class="line">                f[i][j] = f[i  - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维数组的构造过程也是逐步求解过程，数组最后一个值f[n][mxv]即为所求：对于前 n 件物品，放在容量为mxv的背包中的最大价值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维dp数组的空间优化"><a href="#一维dp数组的空间优化" class="headerlink" title="一维dp数组的空间优化"></a>一维dp数组的空间优化</h3><p>注意到二维dp的状态转移方程：</p><ul><li><code>f[i][j] = f[i - 1][j]</code></li><li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></li></ul><p>不难发现，前 <code>i</code> 件物品的最大价值只与前 <code>i - 1</code> 件物品有关。对应在二维数组中，第 <code>i</code> 行的计算只与第 <code>i - 1</code> 行有关。<br>不妨维护一个一维数组放入前 <code>i - 1</code> 件物品在不同容量背包下的最大价值。计算前 <code>i</code> 件物品的时候，可以直接使用，并完成更新为前 <code>i + 1</code> 件物品的计算做准备。</p><p>在一维dp中，考虑前 <code>i</code> 个物品在不同体积背包下的最大价值。<br>可定义一维数组：<code>f[j]</code> $(1 &lt;= j &lt;= V)$</p><p><strong>状态转移方程：</strong><br>下面我们尝试将二维状态转移方程压缩至一维：<br><code>f[i][j] = f[i - 1][j]</code> 可以直接等价于 <code>f[j] = f[j]</code><br><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code> 则可以等价于：<br><code>f[j] = max(f[j], f[j - v[i]] + w[i])</code></p><p>对于前 <code>i</code> 件物品，在计算 <code>f[j]</code> 的时候，注意 <code>f[j - v[i]]</code> 的来源：<br>首先应该明确 <code>f[j - v[i]]</code> 来自于前 <code>i - 1</code> 件物品的计算，即上一层循环得到的一位dp数组;<br>其次，<code>j</code> 大于 <code>j - v[i]</code> ，因为 <code>j - (j - v[i]) &gt; 0</code> ;<br>那么，为了计算前 <code>i</code> 件物品的最大价值，我们在更新当前的一维dp数组的时候需要使用到上一次计算前 <code>i - 1</code> 件物品的dp数组。<strong>其中，使用到的 <code>f[j - v[i]]</code> 在 <code>f[j]</code> 前面。</strong><br>那么，如果我们计算了 <code>f[j]</code> 的值，并且更新了 <code>f[j]</code> ，那么 <strong>随着 <code>j</code> 的增大，需要使用到 <code>f[j]</code> 的时候，上一层的信息已经被本层之前的计算覆盖了。</strong><br>为了解决更新第 <code>i</code> 次dp数组而不影响使用第 <code>i - 1</code> 次数组信息的问题，我们可以从大到小遍历体积：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(mxv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mxv; j &gt;= <span class="number">1</span>; j--) &#123;    <span class="comment">// 从前 i 件放在最大容量为mxv的包里，到前 i 件放在最大容量为 1 的包里</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i])</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                f[j] = f[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，不难看出只有当 <code>j &gt;= v[i]</code> 时dp数组会更新，所以：<br><code>for (int j = mxv; j &gt;= 1; j--)</code> 可以进一步优化成<br><code>for (int j = mxv; j &gt;= v[i]; j--)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(mxv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mxv; j &gt;= v[i]; j--) &#123;     <span class="comment">// 从前 i 件放在最大容量为mxv的包里，到前 i 件放在最大容量为 1 的包里</span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/activity/content/problem/content/997/1/" target="_blank" rel="noopener">AcWing 2. 01背包问题</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;01背包模板题，非常纯粹。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://accepted.org.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
      <category term="背包" scheme="https://accepted.org.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="01背包" scheme="https://accepted.org.cn/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>算法题由给定数据范围反推算法复杂度及算法内容</title>
    <link href="https://accepted.org.cn/2021/06/18/%E7%AE%97%E6%B3%95%E9%A2%98%E7%94%B1%E7%BB%99%E5%AE%9A%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
    <id>https://accepted.org.cn/2021/06/18/%E7%AE%97%E6%B3%95%E9%A2%98%E7%94%B1%E7%BB%99%E5%AE%9A%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</id>
    <published>2021-06-18T00:09:43.000Z</published>
    <updated>2021-06-26T09:25:21.508Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>可以从数据范围分析出大致的最高限度的复杂度要求</p><a id="more"></a><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ul><li>$n≤30$, 指数级别, dfs+剪枝，状态压缩dp</li><li>$n≤100 =&gt; O(n3)$，floyd，dp，高斯消元</li><li>$n≤1000 =&gt; O(n2)，O(n^2logn)$，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>$n≤10000 =&gt; O(n \sqrt n)$，块状链表、分块、莫队</li><li>$n≤100000 =&gt; O(nlogn)$ =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分</li><li>$n≤1000000 =&gt; O(n)$, 以及常数较小的 $O(nlogn)$ 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa</li><li>$n≤10000000 =&gt; O(n)$，双指针扫描、kmp、AC自动机、线性筛素数</li><li>$n≤10^9 =&gt; O(\sqrt n)$，判断质数</li><li>$n≤10^{18} =&gt; O(logn)$，最大公约数，快速幂</li><li>$n≤10^{1000} =&gt; O((logn)^2)$，高精度加减乘除</li><li>$n≤10^{100000} =&gt; O(logk×loglogk)$，k表示位数$O(logk×loglogk)$，k表示位数，高精度加减、FFT/NTT</li></ul><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://www.acwing.com/blog/content/32/" target="_blank" rel="noopener">由数据范围反推算法复杂度以及算法内容</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;可以从数据范围分析出大致的最高限度的复杂度要求&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="复杂度" scheme="https://accepted.org.cn/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛常用STL和其他c++知识点总结</title>
    <link href="https://accepted.org.cn/2021/06/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8STL%E5%92%8C%E5%85%B6%E4%BB%96c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://accepted.org.cn/2021/06/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8STL%E5%92%8C%E5%85%B6%E4%BB%96c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-11T13:32:03.000Z</published>
    <updated>2021-06-21T03:01:26.786Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>都是常用的。</p><a id="more"></a><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>对数组<code>vector&lt;int&gt; a</code>排序：<br><code>#include &lt;algorithm&gt;</code></p><ul><li><p>升序<br><code>sort(a.begin(), a.end());</code><br><code>sort(a.begin(), a.end(), less&lt;int&gt;());</code></p></li><li><p>降序<br><code>sort(a.begin(), a.end(), greater&lt;int&gt;());</code><br><code>sort(a.rbegin(), a.rend());</code></p></li></ul><h4 id="字符串转数值类型"><a href="#字符串转数值类型" class="headerlink" title="字符串转数值类型"></a>字符串转数值类型</h4><p><code>#include &lt;string&gt;</code><br><strong>std::atoi</strong><br>转换 const char* 为一个 int 类型整数，超出 int 类型范围时，返回边界值。</p><p><strong>std::atol</strong><br>转换 const char* 为一个 long 类型整数，超出 long 类型范围时，返回边界值。</p><p><strong>std::atoll</strong><br>转换 const char* 为一个 long long 类型整数，超出 long long 类型范围时，返回边界值。</p><p><strong>std::stoi</strong><br>转换 std::string 为一个 int 类型整数，超出 int 类型范围时报错。</p><p><strong>std::stol</strong><br>转换 std::string 为一个 long 类型整数，超出 long 类型范围时报错。</p><p><strong>std::stoll</strong><br>转换 std::string 为一个 long long 类型整数，超出 long long 类型范围时报错。</p><h3 id="其他C-知识点"><a href="#其他C-知识点" class="headerlink" title="其他C++知识点"></a>其他C++知识点</h3><h4 id="0x0-输出指定位的小数点或有效数字"><a href="#0x0-输出指定位的小数点或有效数字" class="headerlink" title="0x0 输出指定位的小数点或有效数字"></a>0x0 输出指定位的小数点或有效数字</h4><p><strong>举例：</strong><br><code>float a = 233.233;</code></p><ul><li><p>输出保留2位小数:<br><code>inlcude &lt;iomanip&gt;</code><br><code>cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; a;</code><br>四舍五入输出<code>233.23</code><br>其中，<code>setiosflags(ios::fixed)</code> 为设置浮点数以固定的小数位数显示。<br><code>setprecision(2)</code> 为设置精度为2.</p></li><li><p>输出保留5位有效数字<br><code>cout &lt;&lt; setprecision(5) &lt;&lt; a;</code><br>四舍五入输出<code>233.23</code></p></li></ul><div class="note primary">            <p><strong>参考链接：</strong> <a href="https://www.cnblogs.com/ysx1997/p/7753579.html" target="_blank" rel="noopener">C++ 如何保留两位小数和有效位数</a></p>          </div><div class="note primary">            <p><strong>参考链接：</strong> <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/10705252.html" target="_blank" rel="noopener">C++ 标准库之 iomanip 、操作符 ios::fixed 以及 setprecision 使用的惨痛教训经验总结</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;都是常用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="STL" scheme="https://accepted.org.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1091. 二进制矩阵中的最短路径</title>
    <link href="https://accepted.org.cn/2021/06/06/LeetCode-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>https://accepted.org.cn/2021/06/06/LeetCode-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2021-06-06T15:20:56.000Z</published>
    <updated>2021-06-26T03:25:23.398Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS模板题</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p><p>二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p><ul><li>路径途经的所有单元格都的值都是 0 。</li><li>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li></ul><p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p><p><strong>示例 1：</strong></p><blockquote><p><img src="example1_1.png" alt="0x0"><br>输入：grid = [[0,1],[1,0]]<br>输出：2</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><img src="example2_1.png" alt="0x1"><br>输入：grid = [[0,0,0],[1,1,0],[1,1,0]]<br>输出：4</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：grid = [[1,0,0],[1,1,0],[1,1,0]]<br>输出：-1</p></blockquote><p><strong>提示：</strong></p><ul><li>$n == grid.length$</li><li>$n == grid[i].length$</li><li>$1 &lt;= n &lt;= 100$</li><li>$grid[i][j]$ 为 $0$ 或 $1$</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dc[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">        pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] || !R) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        q[++tt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, <span class="number">1</span>&#125;;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh;)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; node = q[hh++];</span><br><span class="line">            <span class="comment">// determin if current node is end of grids</span></span><br><span class="line">            <span class="keyword">int</span> r = node.first.first, c = node.first.second, len = node.second;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; r &lt;&lt; "-" &lt;&lt; c &lt;&lt; "-" &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (r == R - <span class="number">1</span> &amp;&amp; c == C - <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i];</span><br><span class="line">                <span class="keyword">int</span> nec = c + dc[i];</span><br><span class="line">                <span class="keyword">int</span> nel = len + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// determin if in range</span></span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; R &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; C &amp;&amp; !grid[ner][nec])    <span class="comment">// valid node</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; ner &lt;&lt; "-" &lt;&lt; nec &lt;&lt; "-" &lt;&lt; nel &lt;&lt; endl;</span></span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, nel&#125;;</span><br><span class="line">                    grid[ner][nec] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>咱们来思考一个问题：<br>Q: 为什么首先到达终点的路径一定是最短的？<br>A: 对于基于某个点的下一层，路径长度相等。因为BFS借助队列实现，如果存在两条不同长度的路径，那么可以认为他们之间是「平行」的，可以在某点处分道扬镳，最短路径一定最先抵达终点。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">LeetCode 1091. 二进制矩阵中的最短路径</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS模板题&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
      <category term="Flood Fill" scheme="https://accepted.org.cn/tags/Flood-Fill/"/>
    
      <category term="洪水灌溉算法" scheme="https://accepted.org.cn/tags/%E6%B4%AA%E6%B0%B4%E7%81%8C%E6%BA%89%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在LeetCode刷题应尽量避免使用全局变量</title>
    <link href="https://accepted.org.cn/2021/06/06/%E5%9C%A8LeetCode%E5%88%B7%E9%A2%98%E5%BA%94%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/06/06/%E5%9C%A8LeetCode%E5%88%B7%E9%A2%98%E5%BA%94%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</id>
    <published>2021-06-06T15:10:19.000Z</published>
    <updated>2021-06-21T11:01:37.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>会导致奇怪问题。</p><a id="more"></a><p>力扣的判题机在读取您的代码后，对每个测试用例，都会初始化一次类，但全局变量和类内静态变量需要您手动初始化。<br>但有时候即便手动初始化依然出错，所以应当尽量将变量初始化在类中。<br>但是，有时候初始化超大数组又不得不在堆上创建，所以这种事情还得根据实际情况自己权衡一下。</p><div class="note primary">            <p><strong>相关链接：</strong> <a href="https://support.leetcode-cn.com/hc/kb/article/1194344/" target="_blank" rel="noopener">某些测试用例下，执行代码返回结果正确，但提交解答却出错了</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;会导致奇怪问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>最小公倍数lcm算法</title>
    <link href="https://accepted.org.cn/2021/05/30/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm%E7%AE%97%E6%B3%95/"/>
    <id>https://accepted.org.cn/2021/05/30/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm%E7%AE%97%E6%B3%95/</id>
    <published>2021-05-30T08:00:53.000Z</published>
    <updated>2021-06-26T09:23:57.198Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>最小公倍数 = 两数乘积 / 最大公约数</p><a id="more"></a><p>因为 <strong>最小公倍数 = 两数乘积 / 最大公约数</strong>，<br>所以:</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>相关链接：</strong> <a href="https://eetoa.github.io/2020/03/27/求最大公约数（gcd）的一点心得" target="_blank" rel="noopener">求最大公约数（gcd）的一点心得</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;最小公倍数 = 两数乘积 / 最大公约数&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="最大公约数" scheme="https://accepted.org.cn/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    
      <category term="gcd" scheme="https://accepted.org.cn/tags/gcd/"/>
    
      <category term="最小公倍数" scheme="https://accepted.org.cn/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    
      <category term="lcm" scheme="https://accepted.org.cn/tags/lcm/"/>
    
  </entry>
  
  <entry>
    <title>C++算法题输入输出小技巧总结</title>
    <link href="https://accepted.org.cn/2021/05/29/C-%E7%AE%97%E6%B3%95%E9%A2%98%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://accepted.org.cn/2021/05/29/C-%E7%AE%97%E6%B3%95%E9%A2%98%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-29T12:44:47.000Z</published>
    <updated>2021-06-21T10:52:51.563Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>OJ输入输出小技巧总结。</p><a id="more"></a><h3 id="输入一行没有空格的字符串"><a href="#输入一行没有空格的字符串" class="headerlink" title="输入一行没有空格的字符串"></a>输入一行没有空格的字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br></pre></td></tr></table></figure><h3 id="输入一行带有空格的字符串"><a href="#输入一行带有空格的字符串" class="headerlink" title="输入一行带有空格的字符串"></a>输入一行带有空格的字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure><h3 id="循环输入直到无数据源"><a href="#循环输入直到无数据源" class="headerlink" title="循环输入直到无数据源"></a>循环输入直到无数据源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">cin</span> &gt;&gt; a; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stringstream-流式输入"><a href="#stringstream-流式输入" class="headerlink" title="stringstream 流式输入"></a>stringstream 流式输入</h3><p>很方便地进行字符串分割和字符串到其他类型的转换。</p><ul><li>输入：<br>1 2 3 4 5 6 7 8 9<br>34 56 85 19 0 88<br>995 668<br>10086</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ar[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; getline(<span class="built_in">cin</span>, s);) &#123;</span><br><span class="line">        ss &lt;&lt; s;    <span class="comment">// 将s放入ss中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; ss &gt;&gt; t; i++) &#123;</span><br><span class="line">            ar[i] = t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提高输入输出效率"><a href="#提高输入输出效率" class="headerlink" title="提高输入输出效率"></a>提高输入输出效率</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// start cin or cout</span></span><br></pre></td></tr></table></figure><p>对于大量数据输入，少量输出的情况，可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="Class模式的OJ（如LeetCode）提高输入输出"><a href="#Class模式的OJ（如LeetCode）提高输入输出" class="headerlink" title="Class模式的OJ（如LeetCode）提高输入输出"></a>Class模式的OJ（如LeetCode）提高输入输出</h3><p>很简单，直接在class外写上如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off=[]()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>举例：</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey" target="_blank" rel="noopener">牛客剑指Offer JZ35. 数组中的逆序对</a></p>          </div><p>使用前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">1000010</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int _mod = 1000000007;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        helper(<span class="number">0</span>, n - <span class="number">1</span>, data);</span><br><span class="line">        <span class="keyword">return</span> cnt % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        helper(lo, mid, data), helper(mid + <span class="number">1</span>, hi, data);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// backtrack       </span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// merge sort and compare</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt;= data[j]) tmp[idx] = data[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[idx] = data[j++];</span><br><span class="line">                cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = data[i++];</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= hi;) tmp[idx++] = data[j++];</span><br><span class="line">        <span class="comment">// override</span></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>, i = lo; i &lt;= hi;) data[i++] = tmp[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>运行时间： 113 ms</p></blockquote><p>使用后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off=[]()&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">1000010</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int _mod = 1000000007;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        helper(<span class="number">0</span>, n - <span class="number">1</span>, data);</span><br><span class="line">        <span class="keyword">return</span> cnt % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        helper(lo, mid, data), helper(mid + <span class="number">1</span>, hi, data);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// backtrack       </span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// merge sort and compare</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt;= data[j]) tmp[idx] = data[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[idx] = data[j++];</span><br><span class="line">                cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = data[i++];</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= hi;) tmp[idx++] = data[j++];</span><br><span class="line">        <span class="comment">// override</span></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>, i = lo; i &lt;= hi;) data[i++] = tmp[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>运行时间： 79 ms</p></blockquote><p>舒服了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;OJ输入输出小技巧总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>b-1面试题总结-Java基础</title>
    <link href="https://accepted.org.cn/2021/04/21/b-1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://accepted.org.cn/2021/04/21/b-1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-21T09:01:43.572Z</published>
    <updated>2021-04-22T13:26:14.353Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>摘要：</strong><br>在原作基础上添加学习笔记。</p><a id="more"></a><h1 id="二-Java-基础-集合-多线程-JVM"><a href="#二-Java-基础-集合-多线程-JVM" class="headerlink" title="二 Java 基础+集合+多线程+JVM"></a>二 Java 基础+集合+多线程+JVM</h1><blockquote><p>作者：Guide 哥。</p><p><strong>介绍:</strong> Github 90k Star 项目 <strong><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></strong>（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取 Java 工程师必备学习资料+面试突击 pdf。</p></blockquote><h2 id="2-1-Java-基础"><a href="#2-1-Java-基础" class="headerlink" title="2.1. Java 基础"></a>2.1. Java 基础</h2><h3 id="2-1-1-面向对象和面向过程的区别"><a href="#2-1-1-面向对象和面向过程的区别" class="headerlink" title="2.1.1. 面向对象和面向过程的区别"></a>2.1.1. 面向对象和面向过程的区别</h3><ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li><li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul><p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431" target="_blank" rel="noopener">面向过程 ：面向过程性能比面向对象高？？</a></p><blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p></blockquote><h3 id="2-1-2-Java-语言有哪些特点"><a href="#2-1-2-Java-语言有哪些特点" class="headerlink" title="2.1.2. Java 语言有哪些特点?"></a>2.1.2. Java 语言有哪些特点?</h3><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><blockquote><p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544" target="_blank" rel="noopener">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread" target="_blank" rel="noopener">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p></blockquote><h3 id="2-1-3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#2-1-3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="2.1.3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>2.1.3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h3><h4 id="2-1-3-1-JVM"><a href="#2-1-3-1-JVM" class="headerlink" title="2.1.3.1. JVM"></a>2.1.3.1. JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。<u>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是 <strong>编译与解释共存</strong> 的语言。</u></p><blockquote><p>Q: 编译什么？解释什么？</p></blockquote><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h4 id="2-1-3-2-JDK-和-JRE"><a href="#2-1-3-2-JDK-和-JRE" class="headerlink" title="2.1.3.2. JDK 和 JRE"></a>2.1.3.2. JDK 和 JRE</h4><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h3 id="2-1-4-Oracle-JDK-和-OpenJDK-的对比"><a href="#2-1-4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="2.1.4. Oracle JDK 和 OpenJDK 的对比"></a>2.1.4. Oracle JDK 和 OpenJDK 的对比</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p><blockquote><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p><p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p></blockquote><p><strong>总结：</strong></p><ol><li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。" target="_blank" rel="noopener">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。</a></li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ol><h3 id="2-1-5-Java-和-C-的区别"><a href="#2-1-5-Java-和-C-的区别" class="headerlink" title="2.1.5. Java 和 C++的区别?"></a>2.1.5. Java 和 C++的区别?</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">https://blog.csdn.net/sszgg2006/article/details/49148189</a><blockquote><p>Q: 为什么Java语言中字符串末尾不需要结束符？</p></blockquote></li></ul><h3 id="2-1-6-字符型常量和字符串常量的区别"><a href="#2-1-6-字符型常量和字符串常量的区别" class="headerlink" title="2.1.6. 字符型常量和字符串常量的区别?"></a>2.1.6. 字符型常量和字符串常量的区别?</h3><ol><li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li></ol><blockquote><p>java 编程思想第四版：2.2.2 节<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt=""></p></blockquote><h3 id="2-1-7-构造器-Constructor-是否可被-override"><a href="#2-1-7-构造器-Constructor-是否可被-override" class="headerlink" title="2.1.7. 构造器 Constructor 是否可被 override?"></a>2.1.7. 构造器 Constructor 是否可被 override?</h3><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h3 id="2-1-8-重载和重写的区别"><a href="#2-1-8-重载和重写的区别" class="headerlink" title="2.1.8. 重载和重写的区别"></a>2.1.8. 重载和重写的区别</h3><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><p><strong>重载：</strong></p><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>下面是《Java 核心技术》对重载这个概念的介绍：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt=""></p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><p><strong>重写：</strong></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p><p>暖心的 Guide 哥最后再来个图表总结一下！</p><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892" target="_blank" rel="noopener">issue#892</a> ）：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⭐️ 关于 <strong>重写的返回值类</strong>型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超级英雄"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超人"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超级超级英雄"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SuperMan <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-9-Java-面向对象编程三大特性-封装-继承-多态"><a href="#2-1-9-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="2.1.9. Java 面向对象编程三大特性: 封装 继承 多态"></a>2.1.9. Java 面向对象编程三大特性: 封装 继承 多态</h3><h4 id="2-1-9-1-封装"><a href="#2-1-9-1-封装" class="headerlink" title="2.1.9.1. 封装"></a>2.1.9.1. 封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="2-1-9-2-继承"><a href="#2-1-9-2-继承" class="headerlink" title="2.1.9.2. 继承"></a>2.1.9.2. 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="2-1-9-3-多态"><a href="#2-1-9-3-多态" class="headerlink" title="2.1.9.3. 多态"></a>2.1.9.3. 多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h3 id="2-1-10-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#2-1-10-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="2.1.10. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>2.1.10. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3><p><strong>可变性</strong></p><p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p><blockquote><p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p></blockquote><p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是 <code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p><p><code>AbstractStringBuilder.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q: 为什么String类型是不可变的？<br>Q: 为什么 <code>StringBuffer</code> 是线程安全的？</p></blockquote><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h3 id="2-1-11-自动装箱与拆箱"><a href="#2-1-11-自动装箱与拆箱" class="headerlink" title="2.1.11. 自动装箱与拆箱"></a>2.1.11. 自动装箱与拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a></p><blockquote><p>Q: 装箱和拆箱底层是怎么实现的？<br>A: 装箱过程是通过调用包装器的 <code>ValueOf</code> 方法实现的；拆箱过程是通过调用包装器的 <code>&lt;int/double/float...&gt;Value</code>实现的。</p></blockquote><h3 id="2-1-12-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#2-1-12-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="2.1.12. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>2.1.12. 在一个静态方法内调用一个非静态成员为什么是非法的?</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h3 id="2-1-13-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#2-1-13-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="2.1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>2.1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><blockquote><p>Q: 我们知道，如果一个类没有声明构造方法，却可以拥有一个默认的构造方法。那么，为什么还需要定义不带参没有内容的构造方法，以供子类加载呢？<br>A: <del>因为如果类没有定义构造方法，是编译器在将java文件 <strong>编译</strong> 成.class文件的的时候自动为类添加无参构造方法。而子类需要在 <strong>类加载</strong> 的验证阶段检查父类的数据，初始化父类。</del></p></blockquote><h3 id="2-1-14-接口和抽象类的区别是什么？"><a href="#2-1-14-接口和抽象类的区别是什么？" class="headerlink" title="2.1.14. 接口和抽象类的区别是什么？"></a>2.1.14. 接口和抽象类的区别是什么？</h3><ol><li>接口的方法默认是 <code>public</code>，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了 <code>static</code>、<code>final</code> 变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 <code>extends</code> 关键字扩展多个接口。</li><li>接口方法默认修饰符是 <code>public</code>，抽象方法可以有 <code>public</code>、<code>protected</code> 和 <code>default</code> 这些修饰符（抽象方法就是为了被重写所以不能使用 <code>private</code> 关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><blockquote><p>备注：</p><ol><li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/146</a>。</li><li>jdk9 的接口被允许定义私有方法 。</li></ol></blockquote><p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/" target="_blank" rel="noopener">相关阅读</a>）：</p><ol><li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li><li>jdk 8 的时候接口可以有默认方法和静态方法功能。</li><li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li></ol><h3 id="2-1-15-成员变量与局部变量的区别有哪些？"><a href="#2-1-15-成员变量与局部变量的区别有哪些？" class="headerlink" title="2.1.15. 成员变量与局部变量的区别有哪些？"></a>2.1.15. 成员变量与局部变量的区别有哪些？</h3><ol><li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h3 id="2-1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2.1.16. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2.1.16. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h3 id="2-1-17-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#2-1-17-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="2.1.17. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>2.1.17. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h3 id="2-1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#2-1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="2.1.18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>2.1.18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="2-1-19-构造方法有哪些特性？"><a href="#2-1-19-构造方法有哪些特性？" class="headerlink" title="2.1.19. 构造方法有哪些特性？"></a>2.1.19. 构造方法有哪些特性？</h3><ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h3 id="2-1-20-静态方法和实例方法有何不同"><a href="#2-1-20-静态方法和实例方法有何不同" class="headerlink" title="2.1.20. 静态方法和实例方法有何不同"></a>2.1.20. 静态方法和实例方法有何不同</h3><ol><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p></li></ol><h3 id="2-1-21-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#2-1-21-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="2.1.21. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>2.1.21. 对象的相等与指向他们的引用相等,两者有什么不同?</h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="2-1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#2-1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="2.1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>2.1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作。</p><h3 id="2-1-23-与-equals-重要"><a href="#2-1-23-与-equals-重要" class="headerlink" title="2.1.23. == 与 equals(重要)"></a>2.1.23. == 与 equals(重要)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h3 id="2-1-24-hashCode-与-equals-重要"><a href="#2-1-24-hashCode-与-equals-重要" class="headerlink" title="2.1.24. hashCode 与 equals (重要)"></a>2.1.24. hashCode 与 equals (重要)</h3><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p><p><strong>1)hashCode()介绍:</strong></p><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>2)为什么要有 hashCode？</strong></p><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><blockquote><p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p><p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p><p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><h3 id="2-1-25-为什么-Java-中只有值传递？"><a href="#2-1-25-为什么-Java-中只有值传递？" class="headerlink" title="2.1.25. 为什么 Java 中只有值传递？"></a>2.1.25. 为什么 Java 中只有值传递？</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>下面通过 3 个例子来给大家说明</strong></p><blockquote><p><strong>example 1</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg" alt="example 1 "></p><p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><blockquote><p><strong>example 2</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">change(arr);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg" alt="example 2"></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><blockquote><p><strong>example 3</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br><span class="line">System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">Student temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>交换之前：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg" alt=""></p><p>交换之后：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg" alt=""></p><p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><blockquote><p><strong>总结</strong></p></blockquote><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p><strong>参考：</strong></p><p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p><h3 id="2-1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#2-1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="2.1.26. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>2.1.26. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。<br>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h3 id="2-1-27-线程有哪些基本状态"><a href="#2-1-27-线程有哪些基本状态" class="headerlink" title="2.1.27. 线程有哪些基本状态?"></a>2.1.27. 线程有哪些基本状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h3 id="2-1-28-关于-final-关键字的一些总结"><a href="#2-1-28-关于-final-关键字的一些总结" class="headerlink" title="2.1.28. 关于 final 关键字的一些总结"></a>2.1.28. 关于 final 关键字的一些总结</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li><li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li></ol><h3 id="2-1-29-Java-中的异常处理"><a href="#2-1-29-Java-中的异常处理" class="headerlink" title="2.1.29. Java 中的异常处理"></a>2.1.29. Java 中的异常处理</h3><h4 id="2-1-29-1-Java-异常类层次结构图"><a href="#2-1-29-1-Java-异常类层次结构图" class="headerlink" title="2.1.29.1. Java 异常类层次结构图"></a>2.1.29.1. Java 异常类层次结构图</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p><p style="font-size:13px;text-align:right">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt=""></p><p style="font-size:13px;text-align:right">图片来自：https://chercher.tech/java-programming/exceptions-java</p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p><strong>受检查异常</strong></p><p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p><p><strong>不受检查异常</strong></p><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPoin​terException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p><h4 id="2-1-29-2-Throwable-类常用方法"><a href="#2-1-29-2-Throwable-类常用方法" class="headerlink" title="2.1.29.2. Throwable 类常用方法"></a>2.1.29.2. Throwable 类常用方法</h4><ul><li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h4 id="2-1-29-3-异常处理总结"><a href="#2-1-29-3-异常处理总结" class="headerlink" title="2.1.29.3. 异常处理总结"></a>2.1.29.3. 异常处理总结</h4><ul><li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li><li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p><ol><li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p><p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h3 id="2-1-30-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#2-1-30-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="2.1.30. Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>2.1.30. Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p><h3 id="2-1-31-获取用键盘输入常用的两种方法"><a href="#2-1-31-获取用键盘输入常用的两种方法" class="headerlink" title="2.1.31. 获取用键盘输入常用的两种方法"></a>2.1.31. 获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p>方法 2：通过 BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure><h3 id="2-1-32-Java-中-IO-流"><a href="#2-1-32-Java-中-IO-流" class="headerlink" title="2.1.32. Java 中 IO 流"></a>2.1.32. Java 中 IO 流</h3><h4 id="2-1-32-1-Java-中-IO-流分为几种"><a href="#2-1-32-1-Java-中-IO-流分为几种" class="headerlink" title="2.1.32.1. Java 中 IO 流分为几种?"></a>2.1.32.1. Java 中 IO 流分为几种?</h4><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p><p>按操作对象分类结构图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p><h4 id="2-1-32-2-既然有了字节流-为什么还要有字符流"><a href="#2-1-32-2-既然有了字节流-为什么还要有字符流" class="headerlink" title="2.1.32.2. 既然有了字节流,为什么还要有字符流?"></a>2.1.32.2. 既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h4 id="2-1-32-3-BIO-NIO-AIO-有什么区别"><a href="#2-1-32-3-BIO-NIO-AIO-有什么区别" class="headerlink" title="2.1.32.3. BIO,NIO,AIO 有什么区别?"></a>2.1.32.3. BIO,NIO,AIO 有什么区别?</h4><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h3 id="2-1-33-深拷贝-vs-浅拷贝"><a href="#2-1-33-深拷贝-vs-浅拷贝" class="headerlink" title="2.1.33. 深拷贝 vs 浅拷贝"></a>2.1.33. 深拷贝 vs 浅拷贝</h3><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p><h3 id="2-1-34-参考"><a href="#2-1-34-参考" class="headerlink" title="2.1.34. 参考"></a>2.1.34. 参考</h3><ul><li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre" target="_blank" rel="noopener">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li><li><a href="https://www.educba.com/oracle-vs-openjdk/" target="_blank" rel="noopener">https://www.educba.com/oracle-vs-openjdk/</a></li><li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top" target="_blank" rel="noopener">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li></ul><h3 id="2-1-35-公众号"><a href="#2-1-35-公众号" class="headerlink" title="2.1.35. 公众号"></a>2.1.35. 公众号</h3><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《JavaGuide 面试突击版》 :</strong> 由本文档衍生的专为面试而生的《JavaGuide 面试突击版》 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java 面试突击”</strong> 即可免费领取！</p><p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;在原作基础上添加学习笔记。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【游戏逆向】LEA指令</title>
    <link href="https://accepted.org.cn/2021/04/19/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91LEA%E6%8C%87%E4%BB%A4/"/>
    <id>https://accepted.org.cn/2021/04/19/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91LEA%E6%8C%87%E4%BB%A4/</id>
    <published>2021-04-19T07:35:56.000Z</published>
    <updated>2021-06-21T03:48:18.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>举例解释Lea汇编指令的用法和含义。</p><a id="more"></a><p>As others have pointed out, LEA (load effective address) is often used as a “trick” to do certain computations, but that’s not its primary purpose. The x86 instruction set was designed to support high-level languages like Pascal and C, where arrays—especially arrays of ints or small structs—are common. Consider, for example, a struct representing (x, y) coordinates:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> xcoord;</span><br><span class="line">     <span class="keyword">int</span> ycoord;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now imagine a statement like:</p><p><code>int y = points[i].ycoord;</code></p><p>where <code>points[]</code> is an array of Point. Assuming the base of the array is already in <code>EBX</code> , and variable <code>i</code> is in <code>EAX</code> , and <code>xcoord</code> and <code>ycoord</code> are each 32 bits (so <code>ycoord</code> is at offset 4 bytes in the struct), this statement can be compiled to:</p><p><code>MOV EDX, [EBX + 8*EAX + 4]    ; right side is &quot;effective address&quot;</code></p><p>which will land <code>y</code> in <code>EDX</code>. The scale factor of 8 is because each <code>Point</code> is 8 bytes in size. Now consider the same expression used with the “address of” operator &amp;:</p><p><code>int *p = &amp;points[i].ycoord;</code></p><p>In this case, you don’t want the value of <code>ycoord</code>, but its address. That’s where LEA (load effective address) comes in. Instead of a <code>MOV</code>, the compiler can generate</p><p><code>LEA ESI, [EBX + 8*EAX + 4]</code></p><p>which will load the address in <code>ESI</code>.</p><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://stackoverflow.com/a/1665570/15451978" target="_blank" rel="noopener">I. J. Kennedy’s@stackoverflow.com</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;举例解释Lea汇编指令的用法和含义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
    
      <category term="游戏逆向" scheme="https://accepted.org.cn/tags/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91/"/>
    
      <category term="汇编" scheme="https://accepted.org.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>【游戏逆向】判断内存Page是否可读</title>
    <link href="https://accepted.org.cn/2021/04/17/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%88%A4%E6%96%AD%E5%86%85%E5%AD%98Page%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AF%BB/"/>
    <id>https://accepted.org.cn/2021/04/17/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%88%A4%E6%96%AD%E5%86%85%E5%AD%98Page%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AF%BB/</id>
    <published>2021-04-17T15:08:28.000Z</published>
    <updated>2021-04-17T15:10:51.379Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>这个方法可以判断指定内存地址是否可读。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Memory access check</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsMemoryReadable</span><span class="params">(<span class="keyword">uintptr_t</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> length = <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> read_access</span><br><span class="line">=(PAGE_READONLY</span><br><span class="line">| PAGE_READWRITE </span><br><span class="line">| PAGE_WRITECOPY </span><br><span class="line">| PAGE_EXECUTE_READ </span><br><span class="line">| PAGE_EXECUTE_READWRITE </span><br><span class="line">| PAGE_EXECUTE_WRITECOPY);</span><br><span class="line"><span class="comment">//structure to pass to virtual query which will be populated with the page's information</span></span><br><span class="line">MEMORY_BASIC_INFORMATION mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//virtual query returns information on a page</span></span><br><span class="line"><span class="comment">//if you don't know what a page is , it's basically a contiguous block of memory</span></span><br><span class="line"><span class="comment">//query for information starting at base</span></span><br><span class="line"><span class="keyword">if</span> (VirtualQuery(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(base), &amp;mbi, <span class="keyword">sizeof</span>(mbi)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//check read protections. if the page has one of the listed access protections, we can successfully read from it</span></span><br><span class="line"><span class="keyword">if</span> (!(mbi.Protect &amp; read_access))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//When a process COMMITS a region of virtual memory, the operating system guarantees that it can maintain all the data </span></span><br><span class="line"><span class="comment">//the process stores in the memory either in physical memory or on disk.</span></span><br><span class="line"><span class="comment">//so check for MEM_COMMIT because this means the page is able to store data</span></span><br><span class="line"><span class="comment">//if this is MEM_RESERVE OR MEM_FREE we don't want to attempt a read</span></span><br><span class="line"><span class="keyword">if</span> (!(mbi.State &amp; MEM_COMMIT))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make sure the page is not guarded and has access. attempts to read or access these kinds of pages will result in an access violation</span></span><br><span class="line"><span class="keyword">if</span> (mbi.Protect &amp; (PAGE_GUARD | PAGE_NOACCESS))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the start and end of the page</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(mbi.BaseAddress);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">end</span> = <span class="keyword">static_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(start + mbi.RegionSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">//check if our memory is within the readable region.</span></span><br><span class="line"><span class="keyword">return</span> (base &gt;= start) &amp;&amp; ((base + length) &lt;= <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://guidedhacking.com/threads/checking-for-readable-memory-c.9822/" target="_blank" rel="noopener">Checking For Readable Memory C++</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;这个方法可以判断指定内存地址是否可读。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
    
      <category term="游戏逆向" scheme="https://accepted.org.cn/tags/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
