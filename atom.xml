<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dirac Sea</title>
  
  <subtitle>where the water tastes like wine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://accepted.org.cn/"/>
  <updated>2021-06-30T15:34:01.172Z</updated>
  <id>https://accepted.org.cn/</id>
  
  <author>
    <name>etoa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【LeetCode双周赛55】B LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-30T15:23:56.000Z</published>
    <updated>2021-06-30T15:34:01.172Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单字符串替换。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 $s$ 和 $part$ ，请你对 $s$ 反复执行以下操作直到 <strong>所有</strong> 子字符串 $part$ 都被删除：</p><ul><li>找到 $s$ 中 <strong>最左边</strong> 的子字符串 $part$ ，并将它从 $s$ 中删除。</li></ul><p>请你返回从 $s$ 中删除所有 $part$ 子字符串以后得到的剩余字符串。</p><p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “daabcbaabcbc”, part = “abc”<br>输出：”dab”<br>解释：以下操作按顺序执行：</p></blockquote><ul><li>s = “daabcbaabcbc” ，删除下标从 2 开始的 “abc” ，得到 s = “dabaabcbc” 。</li><li>s = “dabaabcbc” ，删除下标从 4 开始的 “abc” ，得到 s = “dababc” 。</li><li>s = “dababc” ，删除下标从 3 开始的 “abc” ，得到 s = “dab” 。<br>此时 s 中不再含有子字符串 “abc” 。</li></ul><p><strong>示例 2：</strong></p><p>输入：s = “axxxxyyyyb”, part = “xy”<br>输出：”ab”<br>解释：以下操作按顺序执行：</p><ul><li>s = “axxxxyyyyb” ，删除下标从 4 开始的 “xy” ，得到 s = “axxxyyyb” 。</li><li>s = “axxxyyyb” ，删除下标从 3 开始的 “xy” ，得到 s = “axxyyb” 。</li><li>s = “axxyyb” ，删除下标从 2 开始的 “xy” ，得到 s = “axyb” 。</li><li>s = “axyb” ，删除下标从 1 开始的 “xy” ，得到 s = “ab” 。<br>此时 s 中不再含有子字符串 “xy” 。</li></ul><p><strong>提示：</strong></p><ul><li>$1 &lt;= s.length &lt;= 1000$</li><li>$1 &lt;= part.length &lt;= 1000$</li><li>$s$​​​​​​ 和 $part$ 只包小写英文字母。</li></ul><hr><h3 id="字符串查找替换"><a href="#字符串查找替换" class="headerlink" title="字符串查找替换"></a>字符串查找替换</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOccurrences</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.<span class="built_in">size</span>(), len2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, idx), s2 = s.substr(idx + len2);</span><br><span class="line">            s = s1 + s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/" target="_blank" rel="noopener">LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单字符串替换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】A LeetCode 1909. 删除一个元素使数组严格递增</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</id>
    <published>2021-06-30T14:43:09.000Z</published>
    <updated>2021-06-30T15:26:59.772Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>签到题，但是又不那么水，题目质量挺好。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 $0$ 开始的整数数组 $nums$ ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 $true$ ，否则返回 $false$ 。如果数组本身已经是严格递增的，请你也返回 $true$ 。</p><p>数组 $nums$ 是 <strong>严格递增</strong> 的定义为：对于任意下标的 $1 &lt;= i &lt; nums.length$ 都满足 $nums[i - 1] &lt; nums[i]$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,2,10,5,7]<br>输出：true<br>解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。<br>[1,2,5,7] 是严格递增的，所以返回 true 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [2,3,1,2]<br>输出：false<br>解释：<br>[3,1,2] 是删除下标 0 处元素后得到的结果。<br>[2,1,2] 是删除下标 1 处元素后得到的结果。<br>[2,3,2] 是删除下标 2 处元素后得到的结果。<br>[2,3,1] 是删除下标 3 处元素后得到的结果。<br>没有任何结果数组是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1,1,1]<br>输出：false<br>解释：删除任意元素后的结果都是 [1,1] 。<br>[1,1] 不是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 4：</strong></p><p>输入：nums = [1,2,3]<br>输出：true<br>解释：[1,2,3] 已经是严格递增的，所以返回 true 。</p><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 1000$</li><li>$1 &lt;= nums[i] &lt;= 1000$</li></ul><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举每一位数，剔除后判断剩余数组是否严格单调递增。复杂度 $O(N^2)$, 数组长度最高 $1000$，复杂度是$1000000$ ，可以过掉。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= last) &#123;</span><br><span class="line">                    isgood = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isgood) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>从 <code>-1</code> 开始枚举需要删除的数，<code>-1</code> 表示不删除任何数，判断原数组是否为严格单调递增，太妙了。<br>注意 <code>nums.size()</code> 返回的是一个 <code>unsigned int</code> 类型，需要强转成 <code>int</code> 类型，配合 <code>-1</code>，不然有bug。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/" target="_blank" rel="noopener">LeetCode 1909. 删除一个元素使数组严格递增</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;签到题，但是又不那么水，题目质量挺好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 297. 二叉树的序列化与反序列化</title>
    <link href="https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-30T03:18:11.000Z</published>
    <updated>2021-06-30T03:32:40.375Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>根据遍历来序列化和反序列化二叉树。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例1：</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：root = []<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：root = [1]<br>输出：[1]</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：root = [1,2]<br>输出：[1,2]</p></blockquote><p><strong>提示：</strong></p><ul><li>树中结点数在范围 $[0, 104]$ 内</li><li>$-1000 &lt;= Node.val &lt;= 1000$</li></ul><p><strong>树的定义和方法的调用：</strong></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div></div></div><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在看这道题前，请回顾一下 <a href="https://eetoa.github.io/2021/02/23/剑指Offer-07-重建二叉树/" target="_blank" rel="noopener">剑指Offer 07. 重建二叉树</a>.<br>在上面这道题中，为了反序列化一颗二叉树，我们需要前序遍历序列和中序遍历序列，当这两个序列不包含原树的空节点。<br>如果给定一个包含原树空节点的前序遍历序列，我们就可以直接反序列化这颗二叉树。</p><p>另外这道题注意节点值的负数情况。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs_s(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) path += <span class="string">"#,"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path += to_string(root-&gt;val) + <span class="string">','</span>;</span><br><span class="line">            dfs_s(root-&gt;left);</span><br><span class="line">            dfs_s(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span>&amp; data, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = u;</span><br><span class="line">            <span class="keyword">while</span> (data[u] != <span class="string">','</span>) u ++ ;</span><br><span class="line">            <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(stoi(data.substr(k, u - k)));</span><br><span class="line">            u ++ ;</span><br><span class="line">            root-&gt;left = dfs_d(data, u);</span><br><span class="line">            root-&gt;right = dfs_d(data, u);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/" target="_blank" rel="noopener">LeetCode 297. 二叉树的序列化与反序列化</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;根据遍历来序列化和反序列化二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="树" scheme="https://accepted.org.cn/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://accepted.org.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第一讲-基础算法-归并排序 AcWing 787. 归并排序</title>
    <link href="https://accepted.org.cn/2021/06/29/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-AcWing-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://accepted.org.cn/2021/06/29/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-AcWing-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-29T03:52:06.000Z</published>
    <updated>2021-06-29T13:34:12.370Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典归并排序模板。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定你一个长度为 $n$ 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 $n$。</p><p>第二行包含 $n$ 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出共一行，包含 $n$ 个整数，表示排好序的数列。</p><p><strong>数据范围</strong></p><ul><li>$1≤n≤100000$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5<br>3 1 2 4 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3 4 5</p></blockquote><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的核心思想是递归地将原数组划分成两段，在不可再分的时候（一对数或一个数）进行第一次双指针排序。<br>然后在「归」的过程利用上一层已经排序好的两段，将它们使用双指针合并排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ms</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ms(lo, mid), ms(mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi;) &#123;              <span class="comment">// 对于两段升序子数组，用双指针进行合并排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) tmp[idx++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果某一段较另一段提前完成，需要将另一段加入到已排序临时数组后面。注意另一段数组元素一定大于等于已排序的临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = a[i++];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= hi; ) tmp[idx++] = a[j++];</span><br><span class="line">    <span class="comment">// 将已排序的临时数组覆盖原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> re = lo, t = <span class="number">0</span>; re &lt;= hi;) a[re++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ms(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/789/" target="_blank" rel="noopener">AcWing 787. 归并排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典归并排序模板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第一讲基础算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://accepted.org.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 168. Excel表列名称</title>
    <link href="https://accepted.org.cn/2021/06/29/LeetCode-168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
    <id>https://accepted.org.cn/2021/06/29/LeetCode-168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</id>
    <published>2021-06-29T02:10:42.000Z</published>
    <updated>2021-06-29T03:15:45.556Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>稍微复杂点的26进制问题。本题来自第八届蓝桥杯省赛C++C组。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><p>输入: 1<br>输出: “A”</p><p><strong>示例 2:</strong></p><p>输入: 28<br>输出: “AB”</p><p><strong>示例 3:</strong></p><p>输入: 701<br>输出: “ZY”</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>因为对于给定的 $10$ 进制，在直接换算成 $16$ 进制的时候，会遇到余数为 $0$ 的问题。而 $0$ 无法对应 $26$ 进制中的某一个数。</p><p>通过观察规律，不难发现，一个十进制数 $n$ 可以拆分成 $x \times 26 + y$ 的形式，其中 $x &gt;= 0, 0 &lt;= y &lt;= 26$.</p><ul><li>当 $x = 0$ 时，不予考虑；</li><li>当 $x &lt;= 26$ 时，它对应 $[A,Z]$ 的一个字母；</li><li>当 $x &gt; 26$ 时，递归地将 $x$ 拆成 $xx \times 26 + yy$ 的形式；</li><li>当 $y = 0$ 时，对应 $26$，需要从 $x$ 借 $1$ 位；</li><li>当 $0 &lt; y &lt; 26$ 时，对应 $[A,Z]$ 的一个字母。</li></ul><p>举例：</p><blockquote><p>根据如上规律，对 $703$ 进行拆分：</p><p>$703 = (1 \times 26 + 1) \times 26 + 1$</p><p>即 $AAA$.</p></blockquote><blockquote><p>对 $702$ 进行拆分：</p><p>$702 = 26 \times 26 + 26$</p><p>即 $ZZ$</p></blockquote><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">        helper(n, t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res += t[i] - <span class="number">1</span> + <span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x * 26 + y</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            t.push_back(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = n / <span class="number">26</span>, y = n % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span> (!y) x--, y = <span class="number">26</span>;</span><br><span class="line">        t.push_back(y);</span><br><span class="line">        helper(x, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">LeetCode 168. Excel表列名称</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;稍微复杂点的26进制问题。本题来自第八届蓝桥杯省赛C++C组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="蓝桥杯" scheme="https://accepted.org.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="进制" scheme="https://accepted.org.cn/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 815. 公交路线</title>
    <link href="https://accepted.org.cn/2021/06/28/LeetCode-815-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/"/>
    <id>https://accepted.org.cn/2021/06/28/LeetCode-815-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/</id>
    <published>2021-06-28T15:16:17.000Z</published>
    <updated>2021-06-28T15:31:20.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道较为抽象的BFS最短路问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 $routes$ ，表示一系列公交线路，其中每个 $routes[i]$ 表示一条公交线路，第 $i$ 辆公交车将会在上面循环行驶。</p><p>例如，路线 $routes[0] = [1, 5, 7]$ 表示第 $0$ 辆公交车会一直按序列 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … 这样的车站路线行驶。<br>现在从 $source$ 车站出发（初始时不在公交车上），要前往 $target$ 车站。 期间仅可乘坐公交车。</p><p>求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 $-1$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>routes = [[1,2,7],[3,6,7]], source = 1, target = 6</code><br>输出：<code>2</code><br>解释：最优策略是先乘坐第一辆公交车到达车站 <code>7</code> , 然后换乘第二辆公交车到车站 <code>6</code> 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12</code><br>输出：<code>-1</code></p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= routes.length &lt;= 500$</li><li>$1 &lt;= routes[i].length &lt;= 10^5$</li><li>$routes[i]$ 中的所有值 <strong>互不相同</strong></li><li>$sum(routes[i].length) &lt;= 10^5$</li><li>$0 &lt;= routes[i][j] &lt; 10^6$</li><li>$0 &lt;= source, target &lt; 10^6$</li></ul><hr><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><img src="0.png" alt="0x0"></p><center><font size=1>图片作者：div@acwing</font></center><p>可以将每个路线抽象成一个点，题目即求出从某个路线到目标路线的最短距离。</p><p>建图（以路线抽象成的点构成的图）：将每个点对应的路线存到哈希表中，如果遍历到的某个点存在着除自己所在路线外的其他路线，那么就可以从当前路线BFS到另外这条路线上。</p><p>我们维护一个距离数组记录距离，亦可作为标记数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-28 23:21:19</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line">    <span class="keyword">int</span> q[N];                                       <span class="comment">// 路线队列</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hash;           <span class="comment">// 点对应相关的所有路线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dist[N];                                    <span class="comment">// 路线对应已走过的距离，同时具备标记已走过的路线的功能（初始化成无穷大，如果值不是无穷大说明已经走过）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; routes, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = routes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;             <span class="comment">// 遍历所有路线找到起点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : routes[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == source) &#123;                  <span class="comment">// 找到起始点</span></span><br><span class="line">                    q[++tt] = i;                    <span class="comment">// 将对应路线入队</span></span><br><span class="line">                    dist[i] = <span class="number">1</span>;                    <span class="comment">// 至少需要一站路，距离从1开始，将来BFS到其他路线，距离增加1</span></span><br><span class="line">                &#125;</span><br><span class="line">                hash[x].push_back(i);               <span class="comment">//将所有点和其所在的路线对应起来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh;) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q[hh++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : routes[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == target) <span class="keyword">return</span> dist[cur];  <span class="comment">// 找到目标点，返回距离</span></span><br><span class="line">                                                    <span class="comment">// 否则将点对应的所有路线入队，注意跳过已走过的路线，因为已走过的路线及上面所有点必然已经被遍历过一次，点对应的所有路线必然已被入队，避免重复</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : hash[x]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i] == <span class="number">0x3f3f3f3f</span>) &#123;    <span class="comment">// 新的路线</span></span><br><span class="line">                        q[++tt] = i;                <span class="comment">// 路线入队</span></span><br><span class="line">                        dist[i] = dist[cur] + <span class="number">1</span>;    <span class="comment">// 将下一个路线距离在本路线基础上+1，顺便标记为已访问</span></span><br><span class="line">                    &#125;</span><br><span class="line">                                                    <span class="comment">// 否则是已访问过的路线（已入队或已遍历），直接跳过</span></span><br><span class="line">                &#125;</span><br><span class="line">                                                    <span class="comment">// 将已遍历过的点擦除，道理和标记已访问过的路线一样，只要点被遍历过，那么它对应的所有路线必然已入队。</span></span><br><span class="line">                hash.erase(x);                      <span class="comment">// 将已遍历的点从hashmap中删除，为什么不从别的地方删除？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/bus-routes/comments/" target="_blank" rel="noopener">LeetCode 815. 公交路线</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道较为抽象的BFS最短路问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
      <category term="最短路" scheme="https://accepted.org.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 909. 蛇梯棋</title>
    <link href="https://accepted.org.cn/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/"/>
    <id>https://accepted.org.cn/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/</id>
    <published>2021-06-27T09:48:05.000Z</published>
    <updated>2021-06-27T10:32:47.063Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS魔改题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$N \times N$ 的棋盘 $board$ 上，按从 $1$ 到 $N \times N$ 的数字给方格编号，编号 <strong>从左下角开始</strong>，每一行交替方向。</p><p>例如，一块 $6 \times 6$ 大小的棋盘，编号如下：</p><p><img src="0.png" alt="0x0"></p><p>$r$ 行 $c$ 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 $board[r][c] != -1$，那个蛇或梯子的目的地将会是 $board[r][c]$。</p><p>玩家从棋盘上的方格 $1$ （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 $x$ 开始出发，按下述要求前进：</p><ul><li><p>选定目标方格：选择从编号 $x+1$，$x+2$，$x+3$，$x+4$，$x+5$，或者 $x+6$ 的方格中选出一个目标方格 $s$ ，目标方格的编号 $&lt;= N \times N$。</p><ul><li>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 $[x+1, x+6]$ 之间。</li></ul></li><li><p>传送玩家：如果目标方格 $S$ 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 $S$。<br>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p></li></ul><p>返回达到方格 $N \times N$ 所需的最少移动次数，如果不可能，则返回 $-1$。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong><br>[[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,35,-1,-1,13,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,15,-1,-1,-1,-1]]<br><strong>输出：</strong> 4<br><strong>解释：</strong><br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</p></blockquote><p><strong>提示：</strong></p><ul><li>$2 &lt;= board.length = board[0].length &lt;= 20$</li><li>$board[i][j]$ 介于 $1$ 和 $N \times N$ 之间或者等于 $-1$。</li><li>编号为 $1$ 的方格上没有蛇或梯子。</li><li>编号为 $N \times N$ 的方格上没有蛇或梯子。</li></ul><hr><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>这道题很容易看出来是一道利用BFS找到最短路径步数的题目。和一般的BFS题不同之处在于引入了「传送门」的概念，以及搜索方向是蛇形的。<br>引入「传送门」的概念并不妨碍最先BFS到终点的路径一定最短这一BFS特性。<br>重要的是，我们还是要标记出已经到达的位置，以避免重复入队。<br>把棋盘上非 $-1$ 的数字看成一个位置指针，也不必考虑到循环指针的问题。因为只要做好重复标记，可以避免所有循环指针入队。</p><p>我和yxc解法的区别主要在于路径长度记录和重复标记方法。<br>对于路径长度记录，我是将路径长度和路径点坐标放在一起入队，每次搜索下一个点，将路径 $+1$；而yxc是维护一个和原棋盘大小相同的每个值初始化为无穷大的 <code>dist</code> 二维数组，将起点设为 $0$，每搜索到一个点，如果是新的点，就在当前点的距离上 $+1$。</p><p>对于重复标记，我是将已入队的位置在原棋盘上更改为一个特定值 <code>0x3f3f3f3f</code>；而yxc的解法利用记录路径长度的二维数组，如果搜索到的新点对应值是无穷大，说明确实是一个新的点，如果不是，则之前已被搜过。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-27 18:12:16</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">404</span>;</span><br><span class="line">    pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = board.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = R - <span class="number">1</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ((-r + R) &amp; <span class="number">1</span>) ? <span class="number">0</span> : C - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; C; last++) &#123;</span><br><span class="line">                grid[r][c] = last + <span class="number">1</span>;</span><br><span class="line">                heap[last + <span class="number">1</span>] = &#123;r, c&#125;;</span><br><span class="line">                <span class="keyword">if</span> ((-r + R) &amp; <span class="number">1</span>) c++;</span><br><span class="line">                <span class="keyword">else</span> c--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = R * C;</span><br><span class="line">        q[++tt] = &#123;&#123;R - <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">        board[R - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; hh++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first.first, c = q[hh].first.second;</span><br><span class="line">            <span class="keyword">int</span> x = grid[r][c];</span><br><span class="line">            <span class="keyword">int</span> cnt = q[hh].second;</span><br><span class="line">            </span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = x + i;</span><br><span class="line">                <span class="keyword">int</span> ner = heap[nex].first, nec = heap[nex].second;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "ner: " &lt;&lt; ner &lt;&lt; " nec: " &lt;&lt; nec &lt;&lt; " nex: " &lt;&lt; nex &lt;&lt; " cnt: " &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (nex == target || board[ner][nec] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nex &gt; target || board[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// determine teleport beacon</span></span><br><span class="line">                <span class="keyword">if</span> (board[ner][nec] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q[++tt] = &#123;heap[board[ner][nec]], cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                board[ner][nec] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; cor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        id = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        cor = <span class="built_in">vector</span>&lt;PII&gt;(n * m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, k = <span class="number">1</span>, s = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --, s ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">1e9</span>))</span></span>;</span><br><span class="line">        q.push(&#123;n - <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        dist[n - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> k = id[t.x][t.y];</span><br><span class="line">            <span class="keyword">if</span> (k == n * m) <span class="keyword">return</span> dist[t.x][t.y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= k + <span class="number">6</span> &amp;&amp; i &lt;= n * m; i ++ ) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = cor[i].x, y = cor[i].y;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = board[x][y];</span><br><span class="line">                    x = cor[r].x, y = cor[r].y;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode 909. 蛇梯棋</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS魔改题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊递归</title>
    <link href="https://accepted.org.cn/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/"/>
    <id>https://accepted.org.cn/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/</id>
    <published>2021-06-25T10:10:29.000Z</published>
    <updated>2021-06-25T13:58:17.079Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>递归、回溯、DFS，都聊一聊。</p><a id="more"></a><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>很简单，就是指一段函数内部调用自己。细一点，它分为「递」和「归」两个过程。<br>这些都是大家都知道的东西，今天我想聊一聊如何构建一段标准的递归代码。</p><p>首先是递归进入条件。<br>首次在递归函数外部调用递归函数的条件，需要和递归函数内部调用自身的条件一致。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;递归、回溯、DFS，都聊一聊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://accepted.org.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 149. 直线上最多的点数</title>
    <link href="https://accepted.org.cn/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</id>
    <published>2021-06-24T09:45:27.000Z</published>
    <updated>2021-06-24T10:16:13.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>主要是考虑从哪个角度入手暴搜。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</p><p><strong>示例1:</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：points = [[1,1],[2,2],[3,3]]<br>输出：3</p></blockquote><p><strong>示例2:</strong></p><p><img src="1.jpg" alt="0x1"></p><blockquote><p>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>输出：4</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= points.length &lt;= 300$</li><li>$points[i].length == 2$</li><li>$-10^4 &lt;= xi, yi &lt;= 10^4$</li><li>$points$ 中的所有点 <strong>互不相同</strong></li></ul><hr><h3 id="暴搜"><a href="#暴搜" class="headerlink" title="暴搜"></a>暴搜</h3><p>对于某一个点，把它看成中心点，平面上会有无穷多条直线经过它。对于一个中心点，剩余点的每个点都和它构成一条直线。我们统计剩余点和中心点构成直线的数量。</p><p>注意剩余点和中心点垂直的情况，此时可以用一个额外的变量来统计和中心点垂直的点的数量。<br>注意相同点的情况，即剩余点和中心点重合，虽然题目条件说明所有点互不相同，但是这里依旧考虑这一情况。<br>注意本题精度要求较高，计算斜率使用 long double 变量。<br>如果精度要求更高，可以考虑用分数来存放斜率，这时候需要求分子分母最大公约数。</p><div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-24 17:54:50</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> center = <span class="number">0</span>, vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">double</span> ratio = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[j] == points[i]) center++;   <span class="comment">// 至少包含一个中心点 points[i]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (points[j][<span class="number">0</span>] == points[i][<span class="number">0</span>]) vertical++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ratio = (<span class="keyword">long</span> <span class="keyword">double</span>)(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]) / (points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    cnt[ratio]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 垂线和斜线数量取较大者</span></span><br><span class="line">            <span class="keyword">int</span> mxratio = vertical;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : cnt) &#123;</span><br><span class="line">                mxratio = <span class="built_in">max</span>(mxratio, value);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mxratio + center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">LeetCode 149. 直线上最多的点数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;主要是考虑从哪个角度入手暴搜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1162. 地图分析</title>
    <link href="https://accepted.org.cn/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <id>https://accepted.org.cn/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</id>
    <published>2021-06-23T10:38:43.000Z</published>
    <updated>2021-06-26T03:28:20.766Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道经典的多源BFS题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你现在手里有一份大小为 $N*N$ 的 网格 $grid$，上面的每个 单元格 都用 $0$ 和 $1$ 标记好了。其中 $0$ 代表海洋，$1$ 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：$(x0, y0)$ 和 $(x1, y1)$ 这两个单元格之间的距离是 $|x0 - x1| + |y0 - y1|$ 。</p><p>如果网格上只有陆地或者海洋，请返回 $-1$。</p><p><strong>示例 1：</strong></p><p><img src="1.jpeg" alt="0x0"></p><blockquote><p>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="2.jpeg" alt="0x1"></p><blockquote><p>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</p></blockquote><p><strong>提示：</strong></p><ol><li>$1 &lt;= grid.length == grid[0].length &lt;= 100$</li><li>$grid[i][j]$ 不是 $0$ 就是 $1$</li></ol><hr><h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p>遍历数组，将所有岛屿入队，每次根据当前结点计算出下一个海洋结点，就将海洋结点值设为父结点的值加一。<br>于是，就像水中的多点扰动水面一样，最终涟漪交汇的地方就是最远海洋结点。</p><div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-23 18:47:28</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) q[++tt] = &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// determine special situation</span></span><br><span class="line">        <span class="keyword">int</span> qsize = tt - hh + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qsize == R * C || !qsize) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; ++hh) &#123;                         <span class="comment">// pop head</span></span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first, c = q[hh].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || grid[ner][nec]) <span class="keyword">continue</span>;</span><br><span class="line">                grid[ner][nec] = grid[r][c] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;ner, nec&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, grid[i][j]);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; grid[i][j] &lt;&lt; ' ';</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">LeetCode 1162. 地图分析</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道经典的多源BFS题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】D LeetCode 1906. 查询差绝对值的最小值</title>
    <link href="https://accepted.org.cn/2021/06/23/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91D-LeetCode-1906-%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://accepted.org.cn/2021/06/23/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91D-LeetCode-1906-%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2021-06-23T03:09:06.000Z</published>
    <updated>2021-06-26T09:05:27.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>前缀和配合计数排序，妙哉~！</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 相同 ，那么差绝对值的最小值为 <code>-1</code> 。</p><ul><li>比方说，数组 <code>[5,2,3,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li></ul><p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[li...ri]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[li...ri]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>li</code> 和 <code>ri</code> 之间的所有元素（包含 <code>li</code> 和 <code>ri</code> 在内）。</p><p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p><strong>子数组</strong> 是一个数组中连续的一段元素。</p><p><code>|x|</code> 的值定义为：</p><p>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。<br>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]<br>输出：[2,1,4,1]<br>解释：查询结果如下：<br>– queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。<br>– queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。<br>– queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。<br>– queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]<br>输出：[-1,1,1,3]<br>解释：查询结果如下：<br>– queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。<br>– queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。<br>– queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。<br>– queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 10^5$</li><li>$1 &lt;= nums[i] &lt;= 100$</li><li>$1 &lt;= queries.length &lt;= 2 * 10^4$</li><li>$0 &lt;= li &lt; ri &lt; nums.length$</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>先想想朴素做法，我们可以对于每一段查询获取一个子数组，对子数组排序，找到相邻数字差绝对值最小的数。</p><p>注意到数组元素的取值范围是 $1 &lt;= nums[i] &lt;= 100$, 因为范围很小所以很容易联想到计数排序。既然需要对子数组元素计数，自然联想到前缀和。</p><p>可以开一个二维数组，行表示为数组下标$+1$(因为前缀和需要考虑0的情况，避免出现值-1的下标)；列表示数组元素值在 $[1,100]$ 中的某个数。</p><p>遍历数组中的每个元素，再以当前元素为结束的前缀数组中，遍历 $[1,100]$ 中的每个数，对前缀数组进行计数。<br>注意当前行需要继承前一行的非零值。</p><p>举例：<br>对于数组 <code>nums = [1,3,4,8]</code> ,预处理出的前缀和数组为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>那么可以在 $O(1)$ 的时间复杂度下得到某一段子数组如第2到3的所有元素计数情况。接着，可以在 $O(N)$ 的复杂度下得到这段子数组的 最小差绝对值。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(len + <span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">110</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// presum </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;                    <span class="comment">// 第i行放入数组前0 ~ i - 1项的和，即从1开始数组第某项放在第某行中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (presum[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    presum[i][j] = presum[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            presum[i][nums[i - <span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt;= len; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt;= 100; j++) &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; presum[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++) &#123;          <span class="comment">// 对于每组查询，依次找到子数组中的数，找到最小差绝对值</span></span><br><span class="line">            <span class="keyword">int</span> l = queries[i][<span class="number">0</span>] + <span class="number">1</span>, r = queries[i][<span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 加1是因为l r是数组下标从0记起，而我们的前缀和是从1记起</span></span><br><span class="line">            <span class="keyword">int</span> tres = <span class="number">110</span>, last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;                <span class="comment">// 从小到大遍历子数组中的数</span></span><br><span class="line">                <span class="keyword">if</span> (presum[r][j] - presum[l - <span class="number">1</span>][j] &gt; <span class="number">0</span>) &#123;  <span class="comment">// 找到一个子数组中的数</span></span><br><span class="line">                    <span class="keyword">if</span> (last) &#123;                             <span class="comment">// 如果当前子数组的数不是第一个（可以产生一个差绝对值）</span></span><br><span class="line">                        tres = <span class="built_in">min</span>(tres, j - last);         <span class="comment">// 当前子数组的数和上一个子数组的数绝对值差为 j - last</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    last = j;                               <span class="comment">// 不管当前数字是不是第一个子数组的数，last 都要更新为当前子数组的数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果某段子数组中只包含一种元素，那么31行只会进入一次，且因为是第一个元素第一次进入，那么32行不会进入，那么tres不会得到更新</span></span><br><span class="line">            <span class="keyword">if</span> (tres != <span class="number">110</span>)</span><br><span class="line">                res.push_back(tres);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>下面来思考一下预处理前缀和数组的时候，为什么 <code>i</code> 从 <code>1</code> 开始，前缀和数组第 <code>0</code> 位留空。</p><p>首先我们假设前缀和数组就是从第 <code>0</code> 位开始，即 <code>presum[i]</code> 对应原数组 $[0,i]$ 位元素的和。会发生什么呢？<br>假设求从 <code>0</code> 开始计算的第 <code>4</code> 位到第 <code>5</code> 位子数组和，那么使用这样一个前缀和数组可得：<br><code>int res = presum[5] - presum[4 - 1];</code><br>似乎没有问题，好，那我现在求第 <code>0</code> 位到第 <code>3</code> 位子数组的和：<br><code>int res = presum[3] - presum[0 - 1];</code><br>数组下标出现负数，为了避免这种情况，只能多一次判断，不方便。</p><p>另外，在生成前缀和数组时，递推公式为：<code>presum[i] = presum[i - 1] + nums[i]</code>.<br>问题是，这个递推公式无法适配所有情况。即，当 <code>i</code> 取 <code>0</code> 时，出现异常。<br>为了避免这个情况，只能把 <code>presum[0]</code> 拿出来预设为 <code>nums[0]</code> ，从数组第 <code>1</code> 项接着按照递推公式计算。不方便。</p><p>那么，为了方便地避免以上情况，我们决定将前缀和数组相对原数组向右偏移一位，用 <code>presum[1]</code> 表示原数组第 <code>0</code> 项， <code>presum[2]</code> 表示原数组第 <code>[0,1]</code> 项之和，将 <code>presum[i]</code> 表示为数组中 $[0,i-1]$ 所有数之和。</p><p>那么，如果求原数组从零计第 <code>l</code> 项到 <code>r</code> 项子数组之和，那么<br><code>int res = presum[r + 1] - presum[l + 1 - 1];</code><br>因为 <code>presum[r]</code> 表示的是 $[0, r-1]$ 项之和， <code>presum[l]</code> 表示 $[0,l-1]$ 项之和。<br>另外，如果求原数组从1计算第 <code>l</code> 项到 <code>r</code> 项子数组之和，可以直接：<br><code>int res = presum[r] - presum[l - 1];</code></p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/" target="_blank" rel="noopener">LeetCode 1906. 查询差绝对值的最小值</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;前缀和配合计数排序，妙哉~！&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1249. 移除无效的括号</title>
    <link href="https://accepted.org.cn/2021/06/22/LeetCode-1249-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://accepted.org.cn/2021/06/22/LeetCode-1249-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2021-06-22T14:47:56.000Z</published>
    <updated>2021-06-26T09:16:50.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>华为面试题，时间不够没写出来，面试结束补上了，还是我太菜了。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code> 和小写字母组成的字符串 s。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 任意一条 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li><li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “lee(t(c)o)de)”<br>输出：”lee(t(c)o)de”<br>解释：”lee(t(co)de)” , “lee(t(c)ode)” 也是一个可行答案。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：s = “a)b(c)d”<br>输出：”ab(c)d”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：s = “))((“<br>输出：””<br>解释：空字符串也是有效的</p></blockquote><p><strong>示例 4：</strong></p><p>输入：s = “(a(b(c)d)”<br>输出：”a(b(c)d)”</p><p><strong>提示：</strong></p><ul><li>$ 1 &lt;= s.length &lt;= 10^5$</li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>维护一个栈，将所有有效括号对去除，剩下的就是字符串中多余的目标括号。为了将字符串中多余的括号去除，需要在栈中记录括号对应原字符串下标。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; stk[N];</span><br><span class="line">    <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'('</span>) stk[++tt] = &#123;c, i&#125;;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!tt || stk[tt].first != <span class="string">'('</span>) stk[++tt] = &#123;c, i&#125;;</span><br><span class="line">                    <span class="keyword">else</span> --tt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> (tt) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tt &amp;&amp; i == stk[tt].second) &#123;</span><br><span class="line">                    --tt;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener">LeetCode 1249. 移除无效的括号</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;华为面试题，时间不够没写出来，面试结束补上了，还是我太菜了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="栈" scheme="https://accepted.org.cn/tags/%E6%A0%88/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>HeXo文章分类管理</title>
    <link href="https://accepted.org.cn/2021/06/21/HeXo%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/"/>
    <id>https://accepted.org.cn/2021/06/21/HeXo%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-21T01:47:26.000Z</published>
    <updated>2021-06-21T02:04:08.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单记录下HeXo博客的文章分类管理。</p><a id="more"></a><h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><h4 id="单级分类"><a href="#单级分类" class="headerlink" title="单级分类"></a>单级分类</h4><p>对于一篇文章，在顶部的位置加上：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>A</span><br></pre></td></tr></table></figure><p>那么这篇文章就属于分类 <code>A</code>.</p><h4 id="多级分类"><a href="#多级分类" class="headerlink" title="多级分类"></a>多级分类</h4><p>如果再加上 <code>- B</code></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>A</span><br><span class="line"><span class="bullet">    - </span>B</span><br></pre></td></tr></table></figure><p>那么 <code>B</code> 是 <code>A</code> 的子类，文章属于 <code>A</code> 分类下的 <code>B</code> 分类。以此类推。</p><p>同样的，我们可以以一个列表形式展现文章的多级分类：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>[A, B]</span><br></pre></td></tr></table></figure><h4 id="共存的多级分类"><a href="#共存的多级分类" class="headerlink" title="共存的多级分类"></a>共存的多级分类</h4><p>那么，如果一篇文章既属于A又属于D，我们可以以多个列表同时分类：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>[A, B, C]</span><br><span class="line"><span class="bullet">    - </span>[D, E, F]</span><br></pre></td></tr></table></figure><p>文章既属于A类下的B类下的C类，又属于D分类下的E分类下的F分类。</p><div class="note primary">            <p><strong>相关链接：</strong> <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">HeXo Doc</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单记录下HeXo博客的文章分类管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
      <category term="博客" scheme="https://accepted.org.cn/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://accepted.org.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="HeXo" scheme="https://accepted.org.cn/tags/HeXo/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】C LeetCode 5791. 统计子岛屿</title>
    <link href="https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91C-LeetCode-5791-%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/"/>
    <id>https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91C-LeetCode-5791-%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/</id>
    <published>2021-06-20T08:11:33.000Z</published>
    <updated>2021-06-30T09:25:04.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>洪水灌溉算法经典题型。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p><p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p><p><strong>示例 1：</strong><br><img src="test1.png" alt="0x0"></p><blockquote><p>输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]<br>输出：3<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。</p></blockquote><p><strong>示例 2：</strong><br><img src="testcasex2.png" alt="0x1"></p><blockquote><p>输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]<br>输出：2<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>m == grid1.length == grid2.length</code></li><li><code>n == grid1[i].length == grid2[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在 <code>grid2</code> 中找到所有岛屿，并且在寻找的过程中判断每一个块是否和 <code>grid1</code> 中对应块相等，不等必然不是子岛屿。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid2, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">bool</span> &amp;issub)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid2[r][c] != grid1[r][c]) issub = <span class="literal">false</span>;</span><br><span class="line">        grid2[r][c] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">            <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || !grid2[ner][nec] || grid2[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(grid1, grid2, ner, nec, issub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid2.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid2[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid2[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> issub = <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid1, grid2, i, j, issub);</span><br><span class="line">                    <span class="keyword">if</span> (issub) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>本题是 <a href="https://eetoa.github.io/2020/04/21/LeetCode-200-岛屿数量" target="_blank" rel="noopener">岛屿数量</a> 的升级版。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-sub-islands/" target="_blank" rel="noopener">LeetCode 5791. 统计子岛屿</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;洪水灌溉算法经典题型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
      <category term="Flood Fill" scheme="https://accepted.org.cn/tags/Flood-Fill/"/>
    
      <category term="洪水灌溉算法" scheme="https://accepted.org.cn/tags/%E6%B4%AA%E6%B0%B4%E7%81%8C%E6%BA%89%E7%AE%97%E6%B3%95/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】B LeetCode 5789. 你完成的完整对局数</title>
    <link href="https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91B-LeetCode-5789-%E4%BD%A0%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E5%B1%80%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91B-LeetCode-5789-%E4%BD%A0%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E5%B1%80%E6%95%B0/</id>
    <published>2021-06-20T06:26:47.000Z</published>
    <updated>2021-06-26T09:20:06.053Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道关于时间的题目。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <code>24</code> 小时制的时钟 ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p><p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>&quot;HH:MM&quot;</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p><ul><li>例如，如果 <code>startTime = &quot;05:20&quot;</code> 且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li></ul><p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code> ）。</p><p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：startTime = “12:01”, finishTime = “12:44”<br>输出：1<br>解释：你完成了从 12:15 到 12:30 的一个完整对局。<br>你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。<br>你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。</p></blockquote><p><strong>示例 2：</strong></p><p>输入：startTime = “20:00”, finishTime = “06:00”<br>输出：40<br>解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。<br>16 + 24 = 40</p><p><strong>示例 3：</strong></p><blockquote><p>输入：startTime = “00:00”, finishTime = “23:59”<br>输出：95<br>解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li><li>$00 &lt;= HH &lt;= 23$</li><li>$00 &lt;= MM &lt;= 59$</li><li><code>startTime</code> 和 <code>finishTime</code> 不相等</li></ul><hr><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>将时间转换为分钟数表示，如果结束时间小于开始时间，则将结束时间加上24小时。<br>问题就变成了求开始分钟数后的第一个15的倍数，以及结束时间分钟数前一个15的倍数。再求二者之间的长度共是15的倍数。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ctoi</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = (ctoi(s[<span class="number">0</span>]) * <span class="number">10</span> + ctoi(s[<span class="number">1</span>])) * <span class="number">60</span> + ctoi(s[<span class="number">3</span>]) * <span class="number">10</span> + ctoi(s[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">int</span> b = (ctoi(f[<span class="number">0</span>]) * <span class="number">10</span> + ctoi(f[<span class="number">1</span>])) * <span class="number">60</span> + ctoi(f[<span class="number">3</span>]) * <span class="number">10</span> + ctoi(f[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) b += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        <span class="comment">// 找到a右边第一个15的倍数和b左边第一个15的倍数</span></span><br><span class="line">        <span class="keyword">int</span> l = (<span class="keyword">int</span>)((a + <span class="number">14</span>) / <span class="number">15</span>) * <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (<span class="keyword">int</span>)(b / <span class="number">15</span>) * <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l)                  <span class="comment">// 当r 和 l之间至少有一个完整对局时或者二者不构成一个完整对局且分别某个对局时间点左右</span></span><br><span class="line">            <span class="keyword">return</span> (r - l) / <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">else</span>                       <span class="comment">// 当r和l同在一个完整对局区间内，会出现r &lt; l的情况</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>注意到c++是向零取整，<code>int c = b / a</code>;<br>如果想计算 <code>b / a</code> 向上取整，可以 <code>int c = (b + a - 1) / a</code>.<br>因为 <code>c = (b + a) / a</code> 刚好等于 <code>b / a向下取整 + 1</code>.</p><h3 id="优化：用sscanf将字符串分割为两个数字"><a href="#优化：用sscanf将字符串分割为两个数字" class="headerlink" title="优化：用sscanf将字符串分割为两个数字"></a>优化：用sscanf将字符串分割为两个数字</h3><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: yxc@acwing.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h, m;</span><br><span class="line">        <span class="built_in">sscanf</span>(s.c_str(), <span class="string">"%d:%d"</span>, &amp;h, &amp;m);</span><br><span class="line">        <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">get</span>(s), y = <span class="built_in">get</span>(f);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) y += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        x = (x + <span class="number">14</span>) / <span class="number">15</span>, y /= <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; x)</span><br><span class="line">            <span class="keyword">return</span> y - x;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/" target="_blank" rel="noopener">LeetCode 5789. 你完成的完整对局数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道关于时间的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛246】A LeetCode 5788. 字符串中的最大奇数</title>
    <link href="https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91A-LeetCode-5788-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%87%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91A-LeetCode-5788-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%87%E6%95%B0/</id>
    <published>2021-06-20T06:03:11.000Z</published>
    <updated>2021-06-26T09:05:54.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>寻找字符串中的最大奇数。</p><a id="more"></a><p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p><p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：num = “52”<br>输出：”5”<br>解释：非空子字符串仅有 “5”、”2” 和 “52” 。”5” 是其中唯一的奇数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：num = “4206”<br>输出：””<br>解释：在 “4206” 中不存在奇数。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：num = “35427”<br>输出：”35427”<br>解释：”35427” 本身就是一个奇数。</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= num.length &lt;= 10^5$</li><li>$num$ 仅由数字组成且不含前导零</li></ul><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>奇数最后一个数字一定是奇数，那么就从右向左找到第一个奇数数字，那么以该字符结尾的原字符串前缀就是最大奇数子串。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestOddNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((num.<span class="built_in">end</span>()[<span class="number">-1</span>]) &amp; <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> len = num.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num[i]) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num.substr(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>注意在判断数字字符的奇偶性时，可以直接判断。因为数字字符和对应的数字具有相同奇偶性。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/largest-odd-number-in-string/" target="_blank" rel="noopener">LeetCode 5788. 字符串中的最大奇数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;寻找字符串中的最大奇数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第五讲-动态规划-背包问题 AcWing 2. 01背包问题</title>
    <link href="https://accepted.org.cn/2021/06/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-AcWing-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://accepted.org.cn/2021/06/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-AcWing-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-18T08:59:36.000Z</published>
    <updated>2021-06-29T13:34:28.728Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>01背包模板题，非常纯粹。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong><br>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong><br>$0 &lt; N,V ≤ 1000$<br>$0 &lt; v_i,w_i ≤ 1000$</p><p><strong>输入样例</strong></p><blockquote><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>8</p></blockquote><hr><p>设 <code>i</code> 为前 <code>i</code> 件物品，<code>j</code> 为背包的最大容量。<br>设 <code>v[i]</code> 为第 <code>i</code> 件物品的体积，<code>w[i]</code> 为第 <code>i</code> 件物品的价值。</p><h3 id="二维dp数组"><a href="#二维dp数组" class="headerlink" title="二维dp数组"></a>二维dp数组</h3><p>题目要求前 $N$ 个物品，放入容量为 $V$ 的背包中，所得到的最大价值。<br>由此可以定义一个二维dp数组 <code>f[i][j]</code> 用以表示状态。</p><p><strong>状态集合：</strong> 前 <code>i</code> 个物品放入容量为 <code>j</code> 的背包中的所有情况所构成的集合。<br>其中 $1 &lt;= i &lt;= N, 1 &lt;= j &lt;= V$，即：<br>对于前 $1$ 件到前 $N$ 件中的每种情况，都分别对应背包容量从 $1$ 到 $V$ 的每种情况。所有情况构成了状态集合。</p><p><strong>状态集合元素属性：</strong> 对于集合中的每个元素，将产生的最大价值定义为它的属性放在二维dp数组中。即：<br><code>f[i][j]</code> 表示前 <code>i</code> 个物品放入容量为 <code>j</code> 的背包中，所对应的最大价值。</p><p><strong>状态计算：</strong> 现在思考如何计算 <code>f[i][j]</code> 的值。<br>对于前 <code>i</code> 件物品的第 <code>i</code> 件物品，只会有 「可放入」背包和「不可放入」背包两种情况。现在考虑哪些情况可放入哪些不可放入。</p><ul><li>不可放入第 <code>i</code> 件物品：很容易想到，当尝试放入第 <code>i</code> 件物品时，遇到背包容量限制的时候，必然不可放入。即：<br>当第 <code>i</code> 件的体积超出背包总体积时，必然不可放入（<code>j &lt; v[i]</code>）。<br>那么， <code>f[i][j]</code> 表示前 <code>i - 1</code> 件物品放入容量为 <code>j</code> 的背包中的最大价值。</li><li>可放入第 <code>i</code> 件物品：反之， <code>j &gt;= v[i]</code> ，即 <code>j - v[i] &gt;= 0</code> ，供前 <code>i - 1</code> 件物品放入的背包容量是大于零的。同时，注意，第 <code>i</code> 件可放可不放，没有条件限制。<br>那么， <code>f[i][j]</code> 表示前 <code>i - 1</code> 件物品放入容量为 <code>j - v[i]</code> 的背包中的最大价值和<br>第 <code>i</code> 件物品放入容量为 <code>j</code> 的背包中的最大价值，二者取较大者。</li></ul><p><strong>状态转移方程：</strong> 根据上述状态计算方式，可以得出状态转移方程分别为：</p><ul><li><code>f[i][j] = f[i - 1][j]</code></li><li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></li></ul><p>其中 <code>v[i]</code> 和 <code>w[i]</code> 分别为第 <code>i</code>件物品的体积和价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[i][j]: 前 i 件放在最大容量为j的包里，最大价值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(mxv + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造二维dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mxv; j++) &#123;    <span class="comment">// 从前 i 件放在最大容量为1的包里，到前 i 件放在最大容量为 mxv 的包里</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) &#123;   <span class="comment">// j - v[i] &gt;= 0，前 i - 1件物品放入容量为 j - v[i]的背包中，同时第i件可放可不放。</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// j &lt; v[i]背包全部容量都不够第i件物品的体积，必然不可放入</span></span><br><span class="line">                f[i][j] = f[i  - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维数组的构造过程也是逐步求解过程，数组最后一个值f[n][mxv]即为所求：对于前 n 件物品，放在容量为mxv的背包中的最大价值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维dp数组的空间优化"><a href="#一维dp数组的空间优化" class="headerlink" title="一维dp数组的空间优化"></a>一维dp数组的空间优化</h3><p>注意到二维dp的状态转移方程：</p><ul><li><code>f[i][j] = f[i - 1][j]</code></li><li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></li></ul><p>不难发现，前 <code>i</code> 件物品的最大价值只与前 <code>i - 1</code> 件物品有关。对应在二维数组中，第 <code>i</code> 行的计算只与第 <code>i - 1</code> 行有关。<br>不妨维护一个一维数组放入前 <code>i - 1</code> 件物品在不同容量背包下的最大价值。计算前 <code>i</code> 件物品的时候，可以直接使用，并完成更新为前 <code>i + 1</code> 件物品的计算做准备。</p><p>在一维dp中，考虑前 <code>i</code> 个物品在不同体积背包下的最大价值。<br>可定义一维数组：<code>f[j]</code> $(1 &lt;= j &lt;= V)$</p><p><strong>状态转移方程：</strong><br>下面我们尝试将二维状态转移方程压缩至一维：<br><code>f[i][j] = f[i - 1][j]</code> 可以直接等价于 <code>f[j] = f[j]</code><br><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code> 则可以等价于：<br><code>f[j] = max(f[j], f[j - v[i]] + w[i])</code></p><p>对于前 <code>i</code> 件物品，在计算 <code>f[j]</code> 的时候，注意 <code>f[j - v[i]]</code> 的来源：<br>首先应该明确 <code>f[j - v[i]]</code> 来自于前 <code>i - 1</code> 件物品的计算，即上一层循环得到的一位dp数组;<br>其次，<code>j</code> 大于 <code>j - v[i]</code> ，因为 <code>j - (j - v[i]) &gt; 0</code> ;<br>那么，为了计算前 <code>i</code> 件物品的最大价值，我们在更新当前的一维dp数组的时候需要使用到上一次计算前 <code>i - 1</code> 件物品的dp数组。<strong>其中，使用到的 <code>f[j - v[i]]</code> 在 <code>f[j]</code> 前面。</strong><br>那么，如果我们计算了 <code>f[j]</code> 的值，并且更新了 <code>f[j]</code> ，那么 <strong>随着 <code>j</code> 的增大，需要使用到 <code>f[j]</code> 的时候，上一层的信息已经被本层之前的计算覆盖了。</strong><br>为了解决更新第 <code>i</code> 次dp数组而不影响使用第 <code>i - 1</code> 次数组信息的问题，我们可以从大到小遍历体积：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(mxv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mxv; j &gt;= <span class="number">1</span>; j--) &#123;    <span class="comment">// 从前 i 件放在最大容量为mxv的包里，到前 i 件放在最大容量为 1 的包里</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i])</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                f[j] = f[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，不难看出只有当 <code>j &gt;= v[i]</code> 时dp数组会更新，所以：<br><code>for (int j = mxv; j &gt;= 1; j--)</code> 可以进一步优化成<br><code>for (int j = mxv; j &gt;= v[i]; j--)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(mxv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mxv; j &gt;= v[i]; j--) &#123;     <span class="comment">// 从前 i 件放在最大容量为mxv的包里，到前 i 件放在最大容量为 1 的包里</span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/activity/content/problem/content/997/1/" target="_blank" rel="noopener">AcWing 2. 01背包问题</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;01背包模板题，非常纯粹。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第五讲动态规划" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%BA%94%E8%AE%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://accepted.org.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
      <category term="背包" scheme="https://accepted.org.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="01背包" scheme="https://accepted.org.cn/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>算法题由给定数据范围反推算法复杂度及算法内容</title>
    <link href="https://accepted.org.cn/2021/06/18/%E7%AE%97%E6%B3%95%E9%A2%98%E7%94%B1%E7%BB%99%E5%AE%9A%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
    <id>https://accepted.org.cn/2021/06/18/%E7%AE%97%E6%B3%95%E9%A2%98%E7%94%B1%E7%BB%99%E5%AE%9A%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</id>
    <published>2021-06-18T00:09:43.000Z</published>
    <updated>2021-06-26T09:25:21.508Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>可以从数据范围分析出大致的最高限度的复杂度要求</p><a id="more"></a><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ul><li>$n≤30$, 指数级别, dfs+剪枝，状态压缩dp</li><li>$n≤100 =&gt; O(n3)$，floyd，dp，高斯消元</li><li>$n≤1000 =&gt; O(n2)，O(n^2logn)$，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>$n≤10000 =&gt; O(n \sqrt n)$，块状链表、分块、莫队</li><li>$n≤100000 =&gt; O(nlogn)$ =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分</li><li>$n≤1000000 =&gt; O(n)$, 以及常数较小的 $O(nlogn)$ 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa</li><li>$n≤10000000 =&gt; O(n)$，双指针扫描、kmp、AC自动机、线性筛素数</li><li>$n≤10^9 =&gt; O(\sqrt n)$，判断质数</li><li>$n≤10^{18} =&gt; O(logn)$，最大公约数，快速幂</li><li>$n≤10^{1000} =&gt; O((logn)^2)$，高精度加减乘除</li><li>$n≤10^{100000} =&gt; O(logk×loglogk)$，k表示位数$O(logk×loglogk)$，k表示位数，高精度加减、FFT/NTT</li></ul><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://www.acwing.com/blog/content/32/" target="_blank" rel="noopener">由数据范围反推算法复杂度以及算法内容</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;可以从数据范围分析出大致的最高限度的复杂度要求&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="复杂度" scheme="https://accepted.org.cn/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛常用STL和其他c++知识点总结</title>
    <link href="https://accepted.org.cn/2021/06/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8STL%E5%92%8C%E5%85%B6%E4%BB%96c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://accepted.org.cn/2021/06/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8STL%E5%92%8C%E5%85%B6%E4%BB%96c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-11T13:32:03.000Z</published>
    <updated>2021-06-21T03:01:26.786Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>都是常用的。</p><a id="more"></a><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>对数组<code>vector&lt;int&gt; a</code>排序：<br><code>#include &lt;algorithm&gt;</code></p><ul><li><p>升序<br><code>sort(a.begin(), a.end());</code><br><code>sort(a.begin(), a.end(), less&lt;int&gt;());</code></p></li><li><p>降序<br><code>sort(a.begin(), a.end(), greater&lt;int&gt;());</code><br><code>sort(a.rbegin(), a.rend());</code></p></li></ul><h4 id="字符串转数值类型"><a href="#字符串转数值类型" class="headerlink" title="字符串转数值类型"></a>字符串转数值类型</h4><p><code>#include &lt;string&gt;</code><br><strong>std::atoi</strong><br>转换 const char* 为一个 int 类型整数，超出 int 类型范围时，返回边界值。</p><p><strong>std::atol</strong><br>转换 const char* 为一个 long 类型整数，超出 long 类型范围时，返回边界值。</p><p><strong>std::atoll</strong><br>转换 const char* 为一个 long long 类型整数，超出 long long 类型范围时，返回边界值。</p><p><strong>std::stoi</strong><br>转换 std::string 为一个 int 类型整数，超出 int 类型范围时报错。</p><p><strong>std::stol</strong><br>转换 std::string 为一个 long 类型整数，超出 long 类型范围时报错。</p><p><strong>std::stoll</strong><br>转换 std::string 为一个 long long 类型整数，超出 long long 类型范围时报错。</p><h3 id="其他C-知识点"><a href="#其他C-知识点" class="headerlink" title="其他C++知识点"></a>其他C++知识点</h3><h4 id="0x0-输出指定位的小数点或有效数字"><a href="#0x0-输出指定位的小数点或有效数字" class="headerlink" title="0x0 输出指定位的小数点或有效数字"></a>0x0 输出指定位的小数点或有效数字</h4><p><strong>举例：</strong><br><code>float a = 233.233;</code></p><ul><li><p>输出保留2位小数:<br><code>inlcude &lt;iomanip&gt;</code><br><code>cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; a;</code><br>四舍五入输出<code>233.23</code><br>其中，<code>setiosflags(ios::fixed)</code> 为设置浮点数以固定的小数位数显示。<br><code>setprecision(2)</code> 为设置精度为2.</p></li><li><p>输出保留5位有效数字<br><code>cout &lt;&lt; setprecision(5) &lt;&lt; a;</code><br>四舍五入输出<code>233.23</code></p></li></ul><div class="note primary">            <p><strong>参考链接：</strong> <a href="https://www.cnblogs.com/ysx1997/p/7753579.html" target="_blank" rel="noopener">C++ 如何保留两位小数和有效位数</a></p>          </div><div class="note primary">            <p><strong>参考链接：</strong> <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/10705252.html" target="_blank" rel="noopener">C++ 标准库之 iomanip 、操作符 ios::fixed 以及 setprecision 使用的惨痛教训经验总结</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;都是常用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="STL" scheme="https://accepted.org.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1091. 二进制矩阵中的最短路径</title>
    <link href="https://accepted.org.cn/2021/06/06/LeetCode-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>https://accepted.org.cn/2021/06/06/LeetCode-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2021-06-06T15:20:56.000Z</published>
    <updated>2021-06-26T03:25:23.398Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS模板题</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p><p>二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p><ul><li>路径途经的所有单元格都的值都是 0 。</li><li>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li></ul><p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p><p><strong>示例 1：</strong></p><blockquote><p><img src="example1_1.png" alt="0x0"><br>输入：grid = [[0,1],[1,0]]<br>输出：2</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><img src="example2_1.png" alt="0x1"><br>输入：grid = [[0,0,0],[1,1,0],[1,1,0]]<br>输出：4</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：grid = [[1,0,0],[1,1,0],[1,1,0]]<br>输出：-1</p></blockquote><p><strong>提示：</strong></p><ul><li>$n == grid.length$</li><li>$n == grid[i].length$</li><li>$1 &lt;= n &lt;= 100$</li><li>$grid[i][j]$ 为 $0$ 或 $1$</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dc[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">        pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] || !R) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        q[++tt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, <span class="number">1</span>&#125;;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh;)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; node = q[hh++];</span><br><span class="line">            <span class="comment">// determin if current node is end of grids</span></span><br><span class="line">            <span class="keyword">int</span> r = node.first.first, c = node.first.second, len = node.second;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; r &lt;&lt; "-" &lt;&lt; c &lt;&lt; "-" &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (r == R - <span class="number">1</span> &amp;&amp; c == C - <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i];</span><br><span class="line">                <span class="keyword">int</span> nec = c + dc[i];</span><br><span class="line">                <span class="keyword">int</span> nel = len + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// determin if in range</span></span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; R &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; C &amp;&amp; !grid[ner][nec])    <span class="comment">// valid node</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; ner &lt;&lt; "-" &lt;&lt; nec &lt;&lt; "-" &lt;&lt; nel &lt;&lt; endl;</span></span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, nel&#125;;</span><br><span class="line">                    grid[ner][nec] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>咱们来思考一个问题：<br>Q: 为什么首先到达终点的路径一定是最短的？<br>A: 对于基于某个点的下一层，路径长度相等。因为BFS借助队列实现，如果存在两条不同长度的路径，那么可以认为他们之间是「平行」的，可以在某点处分道扬镳，最短路径一定最先抵达终点。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">LeetCode 1091. 二进制矩阵中的最短路径</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS模板题&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
      <category term="Flood Fill" scheme="https://accepted.org.cn/tags/Flood-Fill/"/>
    
      <category term="洪水灌溉算法" scheme="https://accepted.org.cn/tags/%E6%B4%AA%E6%B0%B4%E7%81%8C%E6%BA%89%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
