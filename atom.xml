<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dirac Sea</title>
  
  <subtitle>where the water tastes like wine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://accepted.org.cn/"/>
  <updated>2021-07-05T16:44:55.985Z</updated>
  <id>https://accepted.org.cn/</id>
  
  <author>
    <name>etoa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 726. 原子的数量</title>
    <link href="https://accepted.org.cn/2021/07/06/LeetCode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/06/LeetCode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-05T16:34:58.000Z</published>
    <updated>2021-07-05T16:44:55.985Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很容易想到使用DFS解决问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个化学式 $formula$（作为字符串），返回每种原子的数量。</p><p>原子总是以一个大写字母开始，接着跟随 $0$ 个或任意个小写字母，表示原子的名字。</p><p>如果数量大于 $1$，原子后会跟着数字表示原子的数量。如果数量等于 $1$ 则不会跟数字。例如，$H2O$ 和 $H2O2$ 是可行的，但 $H1O2$ 这个表达是不可行的。</p><p>两个化学式连在一起是新的化学式。例如 $H2O2He3Mg4$ 也是化学式。</p><p>一个括号中的化学式和数字（可选择性添加）也是化学式。例如 $(H2O2)$ 和 $(H2O2)3$ 是化学式。</p><p>给定一个化学式 $formula$ ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 $1$），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 $1$），以此类推。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：formula = “H2O”<br>输出：”H2O”<br>解释：<br>原子的数量是 {‘H’: 2, ‘O’: 1}。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：formula = “Mg(OH)2”<br>输出：”H2MgO2”<br>解释：<br>原子的数量是 {‘H’: 2, ‘Mg’: 1, ‘O’: 2}。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：formula = “K4(ON(SO3)2)2”<br>输出：”K4N2O14S4”<br>解释：<br>原子的数量是 {‘K’: 4, ‘N’: 2, ‘O’: 14, ‘S’: 4}。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：formula = “Be32”<br>输出：”Be32”</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= formula.length &lt;= 1000$</li><li>$formula$ 由小写英文字母、数字 <code>(</code> 和 <code>)</code> 组成。</li><li>$formula$ 是有效的化学式。</li></ul><hr><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>本题会遇到嵌套的括号，可以使用递归解决问题。<br>每遇到左括号就进入递归，并计算括号内的原子数量，保存在 <code>map</code> 中。<br>遇到右括号递归终止，返回。<br>回溯阶段判断右括号外的倍数问题，将返回的 <code>map</code> 中原子数目全部乘倍数。<br>因为题目要求使用字典序输出内容，故不使用 <code>unordered_map</code> 而使用 <code>map</code>.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-6 00:43:56</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        n = formula.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ordereded_map = dfs(formula, u);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[atom, cnt] : ordereded_map) &#123;</span><br><span class="line">            res += atom;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) res += to_string(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string, int&gt; dfs(string &amp;formula, int &amp;u) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tres;</span><br><span class="line">        <span class="keyword">for</span> (; u &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (formula[u] == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++u;</span><br><span class="line">                <span class="keyword">auto</span> tmap = dfs(formula, u);</span><br><span class="line">                <span class="comment">// checks if current is digits</span></span><br><span class="line">                <span class="keyword">int</span> mul = <span class="number">0</span>, k = u;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">isdigit</span>(formula[k]); ++k) &#123;</span><br><span class="line">                    mul = mul * <span class="number">10</span> + formula[k] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!mul) ++mul;</span><br><span class="line">                u = k;</span><br><span class="line">                <span class="comment">// merge</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[atom, cnt] : tmap) &#123;</span><br><span class="line">                    tres[atom] += cnt * mul;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (formula[u] == <span class="string">')'</span>) &#123;    <span class="comment">// endof dfs</span></span><br><span class="line">                ++u;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">int</span> k = u + <span class="number">1</span>;  <span class="comment">// 从字母的下一位开始</span></span><br><span class="line">                <span class="built_in">string</span> atom;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">islower</span>(formula[k]); ++k);</span><br><span class="line">                <span class="keyword">int</span> atomlen = k - u;</span><br><span class="line">                atom = formula.substr(u, atomlen);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; atom &lt;&lt; endl;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; n &amp;&amp; <span class="built_in">isdigit</span>(formula[k]); k++) &#123;</span><br><span class="line">                    cnt = cnt * <span class="number">10</span> + formula[k] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!cnt) ++cnt;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                tres[atom] += cnt;</span><br><span class="line">                u = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; MPSI;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MPSI <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        MPSI res;</span><br><span class="line">        <span class="keyword">while</span> (u &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'('</span>) &#123;</span><br><span class="line">                u ++ ;</span><br><span class="line">                <span class="keyword">auto</span> t = dfs(str, u);</span><br><span class="line">                u ++ ;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>, k = u;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[k])) k ++ ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; u) &#123;</span><br><span class="line">                    cnt = stoi(str.substr(u, k - u));</span><br><span class="line">                    u = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y]: t) res[x] += y * cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[u] == <span class="string">')'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> k = u + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="string">'a'</span> &amp;&amp; str[k] &lt;= <span class="string">'z'</span>) k ++ ;</span><br><span class="line">                <span class="keyword">auto</span> key = str.substr(u, k - u);</span><br><span class="line">                u = k;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[k])) k ++ ;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; u) &#123;</span><br><span class="line">                    cnt = stoi(str.substr(u, k - u));</span><br><span class="line">                    u = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res[key] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> t = dfs(formula, k);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y]: t) &#123;</span><br><span class="line">            res += x;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; <span class="number">1</span>) res += to_string(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-atoms/" target="_blank" rel="noopener">LeetCode 726. 原子的数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很容易想到使用DFS解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯" scheme="https://accepted.org.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛248】C LeetCode 5802. 统计好数字的数目</title>
    <link href="https://accepted.org.cn/2021/07/05/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91C-LeetCode-5802-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://accepted.org.cn/2021/07/05/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91C-LeetCode-5802-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-07-04T17:14:16.000Z</published>
    <updated>2021-07-05T03:45:26.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典模意义下快速幂应用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 $0$ 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （$2$，$3$，$5$ 或 $7$）。</p><ul><li>比方说，$2582$ 是好数字，因为偶数下标处的数字（$2$ 和 $8$）是偶数且奇数下标处的数字（$5$ 和 $2$）为质数。但 $3245$ <strong>不是</strong> 好数字，因为 $3$ 在偶数下标处但不是偶数。</li></ul><p>给你一个整数 $n$ ，请你返回长度为 $n$ 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对 $10^9 + 7$ <strong>取余后返回</strong> 。</p><p>一个 <strong>数字字符串</strong> 是每一位都由 $0$ 到 $9$ 组成的字符串，且可能包含前导 $0$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 1<br>输出：5<br>解释：长度为 1 的好数字包括 “0”，”2”，”4”，”6”，”8” 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 4<br>输出：400</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：n = 50<br>输出：564908303</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= n &lt;= 10^{15}$</li></ul><hr><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>对于长度为 $n$ 的数字，偶数位对应着 $0, 2, 4, 6, 8$ 共 $5$ 种选择；奇数位对应着 $2, 3, 5, 7$ 共 $4$ 种选择。</p><p>偶数位共有 $\lceil n / 2 \rceil$ 个，奇数位共有 $\lfloor n / 2 \rfloor$ 个。</p><p>那么答案应该是 $5^{\lceil n / 2 \rceil} \times 4^{\lfloor n / 2 \rfloor} \bmod (10^9 + 7)$.</p><p>使用模意义下的快速幂可以在 $O(log(\lceil n / 2 \rceil + \lfloor n / 2 \rfloor))$ 复杂度内算出。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="number">1'000'000'007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(LL a, LL b, LL MOD)</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % MOD;</span><br><span class="line">            a = a * a % MOD;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodNumbers</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">        LL even = n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        LL odd = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (ksm(<span class="number">5</span>, even, MOD) * ksm(<span class="number">4</span>, odd, MOD)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-good-numbers/" target="_blank" rel="noopener">LeetCode 5802. 统计好数字的数目</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典模意义下快速幂应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="248" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/248/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="数论" scheme="https://accepted.org.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="https://accepted.org.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第四讲-数学知识-快速幂 AcWing 875. 快速幂</title>
    <link href="https://accepted.org.cn/2021/07/04/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%BF%AB%E9%80%9F%E5%B9%82-AcWing-875-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://accepted.org.cn/2021/07/04/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E5%BF%AB%E9%80%9F%E5%B9%82-AcWing-875-%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2021-07-04T15:46:47.000Z</published>
    <updated>2021-07-04T17:00:24.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典快速求幂的算法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 $n$ 组 $a_i$, $b_i$, $p_i$，对于每组数据，求出 $a_i^{b_i} \bmod p_i$ 的值。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $n$。</p><p>接下来 $n$ 行，每行包含三个整数 $a_i$, $b_i$, $p_i$。</p><p><strong>输出格式</strong></p><p>对于每组数据，输出一个结果，表示 $a_i^{b_i} \bmod p_i$ 的值。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><ul><li>$1≤n≤100000$,</li><li>$1≤a_i, b_i, p_i≤2×10^9$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>2<br>3 2 5<br>4 3 9</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>4<br>1</p></blockquote><hr><h3 id="二进制反复平方"><a href="#二进制反复平方" class="headerlink" title="二进制反复平方"></a>二进制反复平方</h3><p>本题是模意义下取幂，我们知道取模运算不会干涉乘法运算。所以我们核心关注如何求 $a^b$.</p><p>如果我们可以将 $b$ 拆分成 $2^{x_1} + 2^{x_2} + … + 2^{x_i}$，那么</p><p>$a^b = a^{2^{x_1} + 2^{x_2} + … + 2^{x_i}}$ (即$a^b = a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}$).</p><p>显然这是将 $b$ 转化为 $2$ 进制后进行 $10$ 进制展开的结果，很轻松可以做到。</p><p>那么现在考虑如何快速获得 $a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}$ 的值。</p><p>我们可以很方便地预处理出来 $a^{2^0}, a^{2^1}, a^{2^2} … a^{2^{log_2b}}$ 的序列。其中最后一项 $a^{2^{log_2b}}$ 需要刚好小于等于 $a^{b}$.</p><p>有了这样一个序列，我们就可以从中选择需要的数字相乘即可得到最终答案。显然，当 $b$ 的二进制位为1的时候就是对应需要的值（如果二进制位为 $0$，则 $10$ 进制展开的时候是 $0 \times 2^{x_i}$，相加的时候被忽略）。</p><p>在预处理过程中，每一项都是由前一项平方得到，那么整个算法的时间复杂度为 $O(logb)$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>; <span class="comment">// 2的零次幂</span></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="comment">// 如果b的最后一位是1，那么将b拆成2进制表示再分解成若干个2的xi次幂因式的时候，某一个因式对应着该位</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;  <span class="comment">// a,b &gt;= 1，所以至少需要算一下第一次a的2的0次幂(等于a)，所以res初始化为1. 随后的计算, a被更新成对应a的2的若干次幂</span></span><br><span class="line">        <span class="comment">// 不管b最后一位是否是1，都需要反复求a的平方，直到a的2的x次幂 &gt; a的b次幂，此时一共计算了log_2b次</span></span><br><span class="line">        a = (LL)a * a % p;  <span class="comment">// 下一次a更新成本次a的平方，其中a = a的2的xi次幂</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;    <span class="comment">// b右移一位，直到为0退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a, b, p;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ksm(a, b, p) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>现在证明模意义下取幂的正确性：<br>根据模运算性质可知，<br>$x \times y \bmod p = x \bmod p \times y \bmod p$.</p><p>那么，$a^b \bmod p = (a^{2^{x_1}} \times a^{2^{x_2}} \times … \times a^{2^{x_i}}) \bmod p$.</p><p>即$a^b \bmod p = (a^{2^{x_1}} \bmod p \times a^{2^{x_2}} \bmod p \times … \times a^{2^{x_i}} \bmod p) \bmod p$.</p><p>那么每次 $a$ 的迭代 $\bmod p$ 一次，对应上式中每一项 $\bmod p$，每次 $res$ 计算的时候 $\bmod p$ 一次对应上式中最后面的 $\bmod p$.</p><p>取模运算不会干涉乘法运算。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/description/877/" target="_blank" rel="noopener">AcWing 875. 快速幂</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典快速求幂的算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第四讲数学知识" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E5%9B%9B%E8%AE%B2%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://accepted.org.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="位运算" scheme="https://accepted.org.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
      <category term="数论" scheme="https://accepted.org.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="https://accepted.org.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛248】B LeetCode 5801. 消灭怪物的最大数量</title>
    <link href="https://accepted.org.cn/2021/07/04/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91B-LeetCode-5801-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/04/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B248%E3%80%91B-LeetCode-5801-%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-04T14:22:06.000Z</published>
    <updated>2021-07-04T14:36:05.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>很明显的贪心题，植物大战僵尸。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 $0$ 开始</strong> 且长度为 $n$ 的整数数组 $dist$ ，其中 $dist[i]$ 是第 $i$ 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p><p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 $n$ 的整数数组 $speed$ 表示每个怪物的速度，其中 $speed[i]$ 是第 $i$ 个怪物的速度（单位：米/分）。</p><p>怪物从 <strong>第 $0$ 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为 <strong>输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  $n$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dist = [1,3,4], speed = [1,1,1]<br>输出：3<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。<br>第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。<br>第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。<br>所有 3 个怪物都可以被消灭。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dist = [1,1,2,3], speed = [1,1,1,1]<br>输出：1<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。<br>你只能消灭 1 个怪物。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：dist = [3,2,4], speed = [5,3,2]<br>输出：1<br>解释：<br>第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。<br>你只能消灭 1 个怪物。</p></blockquote><p><strong>提示：</strong></p><ul><li>$n = dist.length = speed.length$</li><li>$1 &lt;= n &lt;= 10^5$</li><li>$1 &lt;= dist[i], speed[i] &lt;= 10^5$</li></ul><hr><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>不能根据距离判断优先击杀的对象，因为速度不同，所以要根据预计到达时间来判断。<br>因为每次击杀之后都需要获得最近到达的对象，所以考虑将所有对象的预计到达时间计算出来，从小到大排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eliminateMaximum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            time.push_back((<span class="keyword">double</span>)dist[i] / speed[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= time[i]) <span class="keyword">return</span> res;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters/" target="_blank" rel="noopener">LeetCode 5801. 消灭怪物的最大数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;很明显的贪心题，植物大战僵尸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="248" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/248/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="贪心" scheme="https://accepted.org.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛247】C LeetCode 1915. 最美子字符串的数目</title>
    <link href="https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91C-LeetCode-1915-%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91C-LeetCode-1915-%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/</id>
    <published>2021-07-03T15:51:04.000Z</published>
    <updated>2021-07-05T16:49:13.415Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>将奇偶性的状态压缩成一个二进制数字。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果某个字符串中 至多一个 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p><ul><li>例如，$ccjjc$ 和 $abab$ 都是最美字符串，但 $ab$ 不是。</li></ul><p>给你一个字符串 $word$ ，该字符串由前十个小写英文字母组成（$a$ 到 $j$）。请你返回 $word$ 中 <strong>最美非空子字符串</strong> 的数目。如果同样的子字符串在 $word$ 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数。</p><p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：word = “aba”<br>输出：4<br>解释：4 个最美子字符串如下所示：<br>– “aba” -&gt; “a”<br>– “aba” -&gt; “b”<br>– “aba” -&gt; “a”<br>– “aba” -&gt; “aba”</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：word = “aabb”<br>输出：9<br>解释：9 个最美子字符串如下所示：<br>– “aabb” -&gt; “a”<br>– “aabb” -&gt; “aa”<br>– “aabb” -&gt; “aab”<br>– “aabb” -&gt; “aabb”<br>– “aabb” -&gt; “a”<br>– “aabb” -&gt; “abb”<br>– “aabb” -&gt; “b”<br>– “aabb” -&gt; “bb”<br>– “aabb” -&gt; “b”</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：word = “he”<br>输出：2<br>解释：2 个最美子字符串如下所示：<br>– “he” -&gt; “h”<br>– “he” -&gt; “e”</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= word.length &lt;= 10^5$</li><li>$word$ 由从 $a$ 到 $j$ 的小写英文字母组成</li></ul><hr><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>根据题意，在某个最美子串中，所有的字母出现的的次数要么全为偶数次，要么有一位字母出现了奇数次。<br>很容易想到使用前缀和快速拿到出现次数。配合暴力枚举子串，复杂度为 $n \times (n + 1) / 2$，必然超时。</p><p>定义前缀和数组 $presum[N][j]$，其中 $1 &lt;= N &lt;= 10^5$, $j = 10$. $presum[i][j]$ 表示在原字符串中从第 $1$ 位开始到第 $i$ 位结尾的子串某个字母出现的次数。</p><p>那么一段下标为 $[a, b]$ 的子串，它的某个字母 $j$ 出现次数可表示为 $presum[b][j] - presum[a - 1][j]$。 根据数学知识，如果它是一个奇数，那么 $presum[b][j]$ 和 $presum[a - 1][j]$ 奇偶性不同，反之相同。</p><p>那么问题就变成了：在字符串所有子串中，每个字母对应的 $presum[b][j]$ 和 $presum[a - 1][j]$ 奇偶性不同的情况最多只能出现一次的子串一共多少。</p><p>现在对前缀和数组的某一项的每一位字母出现的奇偶性状态进行压缩。<br>对于某个子串，我们可以将出现奇数次的字母记为 $1$，将出现偶数次的字母记为 $0$.由于字母范围为字母表前 $10$ 个，那么一段子串的每一位字母出现次数的奇偶性状态可表示为一个 $10$ 位的二进制数。</p><p>$presum[b][j]$ 和 $presum[a - 1][j]$ 的各字母出现奇偶性的状态都可以表示成一个 $10$ 位二进制数。<br>对于以下标 $b$ 结尾的前缀子串的奇偶性状态，以下标 $a$ 结尾的子串共有 $11$ 种对应的状态可以满足奇偶性不同的情况最多一次的条件。其中，完全和该状态相同的状态表示奇偶性不同的情况出现 $0$ 次，即奇偶性完全相同；另外 $10$ 种对应着原状态的 $10$ 位奇偶状态的某一位不同。<br>比如一个状态为：<code>0001000110</code>. 满足条件的 $11$ 种状态如下：<br><code>0001000110</code><br><code>1001000110</code><br><code>0101000110</code><br><code>0011000110</code><br><code>0000000110</code><br><code>0001100110</code><br><code>0001010110</code><br><code>0001001110</code><br><code>0001000010</code><br><code>0001000100</code><br><code>0001000111</code><br>那么我们考虑遍历字符串，当遍历到第 $b$ 位时，枚举上述 $11$ 种状态，如果之前出现过其中一种或多种，那么以那一种或多种对应下标开始到 $b$ 结束的子串即满足要求。</p><p>所以我们需要一个计数数组，将从第 $1$ 个字符开始到遍历到的每一位字符结束的状态数量记录下来供后面使用。<br>考虑到二进制状态数字最高 $10$ 位，所以可以开一个数量为 $10000000000_2$（$1024_{10}$）的计数数组.</p><p>另外，思考一下计数数组的第 $0$ 位初始化为什么应该是 $1$.<br>在字符串第 $0$ 位之前，存在一个状态 <code>0000000000</code>，它表示每一位字母出现了 $0$ 次（均为偶数）。所以这种状态在遍历之前计数为 $1$.</p><p>举例：对于一个字符串 $a$ 来说，它的最美子串数目为 $1$. 我们初始化状态 <code>0000000000</code> 的数量为 $1$，这样，在遍历到字符串第 $0$ 个数的时候状态为 <code>1000000000</code>，$11$ 个期望的状态中共有一种符合与之构成最美子串的状态，即初始化的 <code>0000000000</code>. 这两个状态有一位字母的出现的奇偶性不同。对应子串为 $a$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[N];    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="keyword">word</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                presum[i + <span class="number">1</span>][j] = presum[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            presum[i + <span class="number">1</span>][c - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; 10; j++) &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; presum[i + 1][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">                state = state * <span class="number">2</span> + presum[i + <span class="number">1</span>][j] % <span class="number">2</span>;    <span class="comment">// 跟10进制一样的。一段十进制序列转换成十进制数：for (int j = 0; j &lt; len; j++) res = res * 10 + seq[j];</span></span><br><span class="line">            <span class="comment">// 对于当前以i结尾的字符串，根据当前状态枚举每一种可能的状态，通过cnt数组查看之前有没有出现过</span></span><br><span class="line">            <span class="comment">// 首先是完全一样的状态，如果在[0, i - 1]这一段出现过跟以i结尾的字符串完全一致的状态，那么它们构成的子串有0个字母出现了奇数次</span></span><br><span class="line">            res += cnt[state];</span><br><span class="line">            <span class="comment">// 其次是10种不同状态，每种有一位和当前状态不同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                res += cnt[state ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[state]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>代码涉及到的两个额外知识，且都和位运算有关:</p><ol><li><p>将一段二进制序列转换成十进制数：<br>对于以下标b结束的前缀和字母计数序列，需要将它的各位奇偶性状态压缩成一个二进制数。代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    state = state * <span class="number">2</span> + presum[i + <span class="number">1</span>][j] % <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个二进制数 $x$，它的距离最低位 $k$ 个数字不同且其他位相同的二进制数为：<br><code>x ^ (1 &lt;&lt; k)</code></p></li></ol><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings/" target="_blank" rel="noopener">LeetCode 1915. 最美子字符串的数目</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;将奇偶性的状态压缩成一个二进制数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="247" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/247/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="位运算" scheme="https://accepted.org.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="前缀和" scheme="https://accepted.org.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】C LeetCode 1911. 最大子序列交替和</title>
    <link href="https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91C-LeetCode-1911-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/"/>
    <id>https://accepted.org.cn/2021/07/03/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91C-LeetCode-1911-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/</id>
    <published>2021-07-03T04:50:36.000Z</published>
    <updated>2021-07-05T16:49:27.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典的状态机类型的dp问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个下标从 $0$ 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p><ul><li>比方说，数组 $[4,2,5,3]$ 的交替和为 $(4 + 5) - (2 + 3) = 4$ 。</li></ul><p>给你一个数组 $nums$ ，请你返回 $nums$ 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 $0$ 开始编号）。</p><p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，$[2,7,4]$ 是 $[4,2,3,7,2,1,4]$ 的一个子序列（加粗元素），但是 $[2,4,2]$ 不是。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [4,2,5,3]<br>输出：7<br>解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [5,6,7,8]<br>输出：8<br>解释：最优子序列为 [8] ，交替和为 8 。</p></blockquote><p><strong>示例 3：</strong></p><p>输入：nums = [6,2,1,2,4,5]<br>输出：10<br>解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。</p><p><strong>提示：</strong></p><ul><li>$1 &lt;= nums.length &lt;= 10^5$</li><li>$1 &lt;= nums[i] &lt;= 10^5$</li></ul><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>状态集合：</strong> 前 $i$ 个数字，数字总数为偶数的子序列与前 $i$ 个数字，数字总数为奇数的子序列构成的集合。</p><p><strong>状态集合元素属性：</strong> 对于集合中的每个元素（子序列），定义子序列的交替和的最大值为元素属性。</p><p><strong>状态计算：</strong> 设 $f[i][0]$ 为前 $i$ 个数字，数字总数为偶数的子序列的最大交替和；设 $f[i][1]$ 为前 $i$ 个数字，数字总数为奇数的子序列的最大交替和；</p><p>对前 $i$ 个数字依次计算两种交替和：</p><ul><li><p>前 $i$ 个数字，子序列总数为偶数时，最后一个数字 $nums[i]$ 可取可不取。</p><ul><li><p>取第 $i$ 个数字时，对于整个构成的子序列而言，由原数组前 $i - 1$ 个数字构成的子序列前部分总数一定是奇数，那么问题就变成了，由原数组前 $i - 1$ 个数字构成的总数为奇数的子序列的最大交替和与第 $i$ 项数字共同构成的子序列的最大交替和是多少。因为子序列下标从 $0$ 开始计算，取最后一项后总数是偶数，那么最后一项在子序列中的下标一定是奇数。由交替和的定义可知：</p><p>$f[i][0] = f[i - 1][1] - nums[i]$</p></li><li><p>不取第 $i$ 个数字时，我们从前 $i - 1$ 项来考虑。我们现在假设由原数组前 $i - 1$ 项构成的子序列总数是偶数，现在有第 $i$ 项存在，但是我们不取，那么原数组前 $i$ 项构成的子序列总数依然是偶数，且有：</p><p>$f[i][0] = f[i - 1][0]$</p></li><li><p>将上述两种情况合并有：</p><p>$f[i][0] = max(f[i - 1][0], f[i - 1][1] - nums[i])$</p></li></ul></li><li><p>前i个数字，子序列总数为奇数时，最后一个数字 $nums[i]$ 也是可取可不取。</p><ul><li><p>取第 $i$ 个数字时，这里又分为两种情况：</p><ul><li><p>取了之后放弃子序列中所有前面的值，只留原数组第 $i$ 个数，总数依旧是奇数。<br>那么有：</p><p>$f[i][1] = 0 + nums[i]$</p></li><li><p>取了之后保留子序列中所有前面的值，对于整个构成的子序列而言，由原数组前 $i - 1$ 个数字构成的子序列前部分总数一定是偶数，那么问题就变成了，由原数组前 $i - 1$ 个数字构成的总数为偶数的子序列的最大交替和与第 $i$ 项数字共同构成的子序列的最大交替和是多少。因为子序列下标从 $0$ 开始计算，取最后一项后总数是奇数，那么最后一项在子序列中的下标一定是偶数。由交替和的定义可知：</p><p>$f[i][1] = f[i - 1][1] + nums[i]$</p></li><li><p>将这两种子情况合并有：</p><p>$f[i][1] = max(0 + f[i - 1][1]) + nums[i]$</p></li></ul></li><li><p>不取第 $i$ 个数字时，我们从前 $i - 1$ 项来考虑。我们现在假设由原数组前 $i - 1$ 项构成的子序列总数是奇数，现在有第 $i$ 项存在，但是我们不取，那么原数组前 $i$ 项构成的子序列总数依然是奇数，且有：</p><p>$f[i][1] = f[i - 1][1]$</p></li><li><p>将上述两种情况合并有：</p><p>$f[i][1] = max(f[i - 1][1], max(0 + f[i - 1][1]) + nums[i])$</p></li></ul></li></ul><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][0]: 前 i 个数，总数为偶数的子序列的最大交替和</span></span><br><span class="line">        <span class="comment">// dp[i][1]: 前 i 个数，总数为奇数的子序列的最大交替和</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 考虑前i个数中子序列总数为偶数的情况</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - nums[i]);</span><br><span class="line">            <span class="comment">// 考虑前i个数中子序列总数为奇数的情况</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="built_in">max</span>(<span class="number">0l</span>l, dp[i - <span class="number">1</span>][<span class="number">0</span>]) + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>仔细观察不难发现，dp数组每一项都是非负的（因为原数组每一项取值为$1 &lt;= nums[i] &lt;= 10^5$，且dp数组的初始项非负，且后序计算是不断地取最大值扩展的），那么 <code>max(0ll, dp[i - 1][0]) + nums[i]</code> 可以优化成 <code>dp[i - 1][0] + nums[i]</code>.</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/" target="_blank" rel="noopener">LeetCode 1911. 最大子序列交替和</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典的状态机类型的dp问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://accepted.org.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="状态机" scheme="https://accepted.org.cn/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 451. 根据字符出现频率排序</title>
    <link href="https://accepted.org.cn/2021/07/03/LeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <id>https://accepted.org.cn/2021/07/03/LeetCode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-03T01:14:28.000Z</published>
    <updated>2021-07-03T01:27:42.861Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>STL sort() 配合Lambda表达式排序。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p><strong>示例 1:</strong></p><p>输入:</p><blockquote><p>“tree”<br>输出:<br>“eert”<br>解释:<br>‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p></blockquote><p><strong>示例 2:</strong></p><p>输入:</p><blockquote><p>“cccaaa”<br>输出:<br>“cccaaa”<br>解释:<br>‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。<br>注意”cacaca”是不正确的，因为相同的字母必须放在一起。</p></blockquote><p><strong>示例 3:</strong></p><p>输入:</p><blockquote><p>“Aabb”<br>输出:<br>“bbAa”<br>解释:<br>此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。<br>注意’A’和’a’被认为是两种不同的字符。</p></blockquote><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>先将字符计数，再根据计数来排序。<br>需要注意的地方是，当两个不同字符频率相同时，可能会出现顺序打乱的情况，比如说 $a$ 出现 $2$ 次，$b$ 出现 $2$ 次，那么输出可能是 $abab$。<br>为了避免这样的情况，我们需要在不同字符出现相同频率后再按照ascii码排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            cnt[s[i]]++;</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="keyword">char</span> a, <span class="keyword">char</span> b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[a] != cnt[b]) <span class="keyword">return</span> cnt[a] &gt;= cnt[b];</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>为什么要用Lambda呢，因为leetcode排序 <code>cmp</code> 如果写在类里面需要加 <code>static</code> (不加会隐式的加上this指针)，<code>cmp</code> 中需要用到 <code>cnt</code> 数组或者哈希表，这时候就需要将 <code>cnt</code> 数组或者哈希表放在类变量中或者类外面。如果放在类变量中，因为 <code>cmp</code> 函数时 <code>static</code> 的，那么 <code>cnt</code> 数组或者哈希表也需要是 <code>static</code> 的，就会出现一些很奇怪的问题。如果放在类外面，因为leetcode的问题也会出现一些很奇怪的问题比如执行测试用例可以过但是提交评测无法通过的情况。具体请看：<br><a href="https://eetoa.github.io/2021/06/06/在LeetCode刷题应尽量避免使用全局变量/" target="_blank" rel="noopener">在LeetCode刷题应尽量避免使用全局变量</a></p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">LeetCode 451. 根据字符出现频率排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;STL sort() 配合Lambda表达式排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode周赛247】B LeetCode 1914. 循环轮转矩阵</title>
    <link href="https://accepted.org.cn/2021/07/02/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91B-LeetCode-1914-%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>https://accepted.org.cn/2021/07/02/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B247%E3%80%91B-LeetCode-1914-%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5/</id>
    <published>2021-07-02T14:12:30.000Z</published>
    <updated>2021-07-05T16:49:33.853Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道模拟过程的题目，不难，但是有点繁琐。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 $m \times n$ 的整数矩阵 $grid$​​​ ，其中 $m$ 和 $n$ 都是 <strong>偶数</strong> ；另给你一个整数 $k$ 。</p><p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p><p><img src="0.png" alt="0x0"></p><p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针</strong> 方向的相邻元素。轮转示例如下：</p><p><img src="1.jpg" alt="0x1"><br>返回执行 $k$ 次循环轮转操作后的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="2.png" alt="0x2"></p><blockquote><p>输入：grid = [[40,10],[30,20]], k = 1<br>输出：[[10,20],[40,30]]<br>解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="3.png" alt="0x3"></p><p><img src="4.png" alt="0x3"></p><p><img src="5.png" alt="0x3"></p><blockquote><p>输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2<br>输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]<br>解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</p></blockquote><hr><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>将每一层放到一个队列中，再计算出每一层的每一位对应轮转 $k$ 次后在队列中的什么位置。<br>将每一层分为 $4$ 次分别处理入队，分别是上右下左，依次是行不变列增加；行增加列不变；行不变列减小；行减小列减小。<br>另外注意不能数组原地替换，因为前面被替换的数原本包含着最后的要替换的数的数。所以需要额外维护一个同样大小的数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">rotateGrid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mxr = R, mxc = C, <span class="built_in">begin</span> = <span class="number">0</span>; mxr &gt; <span class="number">0</span> &amp;&amp; mxc &gt; <span class="number">0</span>; mxr -= <span class="number">2</span>, mxc -= <span class="number">2</span>, ++<span class="built_in">begin</span>) &#123; <span class="comment">// 逐层将坐标放入数组中</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; <span class="built_in">queue</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="built_in">begin</span>, c = <span class="built_in">begin</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxc - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(r, ++c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxr - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(++r, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxc - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(r, --c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mxr - <span class="number">1</span>; i++) <span class="built_in">queue</span>.emplace_back(--r, c);</span><br><span class="line">            <span class="comment">//for (auto &amp;each : queue) cout &lt;&lt; grid[each.first][each.second] &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">queue</span>.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (i + k) % len;</span><br><span class="line">                res[<span class="built_in">queue</span>[i].first][<span class="built_in">queue</span>[i].second] = grid[<span class="built_in">queue</span>[t].first][<span class="built_in">queue</span>[t].second];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="模拟-DFS"><a href="#模拟-DFS" class="headerlink" title="模拟 + DFS"></a>模拟 + DFS</h3><p>我的思路是先确定一共需要进行多少层轮转，对于每一层的每一次轮转写进行一次深搜，一共 $k$ 次，注意 $k$ 需要对一层的总数取模。</p><p>核心在于如何对指定层进行一次轮转。</p><p>深搜从每一层的左上角开始，所以我们要确定每一层的第一个数坐标。<br>深搜过程中到达拐点处需要改变搜索方向，所以我们需要知道每一层的长和宽。<br>另外我们需要对搜索过的格子进行计数，以便判断递归终止。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">rotateGrid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="built_in">min</span>(R, C) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; level &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//return res;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mod = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            mod = <span class="number">2</span> * (R - i * <span class="number">2</span>) + <span class="number">2</span> * (C - i * <span class="number">2</span>) - <span class="number">4</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; mod &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> t = k % mod;</span><br><span class="line">            rotation(grid, i, t, mod, R - i * <span class="number">2</span>, C - i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">inline</span> <span class="title">rotation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g, <span class="keyword">int</span> level, <span class="keyword">int</span> k, <span class="keyword">int</span> mod, <span class="keyword">int</span> mxr, <span class="keyword">int</span> mxc)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; start = &#123;<span class="number">0</span> + level * <span class="number">1</span>, <span class="number">0</span> + level * <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> direction = <span class="number">0</span>; k--; direction = <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, g, start, start, <span class="number">0</span>, mod, mxr, mxc, direction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> value, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;start, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;mod, <span class="keyword">int</span> &amp;mxr, <span class="keyword">int</span> &amp;mxc, <span class="keyword">int</span> &amp;direction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; pos.first &lt;&lt; ',' &lt;&lt; pos.second &lt;&lt; "," &lt;&lt; cnt &lt;&lt; ',' &lt;&lt; mod &lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == mod) &#123;</span><br><span class="line">            g[pos.first][pos.second] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nevalue = g[pos.first][pos.second];</span><br><span class="line">        g[pos.first][pos.second] = value;</span><br><span class="line">        <span class="keyword">if</span> ((pos.first == start.first + mxr - <span class="number">1</span> &amp;&amp; pos.second == start.second) || (pos.first == start.first + mxr - <span class="number">1</span> &amp;&amp; pos.second == start.second + mxc - <span class="number">1</span>) || (pos.first == start.first &amp;&amp; pos.second == start.second + mxc - <span class="number">1</span>)) &#123;</span><br><span class="line">            direction++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ner = pos.first + dr[direction], nec = pos.second + dc[direction];</span><br><span class="line">        dfs(nevalue, g, start, &#123;ner, nec&#125;, cnt + <span class="number">1</span>, mod, mxr, mxc, direction);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/cyclically-rotating-a-grid/submissions/" target="_blank" rel="noopener">LeetCode 1914. 循环轮转矩阵</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道模拟过程的题目，不难，但是有点繁琐。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
      <category term="247" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%91%A8%E8%B5%9B/247/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="模拟" scheme="https://accepted.org.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1833. 雪糕的最大数量</title>
    <link href="https://accepted.org.cn/2021/07/02/LeetCode-1833-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>https://accepted.org.cn/2021/07/02/LeetCode-1833-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</id>
    <published>2021-07-02T00:41:56.000Z</published>
    <updated>2021-07-02T00:50:11.348Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>排序+贪心题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 $n$ 支雪糕，用长度为 $n$ 的数组 $costs$ 表示雪糕的定价，其中 $costs[i]$ 表示第 $i$ 支雪糕的现金价格。Tony 一共有 $coins$ 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 $costs$ 和现金量 $coins$ ，请你计算并返回 Tony 用 $coins$ 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p>注意：Tony 可以按任意顺序购买雪糕。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：costs = [1,3,2,4,1], coins = 7<br>输出：4<br>解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：costs = [10,6,8,7,7,8], coins = 5<br>输出：0<br>解释：Tony 没有足够的钱买任何一支雪糕。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：costs = [1,6,3,1,2,5], coins = 20<br>输出：6<br>解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。</p></blockquote><p><strong>提示：</strong></p><ul><li>$costs.length = n$</li><li>$1 &lt;= n &lt;= 10^5$</li><li>$1 &lt;= costs[i] &lt;= 10^5$</li><li>$1 &lt;= coins &lt;= 10^8$</li></ul><hr><h3 id="贪心-计数排序"><a href="#贪心-计数排序" class="headerlink" title="贪心+计数排序"></a>贪心+计数排序</h3><p>因为数组中数值存在一个范围，那么我们可以用计数排序的方法优化排序的复杂度为线性。</p><p>按照价格升序选择雪糕，最终个数一定是最多的。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = costs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            cnt[costs[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N &amp;&amp; coins &gt;= i; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; cnt[i]--;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins &gt;= i) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    coins -= i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/" target="_blank" rel="noopener">LeetCode 1833. 雪糕的最大数量</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;排序+贪心题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="贪心" scheme="https://accepted.org.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="计数排序" scheme="https://accepted.org.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LCP 07. 传递信息</title>
    <link href="https://accepted.org.cn/2021/07/01/LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/"/>
    <id>https://accepted.org.cn/2021/07/01/LCP-07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</id>
    <published>2021-07-01T05:42:12.000Z</published>
    <updated>2021-07-01T05:50:58.929Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单深搜题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 $n$ 名玩家，所有玩家编号分别为 $0$ ～ $n-1$，其中小朋友 A 的编号为 $0$</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 $n$，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 $relation$。返回信息从小 A (编号 $0$ ) 经过 $k$ 轮传递到编号为 $n-1$ 的小伙伴处的方案数；若不能到达，返回 $0$。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3<br>输出：3<br>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：n = 3, relation = [[0,2],[2,1]], k = 2<br>输出：0<br>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p></blockquote><p><strong>限制：</strong></p><ul><li>$2 &lt;= n &lt;= 10$</li><li>$1 &lt;= k &lt;= 5$</li><li>$1 &lt;= relation.length &lt;= 90$, 且 $relation[i].length == 2$</li><li>$0 &lt;= relation[i][0],relation[i][1] &lt; n$ 且 $relation[i][0] != relation[i][1]$</li></ul><hr><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-7-1 13:49:27</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt[N];</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rela, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rela.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; each = rela[i];</span><br><span class="line">            cnt[each[<span class="number">0</span>]].push_back(each[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == n - <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path = cnt[node];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nenode = path[i];</span><br><span class="line">            dfs(n, k, u + <span class="number">1</span>, nenode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/" target="_blank" rel="noopener">LCP 07. 传递信息</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单深搜题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】B LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91B-LeetCode-1910-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E7%BB%99%E5%AE%9A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-30T15:23:56.000Z</published>
    <updated>2021-07-05T16:49:44.686Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>简单字符串替换。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 $s$ 和 $part$ ，请你对 $s$ 反复执行以下操作直到 <strong>所有</strong> 子字符串 $part$ 都被删除：</p><ul><li>找到 $s$ 中 <strong>最左边</strong> 的子字符串 $part$ ，并将它从 $s$ 中删除。</li></ul><p>请你返回从 $s$ 中删除所有 $part$ 子字符串以后得到的剩余字符串。</p><p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “daabcbaabcbc”, part = “abc”<br>输出：”dab”<br>解释：以下操作按顺序执行：</p></blockquote><ul><li>s = “daabcbaabcbc” ，删除下标从 2 开始的 “abc” ，得到 s = “dabaabcbc” 。</li><li>s = “dabaabcbc” ，删除下标从 4 开始的 “abc” ，得到 s = “dababc” 。</li><li>s = “dababc” ，删除下标从 3 开始的 “abc” ，得到 s = “dab” 。<br>此时 s 中不再含有子字符串 “abc” 。</li></ul><p><strong>示例 2：</strong></p><p>输入：s = “axxxxyyyyb”, part = “xy”<br>输出：”ab”<br>解释：以下操作按顺序执行：</p><ul><li>s = “axxxxyyyyb” ，删除下标从 4 开始的 “xy” ，得到 s = “axxxyyyb” 。</li><li>s = “axxxyyyb” ，删除下标从 3 开始的 “xy” ，得到 s = “axxyyb” 。</li><li>s = “axxyyb” ，删除下标从 2 开始的 “xy” ，得到 s = “axyb” 。</li><li>s = “axyb” ，删除下标从 1 开始的 “xy” ，得到 s = “ab” 。<br>此时 s 中不再含有子字符串 “xy” 。</li></ul><p><strong>提示：</strong></p><ul><li>$1 &lt;= s.length &lt;= 1000$</li><li>$1 &lt;= part.length &lt;= 1000$</li><li>$s$​​​​​​ 和 $part$ 只包小写英文字母。</li></ul><hr><h3 id="字符串查找替换"><a href="#字符串查找替换" class="headerlink" title="字符串查找替换"></a>字符串查找替换</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOccurrences</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.<span class="built_in">size</span>(), len2 = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, idx), s2 = s.substr(idx + len2);</span><br><span class="line">            s = s1 + s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/" target="_blank" rel="noopener">LeetCode 1910. 删除一个字符串中所有出现的给定子字符串</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;简单字符串替换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://accepted.org.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode双周赛55】A LeetCode 1909. 删除一个元素使数组严格递增</title>
    <link href="https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"/>
    <id>https://accepted.org.cn/2021/06/30/%E3%80%90LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B55%E3%80%91A-LeetCode-1909-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</id>
    <published>2021-06-30T14:43:09.000Z</published>
    <updated>2021-07-05T16:49:54.913Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>签到题，但是又不那么水，题目质量挺好。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 $0$ 开始的整数数组 $nums$ ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 $true$ ，否则返回 $false$ 。如果数组本身已经是严格递增的，请你也返回 $true$ 。</p><p>数组 $nums$ 是 <strong>严格递增</strong> 的定义为：对于任意下标的 $1 &lt;= i &lt; nums.length$ 都满足 $nums[i - 1] &lt; nums[i]$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,2,10,5,7]<br>输出：true<br>解释：从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。<br>[1,2,5,7] 是严格递增的，所以返回 true 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [2,3,1,2]<br>输出：false<br>解释：<br>[3,1,2] 是删除下标 0 处元素后得到的结果。<br>[2,1,2] 是删除下标 1 处元素后得到的结果。<br>[2,3,2] 是删除下标 2 处元素后得到的结果。<br>[2,3,1] 是删除下标 3 处元素后得到的结果。<br>没有任何结果数组是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1,1,1]<br>输出：false<br>解释：删除任意元素后的结果都是 [1,1] 。<br>[1,1] 不是严格递增的，所以返回 false 。</p></blockquote><p><strong>示例 4：</strong></p><p>输入：nums = [1,2,3]<br>输出：true<br>解释：[1,2,3] 已经是严格递增的，所以返回 true 。</p><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 1000$</li><li>$1 &lt;= nums[i] &lt;= 1000$</li></ul><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举每一位数，剔除后判断剩余数组是否严格单调递增。复杂度 $O(N^2)$, 数组长度最高 $1000$，复杂度是$1000000$ ，可以过掉。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= last) &#123;</span><br><span class="line">                    isgood = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isgood) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><p>从 <code>-1</code> 开始枚举需要删除的数，<code>-1</code> 表示不删除任何数，判断原数组是否为严格单调递增，太妙了。<br>注意 <code>nums.size()</code> 返回的是一个 <code>unsigned int</code> 类型，需要强转成 <code>int</code> 类型，配合 <code>-1</code>，不然有bug。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/" target="_blank" rel="noopener">LeetCode 1909. 删除一个元素使数组严格递增</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;签到题，但是又不那么水，题目质量挺好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="LeetCode双周赛" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
      <category term="55" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AB%9E%E8%B5%9B/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/55/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="竞赛" scheme="https://accepted.org.cn/tags/%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 297. 二叉树的序列化与反序列化</title>
    <link href="https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://accepted.org.cn/2021/06/30/LeetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-30T03:18:11.000Z</published>
    <updated>2021-06-30T03:32:40.375Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>根据遍历来序列化和反序列化二叉树。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例1：</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：root = [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：root = []<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：root = [1]<br>输出：[1]</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：root = [1,2]<br>输出：[1,2]</p></blockquote><p><strong>提示：</strong></p><ul><li>树中结点数在范围 $[0, 104]$ 内</li><li>$-1000 &lt;= Node.val &lt;= 1000$</li></ul><p><strong>树的定义和方法的调用：</strong></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure></div></div></div><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在看这道题前，请回顾一下 <a href="https://eetoa.github.io/2021/02/23/剑指Offer-07-重建二叉树/" target="_blank" rel="noopener">剑指Offer 07. 重建二叉树</a>.<br>在上面这道题中，为了反序列化一颗二叉树，我们需要前序遍历序列和中序遍历序列，当这两个序列不包含原树的空节点。<br>如果给定一个包含原树空节点的前序遍历序列，我们就可以直接反序列化这颗二叉树。</p><p>另外这道题注意节点值的负数情况。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs_s(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) path += <span class="string">"#,"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path += to_string(root-&gt;val) + <span class="string">','</span>;</span><br><span class="line">            dfs_s(root-&gt;left);</span><br><span class="line">            dfs_s(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span>&amp; data, <span class="keyword">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = u;</span><br><span class="line">            <span class="keyword">while</span> (data[u] != <span class="string">','</span>) u ++ ;</span><br><span class="line">            <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(stoi(data.substr(k, u - k)));</span><br><span class="line">            u ++ ;</span><br><span class="line">            root-&gt;left = dfs_d(data, u);</span><br><span class="line">            root-&gt;right = dfs_d(data, u);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/" target="_blank" rel="noopener">LeetCode 297. 二叉树的序列化与反序列化</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;根据遍历来序列化和反序列化二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://accepted.org.cn/tags/DFS/"/>
    
      <category term="树" scheme="https://accepted.org.cn/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://accepted.org.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【AcWing算法基础】第一讲-基础算法-归并排序 AcWing 787. 归并排序</title>
    <link href="https://accepted.org.cn/2021/06/29/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-AcWing-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://accepted.org.cn/2021/06/29/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-AcWing-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-29T03:52:06.000Z</published>
    <updated>2021-06-29T13:34:12.370Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>经典归并排序模板。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定你一个长度为 $n$ 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 $n$。</p><p>第二行包含 $n$ 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出共一行，包含 $n$ 个整数，表示排好序的数列。</p><p><strong>数据范围</strong></p><ul><li>$1≤n≤100000$</li></ul><p><strong>输入样例：</strong></p><blockquote><p>5<br>3 1 2 4 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>1 2 3 4 5</p></blockquote><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的核心思想是递归地将原数组划分成两段，在不可再分的时候（一对数或一个数）进行第一次双指针排序。<br>然后在「归」的过程利用上一层已经排序好的两段，将它们使用双指针合并排序。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ms</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ms(lo, mid), ms(mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi;) &#123;              <span class="comment">// 对于两段升序子数组，用双指针进行合并排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) tmp[idx++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果某一段较另一段提前完成，需要将另一段加入到已排序临时数组后面。注意另一段数组元素一定大于等于已排序的临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = a[i++];</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= hi; ) tmp[idx++] = a[j++];</span><br><span class="line">    <span class="comment">// 将已排序的临时数组覆盖原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> re = lo, t = <span class="number">0</span>; re &lt;= hi;) a[re++] = tmp[t++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ms(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/789/" target="_blank" rel="noopener">AcWing 787. 归并排序</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;经典归并排序模板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/"/>
    
      <category term="算法基础课" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    
      <category term="第一讲基础算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E7%AC%AC%E4%B8%80%E8%AE%B2%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://accepted.org.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="AcWing" scheme="https://accepted.org.cn/tags/AcWing/"/>
    
      <category term="归并排序" scheme="https://accepted.org.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 168. Excel表列名称</title>
    <link href="https://accepted.org.cn/2021/06/29/LeetCode-168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
    <id>https://accepted.org.cn/2021/06/29/LeetCode-168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</id>
    <published>2021-06-29T02:10:42.000Z</published>
    <updated>2021-06-29T03:15:45.556Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>稍微复杂点的26进制问题。本题来自第八届蓝桥杯省赛C++C组。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><p>输入: 1<br>输出: “A”</p><p><strong>示例 2:</strong></p><p>输入: 28<br>输出: “AB”</p><p><strong>示例 3:</strong></p><p>输入: 701<br>输出: “ZY”</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>因为对于给定的 $10$ 进制，在直接换算成 $16$ 进制的时候，会遇到余数为 $0$ 的问题。而 $0$ 无法对应 $26$ 进制中的某一个数。</p><p>通过观察规律，不难发现，一个十进制数 $n$ 可以拆分成 $x \times 26 + y$ 的形式，其中 $x &gt;= 0, 0 &lt;= y &lt;= 26$.</p><ul><li>当 $x = 0$ 时，不予考虑；</li><li>当 $x &lt;= 26$ 时，它对应 $[A,Z]$ 的一个字母；</li><li>当 $x &gt; 26$ 时，递归地将 $x$ 拆成 $xx \times 26 + yy$ 的形式；</li><li>当 $y = 0$ 时，对应 $26$，需要从 $x$ 借 $1$ 位；</li><li>当 $0 &lt; y &lt; 26$ 时，对应 $[A,Z]$ 的一个字母。</li></ul><p>举例：</p><blockquote><p>根据如上规律，对 $703$ 进行拆分：</p><p>$703 = (1 \times 26 + 1) \times 26 + 1$</p><p>即 $AAA$.</p></blockquote><blockquote><p>对 $702$ 进行拆分：</p><p>$702 = 26 \times 26 + 26$</p><p>即 $ZZ$</p></blockquote><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">        helper(n, t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res += t[i] - <span class="number">1</span> + <span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x * 26 + y</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            t.push_back(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = n / <span class="number">26</span>, y = n % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span> (!y) x--, y = <span class="number">26</span>;</span><br><span class="line">        t.push_back(y);</span><br><span class="line">        helper(x, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">LeetCode 168. Excel表列名称</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;稍微复杂点的26进制问题。本题来自第八届蓝桥杯省赛C++C组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="蓝桥杯" scheme="https://accepted.org.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="进制" scheme="https://accepted.org.cn/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 815. 公交路线</title>
    <link href="https://accepted.org.cn/2021/06/28/LeetCode-815-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/"/>
    <id>https://accepted.org.cn/2021/06/28/LeetCode-815-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/</id>
    <published>2021-06-28T15:16:17.000Z</published>
    <updated>2021-06-28T15:31:20.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道较为抽象的BFS最短路问题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 $routes$ ，表示一系列公交线路，其中每个 $routes[i]$ 表示一条公交线路，第 $i$ 辆公交车将会在上面循环行驶。</p><p>例如，路线 $routes[0] = [1, 5, 7]$ 表示第 $0$ 辆公交车会一直按序列 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … 这样的车站路线行驶。<br>现在从 $source$ 车站出发（初始时不在公交车上），要前往 $target$ 车站。 期间仅可乘坐公交车。</p><p>求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 $-1$ 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>routes = [[1,2,7],[3,6,7]], source = 1, target = 6</code><br>输出：<code>2</code><br>解释：最优策略是先乘坐第一辆公交车到达车站 <code>7</code> , 然后换乘第二辆公交车到车站 <code>6</code> 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12</code><br>输出：<code>-1</code></p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= routes.length &lt;= 500$</li><li>$1 &lt;= routes[i].length &lt;= 10^5$</li><li>$routes[i]$ 中的所有值 <strong>互不相同</strong></li><li>$sum(routes[i].length) &lt;= 10^5$</li><li>$0 &lt;= routes[i][j] &lt; 10^6$</li><li>$0 &lt;= source, target &lt; 10^6$</li></ul><hr><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><img src="0.png" alt="0x0"></p><center><font size=1>图片作者：div@acwing</font></center><p>可以将每个路线抽象成一个点，题目即求出从某个路线到目标路线的最短距离。</p><p>建图（以路线抽象成的点构成的图）：将每个点对应的路线存到哈希表中，如果遍历到的某个点存在着除自己所在路线外的其他路线，那么就可以从当前路线BFS到另外这条路线上。</p><p>我们维护一个距离数组记录距离，亦可作为标记数组。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-28 23:21:19</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line">    <span class="keyword">int</span> q[N];                                       <span class="comment">// 路线队列</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hash;           <span class="comment">// 点对应相关的所有路线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dist[N];                                    <span class="comment">// 路线对应已走过的距离，同时具备标记已走过的路线的功能（初始化成无穷大，如果值不是无穷大说明已经走过）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; routes, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = routes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;             <span class="comment">// 遍历所有路线找到起点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : routes[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == source) &#123;                  <span class="comment">// 找到起始点</span></span><br><span class="line">                    q[++tt] = i;                    <span class="comment">// 将对应路线入队</span></span><br><span class="line">                    dist[i] = <span class="number">1</span>;                    <span class="comment">// 至少需要一站路，距离从1开始，将来BFS到其他路线，距离增加1</span></span><br><span class="line">                &#125;</span><br><span class="line">                hash[x].push_back(i);               <span class="comment">//将所有点和其所在的路线对应起来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh;) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q[hh++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : routes[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == target) <span class="keyword">return</span> dist[cur];  <span class="comment">// 找到目标点，返回距离</span></span><br><span class="line">                                                    <span class="comment">// 否则将点对应的所有路线入队，注意跳过已走过的路线，因为已走过的路线及上面所有点必然已经被遍历过一次，点对应的所有路线必然已被入队，避免重复</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : hash[x]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i] == <span class="number">0x3f3f3f3f</span>) &#123;    <span class="comment">// 新的路线</span></span><br><span class="line">                        q[++tt] = i;                <span class="comment">// 路线入队</span></span><br><span class="line">                        dist[i] = dist[cur] + <span class="number">1</span>;    <span class="comment">// 将下一个路线距离在本路线基础上+1，顺便标记为已访问</span></span><br><span class="line">                    &#125;</span><br><span class="line">                                                    <span class="comment">// 否则是已访问过的路线（已入队或已遍历），直接跳过</span></span><br><span class="line">                &#125;</span><br><span class="line">                                                    <span class="comment">// 将已遍历过的点擦除，道理和标记已访问过的路线一样，只要点被遍历过，那么它对应的所有路线必然已入队。</span></span><br><span class="line">                hash.erase(x);                      <span class="comment">// 将已遍历的点从hashmap中删除，为什么不从别的地方删除？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/bus-routes/comments/" target="_blank" rel="noopener">LeetCode 815. 公交路线</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道较为抽象的BFS最短路问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
      <category term="最短路" scheme="https://accepted.org.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 909. 蛇梯棋</title>
    <link href="https://accepted.org.cn/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/"/>
    <id>https://accepted.org.cn/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/</id>
    <published>2021-06-27T09:48:05.000Z</published>
    <updated>2021-06-27T10:32:47.063Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>BFS魔改题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$N \times N$ 的棋盘 $board$ 上，按从 $1$ 到 $N \times N$ 的数字给方格编号，编号 <strong>从左下角开始</strong>，每一行交替方向。</p><p>例如，一块 $6 \times 6$ 大小的棋盘，编号如下：</p><p><img src="0.png" alt="0x0"></p><p>$r$ 行 $c$ 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 $board[r][c] != -1$，那个蛇或梯子的目的地将会是 $board[r][c]$。</p><p>玩家从棋盘上的方格 $1$ （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 $x$ 开始出发，按下述要求前进：</p><ul><li><p>选定目标方格：选择从编号 $x+1$，$x+2$，$x+3$，$x+4$，$x+5$，或者 $x+6$ 的方格中选出一个目标方格 $s$ ，目标方格的编号 $&lt;= N \times N$。</p><ul><li>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 $[x+1, x+6]$ 之间。</li></ul></li><li><p>传送玩家：如果目标方格 $S$ 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 $S$。<br>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p></li></ul><p>返回达到方格 $N \times N$ 所需的最少移动次数，如果不可能，则返回 $-1$。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong><br>[[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,35,-1,-1,13,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,15,-1,-1,-1,-1]]<br><strong>输出：</strong> 4<br><strong>解释：</strong><br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</p></blockquote><p><strong>提示：</strong></p><ul><li>$2 &lt;= board.length = board[0].length &lt;= 20$</li><li>$board[i][j]$ 介于 $1$ 和 $N \times N$ 之间或者等于 $-1$。</li><li>编号为 $1$ 的方格上没有蛇或梯子。</li><li>编号为 $N \times N$ 的方格上没有蛇或梯子。</li></ul><hr><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>这道题很容易看出来是一道利用BFS找到最短路径步数的题目。和一般的BFS题不同之处在于引入了「传送门」的概念，以及搜索方向是蛇形的。<br>引入「传送门」的概念并不妨碍最先BFS到终点的路径一定最短这一BFS特性。<br>重要的是，我们还是要标记出已经到达的位置，以避免重复入队。<br>把棋盘上非 $-1$ 的数字看成一个位置指针，也不必考虑到循环指针的问题。因为只要做好重复标记，可以避免所有循环指针入队。</p><p>我和yxc解法的区别主要在于路径长度记录和重复标记方法。<br>对于路径长度记录，我是将路径长度和路径点坐标放在一起入队，每次搜索下一个点，将路径 $+1$；而yxc是维护一个和原棋盘大小相同的每个值初始化为无穷大的 <code>dist</code> 二维数组，将起点设为 $0$，每搜索到一个点，如果是新的点，就在当前点的距离上 $+1$。</p><p>对于重复标记，我是将已入队的位置在原棋盘上更改为一个特定值 <code>0x3f3f3f3f</code>；而yxc的解法利用记录路径长度的二维数组，如果搜索到的新点对应值是无穷大，说明确实是一个新的点，如果不是，则之前已被搜过。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-27 18:12:16</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">404</span>;</span><br><span class="line">    pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = board.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = R - <span class="number">1</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ((-r + R) &amp; <span class="number">1</span>) ? <span class="number">0</span> : C - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; C; last++) &#123;</span><br><span class="line">                grid[r][c] = last + <span class="number">1</span>;</span><br><span class="line">                heap[last + <span class="number">1</span>] = &#123;r, c&#125;;</span><br><span class="line">                <span class="keyword">if</span> ((-r + R) &amp; <span class="number">1</span>) c++;</span><br><span class="line">                <span class="keyword">else</span> c--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = R * C;</span><br><span class="line">        q[++tt] = &#123;&#123;R - <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">        board[R - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; hh++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first.first, c = q[hh].first.second;</span><br><span class="line">            <span class="keyword">int</span> x = grid[r][c];</span><br><span class="line">            <span class="keyword">int</span> cnt = q[hh].second;</span><br><span class="line">            </span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = x + i;</span><br><span class="line">                <span class="keyword">int</span> ner = heap[nex].first, nec = heap[nex].second;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "ner: " &lt;&lt; ner &lt;&lt; " nec: " &lt;&lt; nec &lt;&lt; " nex: " &lt;&lt; nex &lt;&lt; " cnt: " &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (nex == target || board[ner][nec] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nex &gt; target || board[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// determine teleport beacon</span></span><br><span class="line">                <span class="keyword">if</span> (board[ner][nec] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q[++tt] = &#123;heap[board[ner][nec]], cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                board[ner][nec] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; cor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        id = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        cor = <span class="built_in">vector</span>&lt;PII&gt;(n * m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, k = <span class="number">1</span>, s = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --, s ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">1e9</span>))</span></span>;</span><br><span class="line">        q.push(&#123;n - <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        dist[n - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> k = id[t.x][t.y];</span><br><span class="line">            <span class="keyword">if</span> (k == n * m) <span class="keyword">return</span> dist[t.x][t.y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= k + <span class="number">6</span> &amp;&amp; i &lt;= n * m; i ++ ) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = cor[i].x, y = cor[i].y;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = board[x][y];</span><br><span class="line">                    x = cor[r].x, y = cor[r].y;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode 909. 蛇梯棋</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;BFS魔改题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊递归</title>
    <link href="https://accepted.org.cn/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/"/>
    <id>https://accepted.org.cn/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/</id>
    <published>2021-06-25T10:10:29.000Z</published>
    <updated>2021-06-25T13:58:17.079Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>递归、回溯、DFS，都聊一聊。</p><a id="more"></a><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>很简单，就是指一段函数内部调用自己。细一点，它分为「递」和「归」两个过程。<br>这些都是大家都知道的东西，今天我想聊一聊如何构建一段标准的递归代码。</p><p>首先是递归进入条件。<br>首次在递归函数外部调用递归函数的条件，需要和递归函数内部调用自身的条件一致。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;递归、回溯、DFS，都聊一聊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法相关" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://accepted.org.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 149. 直线上最多的点数</title>
    <link href="https://accepted.org.cn/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <id>https://accepted.org.cn/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</id>
    <published>2021-06-24T09:45:27.000Z</published>
    <updated>2021-06-24T10:16:13.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>主要是考虑从哪个角度入手暴搜。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</p><p><strong>示例1:</strong></p><p><img src="0.jpg" alt="0x0"></p><blockquote><p>输入：points = [[1,1],[2,2],[3,3]]<br>输出：3</p></blockquote><p><strong>示例2:</strong></p><p><img src="1.jpg" alt="0x1"></p><blockquote><p>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>输出：4</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= points.length &lt;= 300$</li><li>$points[i].length == 2$</li><li>$-10^4 &lt;= xi, yi &lt;= 10^4$</li><li>$points$ 中的所有点 <strong>互不相同</strong></li></ul><hr><h3 id="暴搜"><a href="#暴搜" class="headerlink" title="暴搜"></a>暴搜</h3><p>对于某一个点，把它看成中心点，平面上会有无穷多条直线经过它。对于一个中心点，剩余点的每个点都和它构成一条直线。我们统计剩余点和中心点构成直线的数量。</p><p>注意剩余点和中心点垂直的情况，此时可以用一个额外的变量来统计和中心点垂直的点的数量。<br>注意相同点的情况，即剩余点和中心点重合，虽然题目条件说明所有点互不相同，但是这里依旧考虑这一情况。<br>注意本题精度要求较高，计算斜率使用 long double 变量。<br>如果精度要求更高，可以考虑用分数来存放斜率，这时候需要求分子分母最大公约数。</p><div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-24 17:54:50</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> center = <span class="number">0</span>, vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">double</span> ratio = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[j] == points[i]) center++;   <span class="comment">// 至少包含一个中心点 points[i]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (points[j][<span class="number">0</span>] == points[i][<span class="number">0</span>]) vertical++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ratio = (<span class="keyword">long</span> <span class="keyword">double</span>)(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]) / (points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    cnt[ratio]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 垂线和斜线数量取较大者</span></span><br><span class="line">            <span class="keyword">int</span> mxratio = vertical;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : cnt) &#123;</span><br><span class="line">                mxratio = <span class="built_in">max</span>(mxratio, value);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mxratio + center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">LeetCode 149. 直线上最多的点数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;主要是考虑从哪个角度入手暴搜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="哈希表" scheme="https://accepted.org.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1162. 地图分析</title>
    <link href="https://accepted.org.cn/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <id>https://accepted.org.cn/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</id>
    <published>2021-06-23T10:38:43.000Z</published>
    <updated>2021-06-26T03:28:20.766Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>一道经典的多源BFS题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你现在手里有一份大小为 $N*N$ 的 网格 $grid$，上面的每个 单元格 都用 $0$ 和 $1$ 标记好了。其中 $0$ 代表海洋，$1$ 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：$(x0, y0)$ 和 $(x1, y1)$ 这两个单元格之间的距离是 $|x0 - x1| + |y0 - y1|$ 。</p><p>如果网格上只有陆地或者海洋，请返回 $-1$。</p><p><strong>示例 1：</strong></p><p><img src="1.jpeg" alt="0x0"></p><blockquote><p>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="2.jpeg" alt="0x1"></p><blockquote><p>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</p></blockquote><p><strong>提示：</strong></p><ol><li>$1 &lt;= grid.length == grid[0].length &lt;= 100$</li><li>$grid[i][j]$ 不是 $0$ 就是 $1$</li></ol><hr><h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p>遍历数组，将所有岛屿入队，每次根据当前结点计算出下一个海洋结点，就将海洋结点值设为父结点的值加一。<br>于是，就像水中的多点扰动水面一样，最终涟漪交汇的地方就是最远海洋结点。</p><div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-23 18:47:28</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) q[++tt] = &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// determine special situation</span></span><br><span class="line">        <span class="keyword">int</span> qsize = tt - hh + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qsize == R * C || !qsize) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; ++hh) &#123;                         <span class="comment">// pop head</span></span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first, c = q[hh].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || grid[ner][nec]) <span class="keyword">continue</span>;</span><br><span class="line">                grid[ner][nec] = grid[r][c] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;ner, nec&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, grid[i][j]);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; grid[i][j] &lt;&lt; ' ';</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">LeetCode 1162. 地图分析</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;一道经典的多源BFS题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="算法" scheme="https://accepted.org.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://accepted.org.cn/tags/LeetCode/"/>
    
      <category term="BFS" scheme="https://accepted.org.cn/tags/BFS/"/>
    
  </entry>
  
</feed>
