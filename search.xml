<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记录对hexo yilia主题的个性定制</title>
    <url>/2020/10/30/%E8%AE%B0%E5%BD%95%E5%AF%B9hexo-yilia%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%AE%9A%E5%88%B6/</url>
    <content><![CDATA[<h3 id="1-隐藏多余的「展开更多」"><a href="#1-隐藏多余的「展开更多」" class="headerlink" title="1. 隐藏多余的「展开更多」"></a>1. 隐藏多余的「展开更多」</h3><blockquote>
<ul>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>定位到<code>&lt;a class=&quot;.article-more-a&quot; href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;</code></li>
<li>行内添加<code>style=“display: none;”</code></li>
</ul>
</blockquote>
<h3 id="2-显示文章阅读次数"><a href="#2-显示文章阅读次数" class="headerlink" title="2. 显示文章阅读次数"></a>2. 显示文章阅读次数</h3><blockquote>
<ul>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>定位到<code>&lt;div class=&quot;article-inner&quot;&gt;</code></li>
<li>定位到<code>&lt;header class=&quot;article-header&quot;&gt;</code></li>
<li>在<code>&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;</code>下添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示阅读次数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"cloud-tie-join-count"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">style</span>=<span class="string">"color:gray;font-size:14px;"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-sort"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"color:#696969;font-size:14px;"</span>&gt;</span></span><br><span class="line">           阅读数: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次 <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--显示阅读次数--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="3-添加文章字数统计和阅读时长"><a href="#3-添加文章字数统计和阅读时长" class="headerlink" title="3. 添加文章字数统计和阅读时长"></a>3. 添加文章字数统计和阅读时长</h3><blockquote>
<ul>
<li>安装wordcount插件: <code>npm i –save hexo-wordcount</code></li>
<li>打开theme\yilia\layout_partial\post，创建<code>word.ejs</code>文件</li>
<li>在<code>word.ejs</code>中写入:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:10px;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-keyboard-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>  字数统计: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">wordcount</span>(<span class="attr">post.content</span>) %&gt;</span>字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-hourglass-half"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>  阅读时长: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">min2read</span>(<span class="attr">post.content</span>) %&gt;</span>分<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>在<code>&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;</code>下添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示文章字数统计以及阅读时长--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.word_count</span> &amp;&amp; !<span class="attr">post.no_word_count</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">word</span>') %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--显示文章字数统计以及阅读时长--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="4-添加页面顶部加载条"><a href="#4-添加页面顶部加载条" class="headerlink" title="4. 添加页面顶部加载条"></a>4. 添加页面顶部加载条</h3><blockquote>
<ul>
<li>打开theme\yilia\layout_partial\head.ejs</li>
<li>定位到：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">title</span>)&#123; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span> | <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在其下方添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--顶部加载条--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">background</span>: <span class="selector-id">#6d6d6d</span>; <span class="comment">/*进度条颜色*/</span></span></span><br><span class="line">       height: 2px;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress-inner</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#1E92FB</span>, 0 0 5<span class="selector-tag">px</span>     <span class="selector-id">#6d6d6d</span>; <span class="comment">/*阴影颜色*/</span></span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-activity</span> &#123;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">border-top-color</span>: <span class="selector-id">#6d6d6d</span>;    <span class="comment">/*上边框颜色*/</span></span></span><br><span class="line"><span class="css">       <span class="selector-tag">border-left-color</span>: <span class="selector-id">#6d6d6d</span>;    <span class="comment">/*左边框颜色*/</span></span></span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--顶部加载条--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 788 或 LeetCode 剑指Offer 51 逆序对的数量</title>
    <url>/2020/10/27/AcWing-788-%E6%88%96-LeetCode-%E5%89%91%E6%8C%87Offer-51-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 <code>i</code> 个和第 <code>j</code> 个元素，如果满足 <code>i &lt; j</code> 且 <code>a[i] &gt; a[j]</code>，则其为一个逆序对；否则不是。</p>
<p><strong>输入格式</strong><br>第一行包含整数n，表示数列的长度。</p>
<p>第二行包含 n 个整数，表示整个数列。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。</p>
<p><strong>数据范围</strong><br><code>1≤n≤100000</code><br><strong>输入样例：</strong></p>
<blockquote>
<p>6<br>  2 3 4 5 6 1</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5</p>
</blockquote>
<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nums[N];</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    helper(lo, mid), helper(mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid &amp;&amp; j &lt;= hi;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) tmp[t++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid;) tmp[t++] = nums[i++];</span><br><span class="line">    <span class="keyword">for</span> (;j &lt;= hi;) tmp[t++] = nums[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi;) nums[i++] = tmp[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">    helper(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>跑路专用呆湾警署查封页面</title>
    <url>/2020/10/25/%E8%B7%91%E8%B7%AF%E4%B8%93%E7%94%A8%E5%91%86%E6%B9%BE%E8%AD%A6%E7%BD%B2%E6%9F%A5%E5%B0%81%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>效果图：<br><img src="2020-10-25-%E8%B7%91%E8%B7%AF%E4%B8%93%E7%94%A8%E5%91%86%E6%B9%BE%E8%AD%A6%E7%BD%B2%E6%9F%A5%E5%B0%81%E9%A1%B5%E9%9D%A2/img.jpg" alt="pic0x0"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-TW"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>網站已遭查禁<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Fonts --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span>  <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>  <span class="attr">integrity</span>=<span class="string">"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            font-family: 'Raleway', sans-serif;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">            -webkit-font-smoothing: antialiased;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            h1, h2, h3, h4, h5&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">font-family</span><span class="selector-pseudo">:'Montserrat'</span>, <span class="selector-tag">sans-serif</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="css">            <span class="selector-class">.img-content</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            align-content: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: auto;</span><br><span class="line">            height: 50%;</span><br><span class="line">            top: -50%;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            align-content: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: auto;</span><br><span class="line">            height: 50%;</span><br><span class="line">            top: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:3</span>%;</span></span><br><span class="line">            align-content: center ;</span><br><span class="line">            margin: auto 5% auto 5% ;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">top</span>, <span class="selector-id">#30cfd0</span> 0%, <span class="selector-id">#330867</span> 100%);</span></span><br><span class="line">            border-radius: 20px;</span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 6<span class="selector-tag">px</span> <span class="selector-id">#cccccc</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line">            font-family: "Microsoft JhengHei" ;</span><br><span class="line">            font-size: 50px;   </span><br><span class="line"><span class="css">            <span class="selector-tag">margin-top</span><span class="selector-pseudo">:1</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-bottom</span><span class="selector-pseudo">:3</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: <span class="selector-class">.9</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line">            font-size: 24px;</span><br><span class="line">            padding: 20px 0;</span><br><span class="line">            font-weight: 300;</span><br><span class="line">            width: 70%;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;script async src='/cdn-cgi/bm/cv/2172558837/api.js'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"bg-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:-11%;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://i.niupic.com/images/2020/04/10/7mLl.jpeg"</span> <span class="attr">style</span>=<span class="string">"align-content: center;text-align: center;width: 40%;height: auto; margin: auto auto 1% auto; "</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-12 text-center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:firebrick;"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>網站已經遭到查禁<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>(This Domain Has Been Seized)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>已經違背中華民國著作權法第九十一條及九十二條規範，全部或部分內容涉屬盜版，正進入司法偵查中。<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                        The website is in violation of the Copyright Act of the Republic of China (Taiwan) for its unauthorized use of materials.  Investigation is currently underway.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span>內政部警政署刑事警察局電偵大隊 敬啟 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                        Criminal Investigation Bureau（Taiwan）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">window</span>[<span class="string">'__CF$cv$params'</span>]=&#123;<span class="attr">r</span>:<span class="string">'580bbb10ab56988d'</span>,<span class="attr">m</span>:<span class="string">'89a8a3de2b7eced49bf0d7d5400be20e69b51188-1586346206-1800-AXfMipt69xS9k39OseM0Cvbr0f3Kbs2a6i15NQFaHcJ2EE29f4nRPtpVQp/KgduXqsjmOfivLCxx7gGaor0X8kEbM7J50HQX16lmdjp4bzFe+Nr/xYV+BXL01+ME0Wcofw=='</span>,<span class="attr">s</span>:[<span class="number">0xde0ce21efa</span>,<span class="number">0xa321d7537b</span>],<span class="attr">fb</span>:<span class="number">0</span>,&#125;&#125;)();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
  </entry>
  <entry>
    <title>位运算妙妙屋</title>
    <url>/2020/10/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%A6%99%E5%A6%99%E5%B1%8B/</url>
    <content><![CDATA[<h3 id="int类型利用位运算乘除2的k次幂"><a href="#int类型利用位运算乘除2的k次幂" class="headerlink" title="int类型利用位运算乘除2的k次幂"></a>int类型利用位运算乘除2的k次幂</h3><p>a乘以2的k次幂，相当于a &lt;&lt; k 不管a是否为正数。<br>a除以2的k次幂，相当于a &gt;&gt; k 当且仅当a为正数。<br>注意，其他类型不常用，有的可以有的不可以，故不列出。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法模板</title>
    <url>/2020/10/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排最难的地方在于边界问题。边界问题涉及到比较因子的选择以及各种条件判断。建议将模板直接背过。<br>今天看了闫学灿的快排讲解之后，感悟颇多，特地记录下来供以后复习。<br>首先上快排模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//end of recursion</span></span><br><span class="line">    <span class="keyword">int</span> cmp = q[(lo + hi) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = lo - <span class="number">1</span>, j = hi + <span class="number">1</span>; <span class="comment">// 每次指针移动，需要向中间偏移一位，故在这里也初始化设置成lo - 1和hi + 1</span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt; j;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; cmp);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; cmp);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(q, lo, j); <span class="comment">//                         1</span></span><br><span class="line">    qSort(q, j + <span class="number">1</span>, hi); <span class="comment">//                     2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于j要么等于i 要么j在i左边一位，故其中1和2可以改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>但是注意，如果 <code>cmp</code> 设置成 <code>q[lo]</code> 的话，则只能是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p>因为如果换成了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>的话会出现死循环问题。<br>举个例子：数组<code>{1, 2}</code>排序，<code>lo = 0, hi = 1, i = -1 , j = 2, cmp = 1</code>.<br>第一轮递归，<code>i = 0, j = 0</code>.<br><code>qSort(q, 0, -1);</code>  直接return.<br><code>qSort(q, 0, 1);</code>   死循环.</p>
<p>同理，如果 <code>cmp</code> 设置成 <code>q[hi]</code> 的话，使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p>也会发生死循环.</p>
<p>所以：<br><strong><code>cmp</code> 设置成 <code>q[lo]</code> 的话，递归调用必须是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p><strong><code>cmp</code> 设置成 <code>q[hi]</code> 的话，递归调用必须是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>为了保险起见，建议将cmp设置成中间位置。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是将原数组递归地一分为二，在最短子数组处完成排序，在回溯过程中合并子数组，以完成整个数组的排序。<br>过程感觉很像二叉树的遍历。<br>以下是归并排序模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;                                     <span class="comment">// test data amount range</span></span><br><span class="line"><span class="keyword">int</span> q[N];                                                   <span class="comment">// original array</span></span><br><span class="line"><span class="keyword">int</span> tmp[N];                                                 <span class="comment">// temporary array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;                                   <span class="comment">// end of recursion</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;                               </span><br><span class="line">    merge_sort(q, lo, mid), merge_sort(q, mid + <span class="number">1</span>, hi);     <span class="comment">// recursively divides into two</span></span><br><span class="line">    <span class="comment">// backtrack progress</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;                                 </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;                                              <span class="comment">// index of temporary array            </span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid &amp;&amp; j &lt;= hi;)                             <span class="comment">// puts smaller one into tmp[]</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[t++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[t++] = q[j++]; </span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid;) tmp[t++] = q[i++];                     <span class="comment">// puts remaining array into tmp[]</span></span><br><span class="line">    <span class="keyword">for</span> (;j &lt;= hi;) tmp[t++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi;) q[i++] = tmp[j++];    <span class="comment">// overrides original array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为一分为二的过程一共持续 <strong><em>log(N)</em></strong> 次（以2为底）,把数放入 <code>tmp[]</code> 再覆盖原数组需要 <strong><em>O(N)</em></strong>。<br>故时间复杂度为 <strong><em>ONlog(N)</em></strong> </p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="整数二分查找"><a href="#整数二分查找" class="headerlink" title="整数二分查找"></a>整数二分查找</h3><p>一般涉及到单调性的问题，查找某个边界，可以使用二分查找。但是二分查找不仅仅只适用于单调性问题。<br>即：<br>单调性问题查找一定可以用二分，非单调性问题也有可能可以用二分。<br>二分查找的本质目的是：<br><strong>在一个整数区间上，前一段满足某种性质A，后一段满足另一性质B。使用二分查找找到满足性质A的边界点edgeA或者满足性质B的边界点edgeB。</strong><br><code>____________Satisfied A______________| |___________Satisfied B________________</code><br>整个查找过程围绕“性质”展开：<br><strong>找A的边界，看mid是否满足B</strong><br>满足即从AreaB向AreaA处搜索，不断缩小mid和边界A的距离，直到最终找到；<br>不满足即从AreaA向AreaB处搜索，不断缩小mid和边界A距离，直到最终找到。<br><strong>找B的边界，看mid是否满足A</strong><br>满足即从AreaA向AreaB处搜索，不断缩小mid和边界B的距离，直到最终找到；<br>不满足即从AreaB向AreaA处搜索，不断缩小mid和边界B的距离，直到最终找到。</p>
<p>整数二分查找模板：<br><strong>查找B边界</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finds edge B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;lo &lt; hi;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;                   <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (is_satisfied_A(mid)) lo = mid;</span><br><span class="line">        <span class="keyword">else</span> hi =  mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找A边界</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finds edge A</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;lo &lt; hi;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;                      <span class="comment">//  2</span></span><br><span class="line">        <span class="keyword">if</span> (is_satisfied_B(mid)) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：1处为了防止边界问题，需要在计算mid的时候加一。</strong></p>
<h3 id="浮点数二分查找"><a href="#浮点数二分查找" class="headerlink" title="浮点数二分查找"></a>浮点数二分查找</h3><h4 id="根据精度迭代"><a href="#根据精度迭代" class="headerlink" title="根据精度迭代"></a>根据精度迭代</h4><p>因为是找浮点数，所以可以不用考虑边界问题。<br><strong>例子：</strong><br>求数字x的开方。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">0</span>, hi = <span class="built_in">max</span>(<span class="number">1</span>, x);                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (;hi - lo &gt; <span class="number">1e-8</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, lo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意1处当<code>x&lt;1</code>时，右边界是1。因为小于1的数，开方比自己大。<code>x&gt;1</code>时，右边界当然可以取到<code>x</code>。<br>题目中一般会给出<code>x</code>的取值范围，如 <code>-10000 &lt; x &lt; 10000</code>，那么<code>lo</code>和<code>hi</code>可以分别初始化为<code>-10000</code>和<code>10000</code>。<br>根据经验，如果题目要求保留<code>n</code>位有效数字，那么一般<code>lo</code>和<code>hi</code>之间判定的精度为<code>1e-(n + 2)</code>。</p>
<h4 id="根据循环次数迭代"><a href="#根据循环次数迭代" class="headerlink" title="根据循环次数迭代"></a>根据循环次数迭代</h4><p>这是浮点数二分的另一种写法，直接循环个<code>100</code>次。<br>如上题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">0</span>, hi = <span class="built_in">max</span>(<span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, lo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这相当于把lo到hi范围缩小2的100次方倍。（100次2分）<br>因为2的100次幂足够大，所以结果是正确的。</p>
<h2 id="高精度四则运算"><a href="#高精度四则运算" class="headerlink" title="高精度四则运算"></a>高精度四则运算</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>两个 <strong>超长位数正整数</strong> 相加，一般是以 <strong>字符串</strong> 形式读取整数，再把整数放入 <strong>数组</strong> 中，进行模拟加法运算。<br><strong>模板1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span>                             <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)                      <span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);                                                  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<blockquote>
<ol>
<li>以数组引用传入参数，可以避免没必要的数组拷贝。</li>
<li><code>A</code>或<code>B</code>至少有一个没有遍历完，都需要继续计算。</li>
<li>注意结束之后进位有可能非0.</li>
</ol>
</blockquote>
<p>该模板可以改写成总是模拟以一个更长的数组加长度较小的数组：<br><strong>模板2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，就可以只考虑遍历较长数组，只进行一次长度判断。</p>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>两个超长正整数相减。因为结果可能为负数，负数的时候输出需要在最前面补<code>&#39;-&#39;</code>。<br><code>A B</code>相减最核心的部分，<code>A</code>总是大于等于<code>B</code>的，这样可以只遍历<code>A</code>，对对应的<code>B</code>有无数字进行判断。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C = A - B， A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return if A &gt;= B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A - B while A &gt;= B</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="comment">// consider if should sub slot of B</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        <span class="comment">// t might be a negative</span></span><br><span class="line">        <span class="comment">// t will be the right slot whatever its negative or positive</span></span><br><span class="line">        <span class="comment">// t + 10 means it will borrow 10 from next slot</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);                                          <span class="comment">//1</span></span><br><span class="line">        <span class="comment">// update t</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;                    </span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there might be some '0' in back of C</span></span><br><span class="line">    <span class="comment">// dont't have to remove while C.size() == 1</span></span><br><span class="line">    <span class="keyword">for</span> (; C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>; ) C.pop_back();                    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B, C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B)) C = sub(A, B);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>此处<code>t</code>有可能被减成了负数（最低可以取到-10，最高可取到9），此时向后一位借10，于是最低取到0；同时由于借10的时候并没有判断正负，所以+10可能会导致结果高于10。也就是说，此时运算过程放入<code>C</code>中的数可能的取值范围是：<code>(0, 19)</code>。这样我对10取模，即可得到正确的放入<code>C</code>中的数了。<br>注意，在把“优化”后的（指借位模10）运算结果放入<code>C</code>时，并没有把结果赋值给<code>t</code>，因为后面需要判断<code>t</code>的正负，以更新下一轮的<code>t</code>取值。如果赋值了，则<code>t</code>必然为正，无法更新进位信息。</li>
<li>注意当A与B前几位部分相等时，C后面会存在’0’，如<code>123 - 120</code>结果类似<code>003</code>。但在结果仅为1位时，不用考虑。</li>
</ol>
</blockquote>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><p>一个超长正整数乘一个普通int正整数。模拟相乘过程把普通int整数看成一个整体。<br><strong>模板1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )                       <span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);                                        <span class="comment">//2</span></span><br><span class="line">        t /= <span class="number">10</span>;                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意1处条件，当A没有遍历完的时候，需要一直和b相乘，更新进位t。当乘完的时候，依然进入处理进位t，只不过此时不需要和b相乘，而是直接模10获得最高位数。</li>
<li>放入slot中的数一直都是对10取模。</li>
</ol>
</blockquote>
<p>当然也可以在遍历完A后再处理最终进位问题，即：<br><strong>模板2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] * b + t;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">for</span> (;C.<span class="built_in">size</span>() &gt;  &amp;&amp; C.back() == <span class="number">0</span>;) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在处理最终进位<code>t</code>的时候，模板1是对<code>t</code>再进入循环处理，这时候如果<code>t &lt; 10</code>的话，只循环一次，但是如果<code>t &gt;= 10</code>的话，需要反复进入循环，依次取模，除10.</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>算法模板</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>使用youtube-dl下载YouTube频道所有视频</title>
    <url>/2020/10/19/%E4%BD%BF%E7%94%A8youtube-dl%E4%B8%8B%E8%BD%BDYouTube%E9%A2%91%E9%81%93%E6%89%80%E6%9C%89%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p><code>youtube-dl -f &quot;bestvideo[width&gt;=&lt;resolution width such as: 3840&gt;]+bestaudio/best&quot; -ciw -o &quot;%(title)s.%(ext)s&quot; -v &lt;channel url like: xxx/channel/xxx&gt; --download-archive downloaded.txt</code></p>
<blockquote>
<p>-f, –format FORMAT<br>    video format code. with adding <code>bestvideo[width&gt;=3840]+bestaudio/best</code> youtube-dl will pick the quality &gt;= 4K</p>
</blockquote>
<blockquote>
<p>-c, –continue<br>    force resume of partially downloaded files</p>
</blockquote>
<blockquote>
<p>-i, –ignore-errors<br>    continue on download errors, for example to skip unavailable videos in a channel </p>
</blockquote>
<blockquote>
<p>-w, –no-overwrites<br>    do not overwrite files</p>
</blockquote>
<blockquote>
<p>-o, –output<br>    Output filename template, this example functions similarly to the old –title option</p>
</blockquote>
<blockquote>
<p>-v, –verbose<br>    print various debugging information</p>
</blockquote>
<blockquote>
<p>with –download-archive download.txt flag you gonna archive all videos’ info so that you can ezlly resume download.<br>-f </p>
</blockquote>
<p><em>reference:</em></p>
<blockquote>
<p><a href="https://askubuntu.com/questions/856911/using-youtube-dl-to-download-entire-youtube-channel" target="_blank" rel="noopener">https://askubuntu.com/questions/856911/using-youtube-dl-to-download-entire-youtube-channel</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>YouTube</tag>
        <tag>youtube-dl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字符串及其指针类型定义</title>
    <url>/2020/10/01/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Meaning in MBCS builds</th>
<th align="center">Meaning in Unicode builds</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WCHAR</td>
<td align="center">wchar_t</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">LPSTR</td>
<td align="center">char*</td>
<td align="center">char*</td>
</tr>
<tr>
<td align="center">LPCSTR</td>
<td align="center">const char*</td>
<td align="center">const char*</td>
</tr>
<tr>
<td align="center">LPWSTR</td>
<td align="center">wchar_t*</td>
<td align="center">wchar_t*</td>
</tr>
<tr>
<td align="center">LPCWSTR</td>
<td align="center">wchar_t*</td>
<td align="center">wchar_t*</td>
</tr>
<tr>
<td align="center">TCHAR</td>
<td align="center">TCHAR char</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">LPTSTR</td>
<td align="center">TCHAR*</td>
<td align="center">TCHAR*</td>
</tr>
<tr>
<td align="center">LPCTSTR</td>
<td align="center">const TCHAR*</td>
<td align="center">const TCHAR*</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectNowCoder学习笔记</title>
    <url>/2020/09/04/ProjectNowCoder%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="2-1-Spring入门和模板语法"><a href="#2-1-Spring入门和模板语法" class="headerlink" title="2.1 Spring入门和模板语法"></a>2.1 Spring入门和模板语法</h2><h3 id="向模板传递参数"><a href="#向模板传递参数" class="headerlink" title="向模板传递参数"></a>向模板传递参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> plus.fingerdance.projectx.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/profile/&#123;group1d&#125;/&#123;userId&#125;"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span>         <span class="comment">//路径参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">profile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> <span class="keyword">int</span> userId,</span></span><br><span class="line"><span class="function">                          @<span class="title">PathVariable</span><span class="params">(<span class="string">"group1d"</span>)</span> String groupId,</span></span><br><span class="line"><span class="function">                          <span class="comment">//请求参数</span></span></span><br><span class="line"><span class="function">                          <span class="comment">// defaultValue是key的默认值，在url未指定该值时使用它。required标明是否需要key，默认为是，如果在默认状态下</span></span></span><br><span class="line"><span class="function">                          <span class="comment">// url未指定key，则报错，如果设置成 false，则如果url未指定key，则key值会被指定为null</span></span></span><br><span class="line"><span class="function">                          @<span class="title">RequestParam</span><span class="params">(<span class="string">"type"</span>)</span> <span class="keyword">int</span> type,</span></span><br><span class="line"><span class="function">                          @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"key"</span>, defaultValue = <span class="string">"zz"</span>, required = <span class="keyword">false</span>)</span> String key)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Profile Page of %d who belong to %s;"</span> +</span><br><span class="line">                <span class="string">"Type: %d Key: %s"</span>, userId, groupId, type, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以welcome.html模板的方式返回</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/welcome"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"value1"</span>, <span class="string">"Wow!"</span>);</span><br><span class="line">        List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"colors"</span>, colors); <span class="comment">//不加toString会报错：意思就是期待一个String类型啥的，而你给的是一个sequence bla bla</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"welcome"</span>; <span class="comment">//welcome.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 559 N叉树的最大深度（Maximum Depth of N-ary Tree）</title>
    <url>/2020/08/31/LeetCode-559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88Maximum-Depth-of-N-ary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>例如，给定一个 <code>3叉树</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">   &#x2F;   |   \</span><br><span class="line">  3    2    4</span><br><span class="line"> &#x2F; \   </span><br><span class="line">5   6</span><br></pre></td></tr></table></figure>
<p>我们应返回其最大深度，3。<br>说明:</p>
<blockquote>
<p>1.树的深度不会超过 1000。<br>2.树的节点总不会超过 5000。</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>没啥可说的，和「LeetCode-104-二叉树的最大深度（Maximum-Depth-of-Binary-Tree）」对比，无非就是取最大值的不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.children.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; heights = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Node item : root.children) &#123;</span><br><span class="line">        heights.add(maxDepth(item)); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Collections.max(heights) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，亦可维护一个「最大值变量」，children的每个元素，和它作比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本方法参考HJF的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            result = Math.max(result, <span class="number">1</span> + maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>可以由DFS递归改成迭代，同时维护一个最大值变量，每次出队需要将节点的深度信息和最大值变量作比较。所以节点需要携带深度信息。可以借助<code>pair</code>，也可以写一个新的节点类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本方法参考官方题解</span></span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&lt;Node, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;Node, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      <span class="keyword">int</span> current_depth = current.getValue();</span><br><span class="line">      <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        <span class="keyword">for</span> (Node c : root.children) &#123;</span><br><span class="line">          stack.add(<span class="keyword">new</span> Pair(c, current_depth + <span class="number">1</span>));    </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题亦可使用BFS，但是我不想写了。</p>
<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/</a><br><strong>官方题解：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-zui-da-shen-du-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-zui-da-shen-du-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树深度</tag>
        <tag>树</tag>
        <tag>N叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>爱的魔力转圈圈：仿shell风火轮进度条实现</title>
    <url>/2020/08/22/%E7%88%B1%E7%9A%84%E9%AD%94%E5%8A%9B%E8%BD%AC%E5%9C%88%E5%9C%88%EF%BC%9A%E4%BB%BFshell%E9%A3%8E%E7%81%AB%E8%BD%AE%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>今天在shell上安装Anaconda的时候，发现安装过程中的「风火轮」进度条很有趣，于是就简单实现了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">icon = [<span class="string">'\\'</span>, <span class="string">'-'</span>, <span class="string">'/'</span>]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">    print(<span class="string">'\rAll work and no play make Jack a dull boy: &#123;&#125;'</span>.format(icon[m % <span class="number">3</span>]), end=<span class="string">''</span>)</span><br><span class="line">    time.sleep(<span class="number">0.25</span>)  <span class="comment"># -- control the r.p.m</span></span><br></pre></td></tr></table></figure>
<p>无非就是把<code>print</code>函数的<code>end=&#39;\n&#39;</code>换成<code>end=&#39;&#39;</code>以便每次打印光标可以回到行首。再就是循环<code>icon</code>列表，制造「动画效果」。<br>比如你要倒计时10s，每0.25s输出一帧，那么就要输出40帧。每一帧依次选取列表的下标可以用m对列表长度取余。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>进度条</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102 二叉树的层序遍历（Binary Tree Level Order Traversal）</title>
    <url>/2020/08/21/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Binary-Tree-Level-Order-Traversal%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 111 二叉树的最小深度（Minimum Depth of Binary Tree）</title>
    <url>/2020/08/21/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%EF%BC%88Minimum-Depth-of-Binary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>本题考查树深度，考虑到树结构的递归特性，可以很容易利用递归去计算。</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>当<code>root</code>节点左右孩子都非空时，二叉树深度最小当且仅当<code>root</code>的左右孩子节点深度取最小。另外，<code>root</code>为空或者<code>root</code>的左或右孩子节点为空的情况可以很容易判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(node.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(node.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dfs(node.left), dfs(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们亦可维护一个「最小值变量」，通过不断和其比较最终得出最小深度。该方法参考官方题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>; <span class="comment">//+1为root节点自身深度。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜素"><a href="#广度优先搜素" class="headerlink" title="广度优先搜素"></a>广度优先搜素</h3><p>可以使用「逐层遍历」方法找到树最小深度。树具有最小深度当且仅当某一层的某节点无左右孩子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>) &#123;  <span class="comment">//size &gt; 0保证一行可以被完全访问</span></span><br><span class="line">                TreeNode cur_node = queue.poll();</span><br><span class="line">                size--;</span><br><span class="line">                TreeNode left = cur_node.left;</span><br><span class="line">                TreeNode right = cur_node.right;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//while size == 0, column over</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>亦可自定义包含深度信息的节点类，此方法参考官方题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueueNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueueNode</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;QueueNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;QueueNode&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> QueueNode(root, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            QueueNode nodeDepth = queue.poll();</span><br><span class="line">            TreeNode node = nodeDepth.node;</span><br><span class="line">            <span class="keyword">int</span> depth = nodeDepth.depth;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a><br><strong>官方题解：</strong> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>树结构</tag>
        <tag>树深度</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104 二叉树的最大深度（Maximum Depth of Binary Tree）</title>
    <url>/2020/08/21/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88Maximum-Depth-of-Binary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>注意和「LeetCode-111-二叉树的最小深度（Minimum-Depth-of-Binary-Tree）」比较学习。</p>
<h3 id="递归（DFS）"><a href="#递归（DFS）" class="headerlink" title="递归（DFS）"></a>递归（DFS）</h3><p>和最小深度不同，当节点仅有左孩子或右孩子，可以直接比较取二者最大值。代码更简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>逐层遍历，每层遍历完之后，深度加一，当整个树遍历完，返回深度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>树深度</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 110 平衡二叉树（Balanced Binary Tree）</title>
    <url>/2020/08/18/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Balanced-Binary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<pre><code>一个二叉树 _每个节点_ 的左右两个子树的高度差的绝对值不超过1。</code></pre><p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 <code>true</code> 。<br><strong>示例 2:</strong><br>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 <code>false</code> 。</p>
<hr>
<p>本题绕不开树的高度计算，用到了递归思想（DFS）。从<code>root</code>节点开始向下依次计算每个节点高度，高度为左右孩子节点的高度较大的那个加一，当节点为<code>null</code>时，认为高度为零。<br>Binary TreeNode Definition:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>从<code>root</code>节点开始，比较左右孩子高度差，接着递归比较左右孩子的左右孩子。当出现不平衡条件返回<code>false</code>，一旦某一个子节点出现<code>false</code>，则整个结果是<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(p.left), height(p.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到在计算高度时仍然需要递归，所以这种方法会造成重复遍历。</p>
<h3 id="解法二：自底向上（后序遍历）"><a href="#解法二：自底向上（后序遍历）" class="headerlink" title="解法二：自底向上（后序遍历）"></a>解法二：自底向上（后序遍历）</h3><p>在计算高度的同时可以对平衡性进行判断。一旦出现不平衡情况，直接逐层返回一个特殊值。<br>这是我的原始代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height(root) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个<code>return -1</code>的情况可以合并：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span> || height_right == -<span class="number">1</span> || Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以不用以返回特殊值<code>-1</code>的方式判断不平衡状态，而是定义一个全局变量<code>res</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>树的高度</tag>
        <tag>二叉树遍历</tag>
        <tag>先序遍历</tag>
        <tag>后序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶技术学习心得</title>
    <url>/2020/08/17/%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/repo/2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><blockquote>
<p>项目开始前准备：<br>系好安全带，放下手刹，踩下刹车，启动引擎，踩下离合器。</p>
</blockquote>
<hr>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E5%80%92%E8%BD%A6%E5%85%A5%E5%BA%93.png" alt="pic0x0"><br><strong>左倒库：</strong> </p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向左打满。</li>
<li>step 2: 车身垂直于A线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过A线离合刹车踩满停下，准备左倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与A线重合，方向盘向左打满。</li>
<li>step 5: 此时注意左后视镜L1角，当L1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向右回一圈减小转角。</li>
<li>step 6: 此时注意观察右后视镜，观察当R2角出现时，方向盘迅速回正，此时注意到车身和R线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<p><strong>右倒库：</strong></p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向右打满。</li>
<li>step 2: 车身垂直于B线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过B线离合刹车踩满停下，准备右倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与B线重合，方向盘向右打满。</li>
<li>step 5: 此时注意观察右后视镜R1角，当R1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向左回一圈减小转角。</li>
<li>step 6: 此时注意左后视镜，观察当L2角出现时，方向盘迅速回正，此时注意到车身和L线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BE%A7%E6%96%B9%E5%81%9C%E8%BD%A6.png" alt="pic0x1"><br><strong>将车开出车库至准备区域：</strong></p>
<ul>
<li>step 1: 挂1挡，踩离合，打左转向灯，方向盘向左打满。</li>
<li>step 2：注意观察左后视镜，当B角出现时，回正方向盘。</li>
<li>step 3：让车辆继续缓缓行驶，注意观察左后视镜，当左前门门把手与车库虚线重合时，方向盘向右打满。</li>
<li>step 4：观察右后视镜，当车右侧与虚线平行时，车身已正，方向盘回正。</li>
<li>step 5：观察右后视镜，当A角出现时，停车。</li>
</ul>
<p><strong>右侧方停车：</strong></p>
<ul>
<li>step 1：挂倒挡，观察右后视镜，当A直角消失，方向盘又打满。</li>
<li>step 2：注意观察左后视镜，当B直角出现，方向盘回正。</li>
<li>step 3：注意观察左后视镜，当左后轮即将碰到车库虚线时，方向盘左打满。</li>
<li>step 4：注意观察右后视镜，当车右侧与车库边线平行时，车身已正。停车。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾驶技术</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶技术学习心得</title>
    <url>/2020/08/17/%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><blockquote>
<p>项目开始前准备：<br>系好安全带，放下手刹，踩下刹车，启动引擎，踩下离合器。</p>
</blockquote>
<hr>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E5%80%92%E8%BD%A6%E5%85%A5%E5%BA%93.png" alt="pic0x0"><br><strong>左倒库：</strong> </p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向左打满。</li>
<li>step 2: 车身垂直于A线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过A线离合刹车踩满停下，准备左倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与A线重合，方向盘向左打满。</li>
<li>step 5: 此时注意左后视镜L1角，当L1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向右回一圈减小转角。</li>
<li>step 6: 此时注意观察右后视镜，观察当R2角出现时，方向盘迅速回正，此时注意到车身和R线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<p><strong>右倒库：</strong></p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向右打满。</li>
<li>step 2: 车身垂直于B线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过B线离合刹车踩满停下，准备右倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与B线重合，方向盘向右打满。</li>
<li>step 5: 此时注意观察右后视镜R1角，当R1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向左回一圈减小转角。</li>
<li>step 6: 此时注意左后视镜，观察当L2角出现时，方向盘迅速回正，此时注意到车身和L线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BE%A7%E6%96%B9%E5%81%9C%E8%BD%A6.png" alt="pic0x1"><br><strong>将车开出车库至准备区域：</strong></p>
<ul>
<li>step 1: 挂1挡，踩离合，打左转向灯，方向盘向左打满。</li>
<li>step 2：注意观察左后视镜，当B角出现时，回正方向盘。</li>
<li>step 3：让车辆继续缓缓行驶，注意观察左后视镜，当左前门门把手与车库虚线重合时，方向盘向右打满。</li>
<li>step 4：观察右后视镜，当车右侧与虚线平行时，车身已正，方向盘回正。</li>
<li>step 5：观察右后视镜，当A角出现时，停车。</li>
</ul>
<p><strong>右侧方停车：</strong></p>
<ul>
<li>step 1：挂倒挡，观察右后视镜，当A直角消失，方向盘又打满。</li>
<li>step 2：注意观察左后视镜，当B直角出现，方向盘回正。</li>
<li>step 3：注意观察左后视镜，当左后轮即将碰到车库虚线时，方向盘左打满。</li>
<li>step 4：注意观察右后视镜，当车右侧与车库边线平行时，车身已正。停车。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾驶技术</tag>
      </tags>
  </entry>
  <entry>
    <title>沟通的艺术</title>
    <url>/2020/08/01/%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="沟通的基本功"><a href="#沟通的基本功" class="headerlink" title="沟通的基本功"></a>沟通的基本功</h3><blockquote>
<ul>
<li>聪明的脑子和活跃的思维<blockquote>
<p>十八核大脑不是盖的，你能透彻地理解对方说的意思，甚至包括言外之意；你能清晰地明白对方语句间的逻辑关系，哪怕他的逻辑存在漏洞你也能够指出；你能设身处地地理解周围所有人的感受，无缝切换各个角色轻松地实现换位思考；你能一定程度上预判对面将要说的话，从而为将来的谈话提前做好准备；</p>
</blockquote>
</li>
<li>敏锐的洞察力（察言观色）</li>
<li></li>
</ul>
</blockquote>
<h3 id="话题穿插切换"><a href="#话题穿插切换" class="headerlink" title="话题穿插切换"></a>话题穿插切换</h3><p>如果对方对和你要聊的话题并无兴趣的话，这时就需要切换话题，把话题转移到另一个方向去。<br><strong>常见话题切换语句</strong></p>
<blockquote>
<ul>
<li>你知道么，其实。。。<blockquote>
<p>举例：你知道么，今天你跟平常不太一样。。。</p>
</blockquote>
</li>
<li>我觉得。。。</li>
<li>对了。。。</li>
</ul>
</blockquote>
<h3 id="1个核心思维模式：「把对方当主角」"><a href="#1个核心思维模式：「把对方当主角」" class="headerlink" title="1个核心思维模式：「把对方当主角」"></a>1个核心思维模式：「把对方当主角」</h3><p>把对方当成聊天的主角，每一步聊天，都围绕着对方，使其感受到「主角」般的爽感，谁都是希望自己被重视，被宠着的。<br>现在，请你在心里默念三遍：<br><strong>TA才是聊天的主角，我要宠着惯着！</strong><br><strong>TA才是聊天的主角，我要宠着惯着！</strong><br><strong>TA才是聊天的主角，我要宠着惯着！</strong></p>
<h3 id="打招呼"><a href="#打招呼" class="headerlink" title="打招呼"></a>打招呼</h3><blockquote>
<p>当然首先还是吸引对方的注意，不然的话，你跟对方打招呼结果他没注意到，那就尴尬了哈哈。<br>其次呢，神情自然大方地去释放你阳光的情绪吧。<br>微笑是最能感染人的，但是别皮笑肉不笑那种。用你的眼神去“微笑”，一个温柔的眼神胜过千言万语。眼睛一定要看着对方哦，瞳孔适当放大。<br>打招呼也有intro和outro的，outro可以用关怀的态度，还是把对方当主角宠。比如：注意安全喔、玩的开心喔，等等，当然，最简单的还是拜拜。</p>
</blockquote>
<h3 id="怎样说话让对面很容易接下去"><a href="#怎样说话让对面很容易接下去" class="headerlink" title="怎样说话让对面很容易接下去"></a>怎样说话让对面很容易接下去</h3><p><strong>在对方给的回答上做文章，谈谈自己的感受，并抛出一个或多个话题。</strong><br>其实如果你是个接话高手，那么只需要在接住话之后稍加 <strong>感受</strong>，再次将话题回到对方身上即可。</p>
<h3 id="沟通前的准备"><a href="#沟通前的准备" class="headerlink" title="沟通前的准备"></a>沟通前的准备</h3><blockquote>
<p><strong>step 1:</strong> 观察。我认为，沟通之前应该迅速判断对面有没有和你沟通的意愿。所以沟通前第一件事，就是用眼观察对方。这一步需要在一瞬间内完成。<br><strong>step 2:</strong> 观察。对的，第二步还是观察，只不过这一步观察对方的状态，根据这一状态可以自然而然开启沟通。<br><strong>step 3:</strong> 营造氛围。这一步开始营造聊天氛围。和人聊天，过了很久之后，具体说些啥，对方可能不会再记起，但是你们聊天的氛围、双方的感受是很难忘却的，特别是当这是一种特别舒服或者特别尴尬的时候。两人见面，不管是两者关系如何，这都不重要，重要的是你对氛围的把控。即便是双方不熟，只要把握好聊天氛围，一样可以有话聊。<br>聊天氛围客观描述：</p>
<blockquote>
<ul>
<li>你自己在即将展开的聊天中扮演什么样的角色，塑造什么样的形象。<br>例1：<strong>自己处于弱势时，可以塑造大方乐观的形象。</strong> 今天和对方在家乐福门口见面，我俩都是从健身房出来，他带了伞，我没带伞，外面下着雨。他有伞我没有，自己处于弱势地位（这里的地位强弱不是说要去竞争什么），这时候你可以营造出一种自己乐观大度的形象：这些雨不算什么，我等会儿再走即可。这样聊天的基调就有了，你对将要发生的谈话已经有了一个非常十足的把握。和谐的氛围油然而生。具体说些啥，这些都不是很重要了。无非就是先寒暄，再顺着你准备的氛围说下去。<br>例2：<strong>塑造赞美者的形象</strong> 今天遇到同事或者同学或者一起健身的朋友，你发现对面穿了一件骚气的衣服，你可以把自己塑造成一个赞美者的形象，其实赞美是一门很深的学问，力度不够，会让人觉得肤浅做作；力度太大会变成讥笑，中国人是最敏感的；力度更大，就成了马屁精，或者舔狗。夸细节啊真诚啊啥的，这些都是最基本的东西，所有人都知道。<br>夸得别人舒服，营造马屁味道，这是需要长期磨炼反思的。人情练达即文章，我现在也不是很在行，以后慢慢补充。<br>例3：____</li>
<li></li>
<li><strong>step 4:</strong> 寒暄。此时开始聊天，在正式聊天前，会有一个intro，这是从不说话到正式聊天之间的一个平稳的过度，让对面做好准备，意思是说，我们要开始聊天了，双方都准备一下。<br>寒暄嘛，都是些无关痛痒的废话。它是根据两人 <strong>关系</strong> 来的。<br>中国人寒暄的时候，关系一般或者不熟可以问对方刚发生的事情。你可以问对方吃了吗？刚健完身啊？刚放学啊？刚下班啊？等等<del>我们一般寒暄的时候会根据对方的状态问一下刚发生的事情，这些事情必须是无关痛痒的。但你不要哪壶不开提哪壶，揭人伤疤啥的。一般也不要问对方将要去做什么，因为有些人很在意这些，你问他要去做啥，他可能不想告诉你，会认为你居心叵测，打探隐私。<br>例1： 噫</del>你也从这边走 or 噫<del>好巧啊，在这遇到你 or 噫</del>你也刚下来么 or 噫~很少在这碰到你等等。<br>关系是熟人或者很好，这个时候你再像上面这样寒暄就会拉开距离，千万注意。这时候，你就单刀直入，可以从 <strong>关怀</strong> 的角度入手。不管关系好坏，关怀可以通吃。<br>例2：</li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>人际关系</tag>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>fix Intellj IDEA git pust rejected</title>
    <url>/2020/07/25/fix-Intellj-IDEA-git-pust-rejected/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>git</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>曾仕强「圆通的人际关系」节目笔记</title>
    <url>/2020/06/30/%E6%9B%BE%E4%BB%95%E5%BC%BA%E3%80%8C%E5%9C%86%E9%80%9A%E7%9A%84%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E3%80%8D%E8%8A%82%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一集"><a href="#第一集" class="headerlink" title="第一集"></a>第一集</h3><ul>
<li><p>很多人用西方的标准去看中国的一切，所以在他看来中国人士乱七八糟的。更有趣的是，自五四运动以来，他们用中国的缺点和西方的优点去比，那当然中国人更糟糕。全世界它要比较的话，应该以一个较持平的标准。</p>
</li>
<li><p>西方和中国的人际关系是截然不同的。西方人与人是平等的，中国是不平等的。在中国，人人平等那就叫没大没小。</p>
</li>
<li><p>现在很多人看书，是越看越困惑越看越倒霉。是因为他们看的都是西方的书，西方的技术是可以学的，因为科学无国界。可是跟文化有关的书，你就要十分小心，一不注意就会掉到坑里去。</p>
</li>
<li><p>西方社会是「神本位」，而中国是「人本位」。西方人认为神是一切的主宰，解释一切都离不开神。而伏羲氏认为天底下最了不起的不是神，而是人。你为什么一定要把一个神弄在你上面当你的主宰呢？</p>
</li>
<li><p>中国是没有宗教的，你看所有宗教他都是外来的。中国人崇拜祖宗，叫做「祖宗崇拜」。很多人说不对呀，你看很多人在拜。你要小心了，那不是「拜神」，那是「理神」。</p>
</li>
<li><p>「神本位」必然走向个人主义（人都是上帝的子民，所以人是个人的、平等的）。西方人经常讲，这是我个人意见blabla。在中国我劝你不要这样讲，你一这样讲，人家就开始不听了。你算老几，你有什么意见？西方人说我个人意见表示我负责，在中国你说你负责你就更惨了，人家就怀疑，你能负什么责？——讲太多西方的话，吃亏的是你自己。</p>
</li>
<li><p>中国人认为人生而不平等。人生下来之前是平等的，人死了之后也是平等的，只要你活着你就不平等。中国人接受 <strong>合理的不平等</strong> ，不接受 <strong>过分的不平等</strong> ，<strong>完全的平等</strong> 我们是完全不相信的。 </p>
</li>
<li><p>中国人认为人与人之间相当地不平等，那才叫 <strong>伦理</strong> 。他是你爸爸，就永远是你爸爸，你永远讲不过他。他是你的领导就永远是你的领导，你就是讲不过他。然后你骗自己说我跟他是平等的，何必呢？</p>
</li>
<li><p>西方有人际关系，而中国有人伦关系，我们本没有人际关系，现在说人际关系其实是很勉强。中国人认为人际关系加上伦理就成了人伦关系。你看两个人在谈话，只要有第三个人插进来，我们马上就会调整，中国人的警觉性很高，还要装得没调整一样。全世界找不到像我们这样的人。</p>
</li>
<li><p>中国人都是双重标准。别人遇到什么事，他都会说，怕什么？不用怕！轮到自己，哎呀我要小心一点。</p>
<blockquote>
<p>郭德纲说：劝人大度遭雷劈。我的理解其中的一方面就是对这种双重标准的反击：哼，你自己遇到事儿怎么不大度了？</p>
</blockquote>
</li>
<li><p>中国的法律、规定都是有弹性的，没有弹性就没办法执行。所以中国人遇到事情就会讲一大堆道理，然后大事化小小事化了，小到不知道怎么办才好。</p>
</li>
<li><p>西方人与人之间，它是好奇，但他不会去关心你。在中国人与人之间，它不好奇，没有什么好好奇的，我们是 <strong>关怀</strong> 。你看西方男人和女人他们互相好奇，很快就同居，发生关系。人与人之间如果不能关怀，那产生什么关系又怎么样呢？西方人见面，Hi, Hello, GoodMorning，很有礼貌但一点也不关心你。你看中国人见面，—— 噫，你嘴巴怎么破了？ —— 上火。 二话不说把药给你吃。西方人之间的这种好奇而不关心产生了人与人之间的 <strong>距离感</strong> 。</p>
</li>
<li><p>西方才讲利害。大到国与国之间，小到人与人之间，完全讲利害关系，没有什么道义可言。真正了解中国人说我们很 <strong>势利</strong> ，我们不讲利害。这件事搞不好就让他走，这就是利害。而中国人，这件事搞不好是搞不好，但他后面有背景，我得罪他，上面会找我。我不是喜欢他，我是看到他不敢动他。上面一旦完了，我第一个动他。这就是 <strong>势利</strong> 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>曾仕强</tag>
        <tag>哲学</tag>
        <tag>人际关系</tag>
      </tags>
  </entry>
  <entry>
    <title>圣经本土化翻译片段</title>
    <url>/2020/06/30/%E5%9C%A3%E7%BB%8F%E6%9C%AC%E5%9C%9F%E5%8C%96%E7%BF%BB%E8%AF%91%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<p>裆里搁裆，裆里搁裆，裆里搁 裆里搁 裆里搁裆… </p>
<p>闲言碎语不要讲，表一表大卫家的小木匠。 </p>
<p>木匠名叫约瑟夫，手巧人帅脾气好，忠厚之名传家乡。</p>
<p>媒婆纷纷来拜访，许了个妹子做新娘。</p>
<p>姑娘叫做玛利亚，温柔美丽人人夸，种田做饭样样强。</p>
<p>两人恩爱深似海，订婚一年却未圆房。</p>
<p>这一天，两人约会去逛街，玛利亚却穿上了防辐射的孕妇装。</p>
<p>约瑟夫见了心不爽：莫非我娘子不贤良，暗自让我把王八当？</p>
<p>玛利亚见状忙解释：“昨晚天使托梦道端详，说我清纯美丽无人及，贞洁贤良远名扬，上帝见了心欢喜，选我做了圣子的娘 ，此儿本是上帝的种，长大必做世人的王”。</p>
<p>未出一力喜当爹，约瑟夫闻言心花放。</p>
<p>十月怀胎匆匆过，一朝分娩苦难当。</p>
<p>马槽呱呱一声啼，天使降临显圣光。</p>
<p>木匠抱起了小宝贝儿，喜上眉梢眼放光：“耶，媳妇卧槽生了个孩儿，萌的为父心酥痒，赐你小名【处生】好养活，大名【 耶稣】亮堂堂，今晚吃饱你娘的奶，明天带你拜谒祖坟烧高香~”</p>
<p>这便是：天父恩泽齐浩荡，处女生子世无双，便宜当爹约瑟夫，万古流芳绿帽王。</p>
<blockquote>
<p>作者：张寒生<br>链接：<a href="https://www.zhihu.com/question/403728436/answer/1307927525" target="_blank" rel="noopener">https://www.zhihu.com/question/403728436/answer/1307927525</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>圣经</tag>
        <tag>段子</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/2020/06/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>淫字论事不论心，论心千古无完人。孝字论心不论事，论事千古无孝子。</p>
</li>
<li><p>肉体才是人的神殿，不管里面供奉的是什么，都应该好好保持它的强韧、美丽和清洁。  ——《1Q84》村上春树</p>
</li>
<li><p>真诚感谢四步法：</p>
<blockquote>
<p>说明行为：就是说清楚对方具体帮你做了什么事；<br>说清影响：说明他帮你的这件事，为你解决了什么问题；<br>分享感受：表达受到帮助后的真实感受；<br>投桃报李：表明对方有需要的话，你也愿意尽力帮忙。</p>
</blockquote>
</li>
<li><p>彭林教授（清华大学人文学院历史系）反对父亲节、母亲节等西方节日。因为中国人是有孝道的，一年四季没有哪一天不孝，君子有终身之孝。而西方人它是没有孝道的，所以他们要找出一天来表示一下。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #238 除自身以外数组的乘积（Product of Array Except Self）</title>
    <url>/2020/06/04/LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%88Product-of-Array-Except-Self%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的整数数组 <code>nums</code>，其中 n &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p>
</blockquote>
<p><strong>提示：</strong> 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong> 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<hr>
<h3 id="左右乘积数组"><a href="#左右乘积数组" class="headerlink" title="左右乘积数组"></a>左右乘积数组</h3><p>维护两个数组，分别存放<code>nums[i]</code>左右乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == len - <span class="number">1</span>) &#123;</span><br><span class="line">                right[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right[j] = right[j + <span class="number">1</span>] * nums[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">            output[k] = left[k] * right[k];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：<strong><em>O(N)</em></strong> 其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。预处理 <code>left</code> 和 <code>right</code> 数组以及最后的遍历计算都是 <strong><em>O(N)</em></strong> 的时间复杂度。</li>
<li>空间复杂度：<strong><em>O(N)</em></strong> 其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。使用了 <code>left</code> 和 <code>right</code> 数组去构造答案，<code>left</code> 和 <code>right</code> 数组的长度为数组 <code>nums</code> 的大小。</li>
</ul>
<h3 id="进一步优化-O-1-的空间复杂度"><a href="#进一步优化-O-1-的空间复杂度" class="headerlink" title="进一步优化 O(1) 的空间复杂度"></a>进一步优化 <strong><em>O(1)</em></strong> 的空间复杂度</h3><p>可以使用答案数组来替代 <code>left</code> 数组，从右向左遍历，动态更新 <code>nums[i]</code> 右侧乘积。<br>也可以使用答案数组来替代 <code>right</code> 数组，从左向右遍历，动态更新 <code>nums[i]</code> 左侧乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        output[len -<span class="number">1</span> ] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            output[i] = output[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) left = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = left * nums[j - <span class="number">1</span>];</span><br><span class="line">            output[j] = left * output[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：<strong><em>O(N)</em></strong>，其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。分析与方法一相同。</li>
<li>空间复杂度：<strong><em>O(1)</em></strong>，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</li>
</ul>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1431 拥有最多糖果的孩子（Kids With the Greatest Number of Candies）</title>
    <url>/2020/06/01/LeetCode-1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%88Kids-With-the-Greatest-Number-of-Candies%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>candies</code>和一个整数<code>extraCandies</code>，其中<code>candies[i]</code> 代表第 <code>i</code>个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<p><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [2,3,5,1,3], extraCandies = 3<br><strong>输出：</strong> [true,true,true,false,true]<br><strong>解释：</strong><br>孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。<br>孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。<br>孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。<br>孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。<br>孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [4,2,1,1,2], extraCandies = 1<br><strong>输出：</strong> [true,false,false,false,false]<br><strong>解释：</strong> 只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [12,1,12], extraCandies = 10<br><strong>输出：</strong> [true,false,true]</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= candies.length &lt;= 100</li>
<li>1 &lt;= candies[i] &lt;= 100</li>
<li>1 &lt;= extraCandies &lt;= 50</li>
</ul>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>没啥好说的，儿童节快乐！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = candies.length;</span><br><span class="line">        <span class="keyword">int</span> max = candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            max = Math.max(max, candies[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to Anaconda</title>
    <url>/2020/06/01/Welcome-to-Anaconda/</url>
    <content><![CDATA[<h3 id="为什么要用Anaconda"><a href="#为什么要用Anaconda" class="headerlink" title="为什么要用Anaconda"></a>为什么要用Anaconda</h3><p>Anaconda解决了官方Python的两大痛点。</p>
<ul>
<li>提供了包管理功能，Windows平台安装第三方包经常失败的场景得以解决。</li>
<li>提供环境管理的功能，功能类似Virtualenv，解决了多版本Python并存、切换的问题。</li>
</ul>
<h3 id="下载安装conda"><a href="#下载安装conda" class="headerlink" title="下载安装conda"></a>下载安装conda</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2019.07-Linux-x86_64.sh</span><br><span class="line">bash  Anaconda3-2019.07-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<h3 id="把conda加入PATH"><a href="#把conda加入PATH" class="headerlink" title="把conda加入PATH"></a>把conda加入PATH</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; conda init &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !! Contents within this block are managed by <span class="string">'conda init'</span> !!</span></span><br><span class="line">__conda_setup="$(CONDA_REPORT_ERRORS=false '/root/anaconda3/bin/conda' shell.bash hook 2&gt; /dev/null)"</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    \eval "$__conda_setup"</span><br><span class="line">else</span><br><span class="line">    if [ -f "/root/anaconda3/etc/profile.d/conda.sh" ]; then</span><br><span class="line">        . "/root/anaconda3/etc/profile.d/conda.sh"</span><br><span class="line">        CONDA_CHANGEPS1=false conda activate base</span><br><span class="line">    else</span><br><span class="line">        \export PATH="/root/anaconda3/bin:$PATH"</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;&lt; conda init &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>

<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/58033789" target="_blank" rel="noopener">https://www.zhihu.com/question/58033789</a></li>
<li><a href="https://www.bobobk.com/32.html" target="_blank" rel="noopener">https://www.bobobk.com/32.html</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #101 对称二叉树（Symmetric Tree）</title>
    <url>/2020/05/31/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Symmetric-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，检查它是否是镜像对称的。<br>例如，二叉树<code>[1,2,2,3,4,4,3]</code>是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong><br>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们可以将对整个二叉树是否对称的判断拆分成对若干节点对是否对称的判断。这是递归思想。<br>具体地，从root节点的左右孩子节点开始，进行一次判断。条件满足的话，再深入到node1的left与node2的right、node1的right与node2的left。依次递归下去。<br>注意回溯的情况，当node1和node2都为空时，即该节点对为对称的且为末端节点，<code>return true</code>。<br>不满足上面条件时，当node1和node2有一个为空或者<code>node1.val != node2.val</code>时，必然非对称，<code>return false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">     * 内存消耗 :37.9 MB, 在所有 Java 提交中击败了31.25%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//递归到头了，必须回溯。 不能在满足条件(node1 != null &amp;&amp; node2 != null &amp;&amp; node1.val == node2.val)时return true，因为此时需要继续向下递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//此时必然非对称</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> cmp(node1.left, node2.right) &amp;&amp; cmp(node1.right, node2.left); <span class="comment">//向下递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们可以引入一个队列，迭代判断所有节点对。<br>第一代poll root节点的左右孩子节点，判断节点状态。<br>往后每一代（如果有的话）保留了上一代判断条件得出的信息，poll出两个节点，再进行下一个判断。<br>一次又一次，迭代地进行判断。只要中间出现了一个不满足对称的情况：<br><code>node1 == null || node2 == null || node1.val != node2.val</code>，直接<code>return false</code>。<br>当所有节点入队出队迭代判断完毕均为出现非对称情况，那么可以认为二叉树是对称的。<br>注意到null节点的情况，队列应该使用LinkedList而非ArrayDeque——前者支持null元素，而后者不支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *执行用时 :1 ms, 在所有 Java 提交中击败了37.93%的用户</span></span><br><span class="line"><span class="comment">     *内存消耗 :39.8 MB, 在所有 Java 提交中击败了5.00%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = queue.poll();    </span><br><span class="line">            TreeNode node2 = queue.poll();  </span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">continue</span>; <span class="comment">//继续迭代判断</span></span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//必然非对称</span></span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//当所有节点入队出队结束，均未出现非对称情况，结果显然是对称的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode #200 岛屿数量（Number of Islands）</title>
    <url>/2020/04/21/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%88Number-of-Islands%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。<br><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>{<br>   {‘1’, ‘1’, ‘1’, ‘1’, ‘0’},<br>   {‘1’, ‘1’, ‘0’, ‘1’, ‘0’},<br>   {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>   {‘0’, ‘0’, ‘0’, ‘0’, ‘0’}<br>}<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>{<br>  {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>  {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>  {‘0’, ‘0’, ‘1’, ‘0’, ‘0’},<br>  {‘0’, ‘0’, ‘0’, ‘1’, ‘1’}<br>}<br><strong>解释：</strong> 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
</blockquote>
<hr>
<p>一看就是搜索题，已经遇到多次类似的。</p>
<h3 id="广度优先搜素"><a href="#广度优先搜素" class="headerlink" title="广度优先搜素"></a>广度优先搜素</h3>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>深度优先搜素</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Shell命令</title>
    <url>/2020/04/18/%E5%B8%B8%E7%94%A8Shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>查找当前目录及子目录特定文件（夹）并删除</strong><br><code>find . -name &quot;*.zip&quot; -type f -print -exec rm {} \;</code></p>
<ul>
<li><code>.</code>即从当前目录递归查找</li>
<li><code>-name &#39;*.zip&#39;</code>查找以<code>.zip</code>文件名结尾的对象</li>
<li><code>-type f</code>该对象为文件</li>
<li><code>-print</code>屏幕输出</li>
<li><code>-exec</code>查找之后执行</li>
<li><code>rm</code>删除<br>如果希望删除目录，可以<code>-type d</code>，其表示对象为目录。另外如果希望递归删除，可以<code>rm -r</code>。如果希望递归强制删除，可以<code>rm -rf</code>。</li>
</ul>
<p><strong>查找当前目录及子目录特定文件并移动到目标目录</strong><br><code>find . -name &quot;*.mp4&quot; -type f -print -exec mv -t /home/AriaGo/ {} +;</code></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows同一台计算机不同用户之间转移hexo运行环境</title>
    <url>/2020/04/15/Windows%E5%90%8C%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E8%BD%AC%E7%A7%BBhexo%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><strong>部署hexo的用户：A</strong><br><strong>新用户：B</strong></p>
<p>在Windows平台由A切换B之后，A配置的hexo没法直接使用。</p>
<p><strong>解决方法</strong></p>
<blockquote>
<ul>
<li>将<code>C:\Users\A\AppData\Roaming</code>下的<code>npm</code>目录拷贝到<code>C:\Users\B\AppData\Roaming</code>。<blockquote>
<p>这里是hexo的安装目录，在新用户下不用重新安装。</p>
</blockquote>
</li>
<li>将<code>C:\Users\A</code>下的<code>.ssh</code>目录拷贝到<code>C:\Users\B</code>。<blockquote>
<p>这里存放着用于连接Github的ssh公钥和私钥。</p>
</blockquote>
</li>
<li>将<code>C:\Users\A</code>下的<code>node_modules</code>目录拷贝到<code>C:\Users\B</code>。<blockquote>
<p>这里是安装node之后用来存放<code>npm</code>下载的各种包的地方，我们不用重新执行<code>npm install</code>，直接拷贝即可。</p>
</blockquote>
</li>
<li>将<code>C:\Users\B\AppData\Roaming\npm</code>添加到B的用户环境变量。<blockquote>
<p>这一步可以让我们在新用户B下直接执行<code>hexo</code>命令。</p>
</blockquote>
</li>
<li>将<code>T:\Git\root\Git\cmd</code>添加到B的用户环境变量。<blockquote>
<p>这样可以在B下执行<code>git</code>命令。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>同一台计算机不同不同用户之间转移hexo运行环境要比不同计算机之间更加方便。</p>
<h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br><a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35668237</a><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a><br><a href="https://m.html.cn/qa/node-js/12146.html" target="_blank" rel="noopener">https://m.html.cn/qa/node-js/12146.html</a><br><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/01/npm-install.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌云（GCP）给给未分配实例的外部IP地址分配实例</title>
    <url>/2020/04/13/%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>为了给未分配实例的外部IP地址分配实例，必须要保证新的实例与该IP地址在同一地区。<br><img src="2020-04-13-%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/0x0.png" alt="pic0x0"></p>
<p>直接在新的实例中选择保留的IP地址。<br><img src="2020-04-13-%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/0x1.png" alt="pic0x1"></p>
<p>这样当我们删除一个实例，但希望把保留的IP地址应用到新的实例时，就可以很方便地操作。</p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>谷歌云</tag>
        <tag>GCP</tag>
        <tag>GCE</tag>
        <tag>VM</tag>
        <tag>外部IP地址</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS测速</title>
    <url>/2020/04/13/VPS%E6%B5%8B%E9%80%9F/</url>
    <content><![CDATA[<blockquote>
<p> <strong>speedtest-cli</strong></p>
<blockquote>
<ul>
<li>下载speedtest-cli<br><code>wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</code></li>
<li>添加可执行权限<br><code>chmod +x speedtest-cli</code></li>
<li>以默认的Mbps为单位测速<br><code>./speedtest-cli</code></li>
<li>以MB为单位测速<br><code>./speedtest-cli --byte</code></li>
<li>查看可用测速服务器<br><code>./speedtest-cli --list</code></li>
<li>选择指定服务器测速<br><code>./speedtest-cli --server NumberOfServer</code></li>
<li>获取帮助<br><code>./speedtest-cli --help</code></li>
</ul>
</blockquote>
<p> <strong>superspeed</strong></p>
<blockquote>
<ul>
<li>下载superspeed<br>. <code>wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh</code></li>
<li>添加可执行权限<br><code>chmod +x superspeed.sh</code></li>
<li>测速<br><code>./superspeed.sh</code></li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>Linux</tag>
        <tag>测速</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用Screen命令</title>
    <url>/2020/04/13/Linux%E5%B8%B8%E7%94%A8Screen%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在使用过程中可以退出screen，甚至可以关掉登录窗口，下次再进去重新挂上screen会话，所有工作全部都会恢复。</p>
<blockquote>
<ul>
<li><p><strong>安装</strong><br><code>sudo apt install screen</code></p>
</li>
<li><p><strong>创建新会话</strong><br><code>screen -S 0x0</code><br>创建一个名为「0x0」的会话，可以在其中执行任务。</p>
</li>
<li><p><strong>让会话独立（Detached）</strong><br>在当前会话中按住<code>Ctrl + A + D</code>，即可让其独立。此时我们可以在终端执行其他任务或退出终端。</p>
</li>
<li><p><strong>重新连接会话</strong><br><code>screen -r 0x0</code><br>回到名为「0x0」的会话中。</p>
</li>
<li><p><strong>查看会话列表</strong><br><code>screen -ls</code></p>
</li>
<li><p><strong>结束会话</strong><br><code>screen -X -S 0x0 quit</code>强制结束「0x0」会话。<br>在「0x0」会话中按住<code>Ctrl + D</code>结束当前会话。</p>
</li>
<li><p><strong>清除死亡会话</strong><br><code>screen -wipe</code></p>
</li>
</ul>
</blockquote>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/40133139" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40133139</a><br><a href="https://www.cnblogs.com/xinzaibing/archive/2012/04/08/2437431.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinzaibing/archive/2012/04/08/2437431.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Screen</tag>
      </tags>
  </entry>
  <entry>
    <title>PanDownload远程Aria2下载恢复连接数</title>
    <url>/2020/04/12/PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h3><p>什么是连接数？如图：<br><img src="2020-04-12-PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/0x0.png" alt="pic0x0"><br>对应PanDownload下载列表的连接数。</p>
<p>这个参数在AriaNg面板中是这样的：<br><img src="2020-04-12-PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/0x2.png" alt="pic0x1"><br>通常情况下，连接数越大，速度越快。Aria2默认可设置单服务器最大连接数是16，可以重新编译Aria2设置更高的连接数。但过高的连接数对于百度云下载无显著意义，因为百度云单方面对连接数和对应速度做出了限制。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>在使用PanDownload远程Aria2下载过程中，会出现连接数缓慢递减，从而造成速度下降甚至是下载骤停。<br>查了很久没有找到对应的配置设置，不过笔者摸索出了一个土办法，可以在连接数下降之后手动重置连接数。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><blockquote>
<ul>
<li>首先让PanDownload与AriaNg面板的显示失去同步。<blockquote>
<p>解释：PanDownload调用远程Aria2下载时，PanDownload和AriaNg会同步显示下载进度。<br>在任意端直接点击暂停都会让二者同时暂停。<br>把PanDownload退出可让二者的显示信息失去同步。</p>
</blockquote>
</li>
<li>打开PanDownload，此时任务在远程服务器仍在进行。AriaNg显示进度而PanDownload则显示暂停。</li>
<li>在AriaNg面板中将所要重置连接数的任务暂停。<blockquote>
<p>此时所要重置连接数的任务会被移动到「正在等待」选项中。</p>
</blockquote>
</li>
<li>在Pandownload中让目标任务继续下载。<blockquote>
<p>若任务消失可以重新下载，不会对已下载的所需要重置连接数的任务造成影响，因为这相当于另一个任务，待会可以删除。</p>
</blockquote>
</li>
<li>在AriaNg面板中发现「正在下载」中出现恢复最大连接数的对应任务。<blockquote>
<p>如果上一步是“暂停 - 下载”，那么这一步恢复的任务会接着暂停的进度继续下载，而「正在等待」中会有相应的重复任务，将其删除即可；<br>如果上一步是重新下载，那么此处恢复最大连接数的任务会从零开始，不用慌，我们将其删除，从「正在等待」中将对应的任务恢复下载，此时目标任务连接数已恢复最大值。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>特别是在下载大文件的时候，掉连接数会造成下载失败。只能通过人工干预来解决了，希望以后Aria2会对此进行优化。</p>
<h1 id="R-I-P-PanDownload"><a href="#R-I-P-PanDownload" class="headerlink" title="R.I.P PanDownload"></a>R.I.P PanDownload</h1><p><strong>2020年4月15日，希望作者渡过这道坎</strong><br><img src="2020-04-12-PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/0x2.jpg" alt="pic0x2"></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
        <tag>AriaNg</tag>
        <tag>PanDownload</tag>
        <tag>远程Aria2下载</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux平台解压缩</title>
    <url>/2020/04/11/Linux%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="7z-zip格式"><a href="#7z-zip格式" class="headerlink" title="7z/zip格式"></a>7z/zip格式</h3><p><strong>安装</strong><br>安装p7zip<br>debian可以直接安装，其他系统可以使用相应命令。<br><code>sudo apt-get install p7zip-full</code></p>
<p><strong>保留完整目录结构解压7z/zip文件</strong><br><code>7z x name.7z</code></p>
<p><strong>解压带密码7z/zip文件</strong><br><code>7z x -p&quot;passwordGo&quot; name.7z</code><br>支持<code>utf-8</code>编码的中文密码，而在Windows平台压缩包其中文密码一般是<code>gbk</code>编码。</p>
<p><strong>解压<code>gbk</code>编码密码的7z/zip文件</strong><br>现有密码为<code>中文密码</code>的压缩包<code>name.7z</code>。<br>直接执行<code>7z x -p&quot;&quot; name.7z</code>报密码错，因为shell输入的<code>中文密码</code>是<code>utf-8</code>编码。<br>需要有一个编码转换的过程，可以执行命令行：<br><code>7z x -p&quot;$(echo -n 中文密码|iconv -f utf-8 -t gbk)&quot; name.7z</code><br>shell会首先执行<code>$()</code>中的命令，不换行打印中文密码<code>中文密码</code>，再将<code>uft-8</code>编码的密码转换成<code>gbk</code>编码。最后执行解压缩命令，即可成功解压。</p>
<p><strong>解压密码带有特殊字符的7z/zip文件</strong><br>现有密码为<code>letsgo!-pipixia#hahaha%wow$thatwasepic!</code>的压缩包。<br>直接执行<code>7z x -p&#39;letsgo!-pipixia#hahaha%wow$thatwasepic!&#39; name.7z</code><br>注意到<code>-p</code>后密码引号为<code>&#39;&#39;</code>。</p>
<p><strong>解压分卷7z/zip文件</strong><br>split files:    </p>
<ul>
<li>name.7z.001</li>
<li>name.7z.002</li>
<li>name.7z.003</li>
</ul>
<p>不用合并后再解压缩，任选一个解压即可。<br><code>7z x name.7z.001</code></p>
<p><strong>解压带密码分卷7z/zip文件</strong><br><code>7z x -p&quot;passwordGo!&quot; name.7z.001</code></p>
<p><strong>批量解压各自独立的7z/zip文件</strong><br><code>for i in *.7z; do 7z x -p&quot;passwordGo&quot; $i; done</code></p>
<p><strong>解压目录下所有7z/zip文件</strong><br>先使用<code>find</code>找出压缩文件，再执行解压。<br><code>find /home/AriaGo *.7z -exec 7z x -p&#39;passwordGo&#39; {} \;</code></p>
<p><strong>加密压缩</strong><br><code>7z a dstname.7z * -p&#39;password&#39;</code><br><code>*</code>是目录或文件，如<code>./image/homeland</code>,<code>./image/homeland/skyline.jpg</code></p>
<h5 id="更多详情，请参考："><a href="#更多详情，请参考：" class="headerlink" title="更多详情，请参考："></a>更多详情，请参考：</h5><blockquote>
<p><a href="https://www.cnblogs.com/itech/archive/2009/08/31/1555835.html" target="_blank" rel="noopener">https://www.cnblogs.com/itech/archive/2009/08/31/1555835.html</a><br><a href="https://blog.csdn.net/qq_28050861/article/details/103255120" target="_blank" rel="noopener">https://blog.csdn.net/qq_28050861/article/details/103255120</a></p>
</blockquote>
<h3 id="rar格式"><a href="#rar格式" class="headerlink" title="rar格式"></a>rar格式</h3><p><strong>安装</strong><br>安装unrar<br>debian可以直接安装，其他系统可以使用相应命令。<br><code>sudo apt-get install unrar</code></p>
<p><strong>按源目录结构解压</strong><br>保留源目录结构解压到工作目录。<br><code>unrar x name.rar</code></p>
<p><strong>不保留目录结构解压</strong><br>不保留源目录结构解压到工作目录。<br><code>unrar e name.rar</code></p>
<p><strong>不保留目录结构解压到指定目录</strong><br><code>unrar e name.rar /home/level1/level2</code> </p>
<p><strong>解压带密码rar文件</strong><br><code>unrar e -p&quot;passwordGo&quot; name.rar</code></p>
<p><strong>列出文件列表</strong><br><code>unrar l name.rar</code></p>
<h5 id="更多详情，请参考：-1"><a href="#更多详情，请参考：-1" class="headerlink" title="更多详情，请参考："></a>更多详情，请参考：</h5><blockquote>
<p><a href="https://www.tecmint.com/how-to-open-extract-and-create-rar-files-in-linux/" target="_blank" rel="noopener">https://www.tecmint.com/how-to-open-extract-and-create-rar-files-in-linux/</a></p>
</blockquote>
<h3 id="tar-gz格式"><a href="#tar-gz格式" class="headerlink" title="tar.gz格式"></a>tar.gz格式</h3><p><strong>压缩</strong><br><code>tar -czvf ./dstfilename.tar.gz ./srcfilname.format</code></p>
<hr>
<p><em>未完待续</em></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>解压缩</tag>
        <tag>7z</tag>
        <tag>zip</tag>
        <tag>rar</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #151 翻转字符串里的单词「Reverse Words in a String」</title>
    <url>/2020/04/11/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%8CReverse-Words-in-a-String%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #22 括号生成「Generate Parentheses」</title>
    <url>/2020/04/10/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E3%80%8CGenerate-Parentheses%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>玩转rclone</title>
    <url>/2020/04/09/%E7%8E%A9%E8%BD%ACrclone/</url>
    <content><![CDATA[<h3 id="名词详解"><a href="#名词详解" class="headerlink" title="名词详解"></a>名词详解</h3><p><strong><code>remote</code></strong></p>
<blockquote>
<p><code>remote</code>可以理解成rclone程序「可操作」的对象。通常，一个remote在配置的时候会被分配：<br>一个API接口<code>client_id</code>和<code>client_secret</code>，可以默认rclone官方接口，也可以自己指定接口；<br>一个rclone权限<code>scope</code>，一共5种权限，通常我会选第1个Full access；<br>一个根目录ID<code>root_folder_id</code>，它指定了rclone程序可操作的源在什么地方，通常我会设置成网盘根目录，即对整个网盘可操作；<br>一个服务账号文件<code>service_account_file</code>，它可指定rclone使用真实或服务账号。</p>
</blockquote>
<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><p><strong><code>copy</code></strong></p>
<blockquote>
<p><code>rclone copy remoteA:srcDir remoteB:dstDir</code></p>
<p><code>copy</code> 适用于从一个地方「拷贝」到另一个地方，不管是从本地到网盘还是网盘到网盘。需要注意的是，Rclone绑定的账号至少需要对源有「读取」权限，对目标有「写入」权限。</p>
<p><strong>举例：</strong><br>假设我们配置4个remote：remoteA为网盘A；remogteB为网盘B；remoteC为团队盘C；remoteD为团队盘D；<br>从remoteA的目录”/GdTemp”到remoteA的目录”/Movies/2020”：<br><code>rclone copy remoteA:/GdTemp remoteA/Movies/2020</code><br>从remoteA的目录”/GDTemp” </p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Rclone</tag>
        <tag>GoogleDrive</tag>
      </tags>
  </entry>
  <entry>
    <title>LeecCode #面试题13 机器人的运动范围「」</title>
    <url>/2020/04/08/LeecCode-%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%8C%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #面试题01.07 旋转矩阵「Rotate Matrix LCCI」</title>
    <url>/2020/04/07/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%8CRotate-Matrix-LCCI%E3%80%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？<br><strong>示例1：</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
</blockquote>
<hr>
<h3 id="原地旋转方法"><a href="#原地旋转方法" class="headerlink" title="原地旋转方法"></a>原地旋转方法</h3><p>先将数组按对角线翻折：<br><img src="2020-04-07-LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%8CRotate-Matrix-LCCI%E3%80%8D/Rotate_Matrix_LCCI_0x0.png" alt="pic0x0"><br>此时得到的数组每行和目标数组相反，只需要再将每行数组按中轴线翻折。<br>注意两次翻折的起始和终止，切记不能重复翻折（会折回去）。<br>比如第一次翻折不能写成<code>for (int j = 0; j &lt; len; j++)</code>。如果这样，在<code>i</code>向下遍历过程中，会将之前折的折回去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 0ms</span></span><br><span class="line"><span class="comment">     * 39.7MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//切莫从0开始，否则当遍历j时又换回去了</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++) &#123; <span class="comment">//到中线结束，否则过中线又换回去了</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][len - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][len - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借用临时N-N数组（需额外空间）"><a href="#借用临时N-N数组（需额外空间）" class="headerlink" title="借用临时N * N数组（需额外空间）"></a>借用临时N * N数组（需额外空间）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 0ms</span></span><br><span class="line"><span class="comment">     * 40.2MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                temp[j][len - <span class="number">1</span> - i] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            System.arraycopy(temp[i], <span class="number">0</span>, matrix[i], <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #42 接雨水（Trapping Rain Water）</title>
    <url>/2020/04/04/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88Trapping-Rain-Water%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="2020-04-04-LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88Trapping-Rain-Water%EF%BC%89/%E9%A2%98%E7%9B%AE.png" alt="pic0x0"></p>
<center><font size=1>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</font></center>

<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6 </p>
</blockquote>
<hr>
<h3 id="按列计算（动态规划计算最值）"><a href="#按列计算（动态规划计算最值）" class="headerlink" title="按列计算（动态规划计算最值）"></a>按列计算（动态规划计算最值）</h3><p>遍历每列，判断要不要计算列上的积水。<br>如何判断？计算出该列左侧最高列高度，计算右侧最高列高度。<br>若该列比二者都小，则该列需要计算;否则不需计算。<br>如何分别计算某列两侧最值？<br>可维护两个数组分别存储每列左右两侧最值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * [列解法, 动态规划]</span></span><br><span class="line"><span class="comment">     * 1ms</span></span><br><span class="line"><span class="comment">     * 39.3MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] leftSideMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] rightSideMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//第一列和最后一列不需要计算两侧最值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            leftSideMax[i] = Math.max(leftSideMax[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightSideMax[i] = Math.max(rightSideMax[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minimum = Math.min(leftSideMax[j], rightSideMax[j]);</span><br><span class="line">            <span class="keyword">if</span> (height[j] &lt; minimum) &#123;</span><br><span class="line">                res += (minimum - height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>核心思想是先降后增必有积水。<br>这个就有点像有效括号，一对儿。<br>维护一个单调递减的栈，栈中存入柱子下标。（为什么存入下标而不直接存入高度？因为我们可能会计算两个相隔若干柱子之间的距离。）<br>入栈：栈为空时；当前柱子低于栈顶柱子。<br>出栈：当前柱子高于栈顶柱子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 单调栈 简化代码</span></span><br><span class="line"><span class="comment">     * 4ms - 29.81%</span></span><br><span class="line"><span class="comment">     * 39.5MB, 11.78%</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123; <span class="comment">//有可能可计算体积</span></span><br><span class="line">                <span class="keyword">int</span> heightInfoBeforePop = stack.peek();</span><br><span class="line">                stack.pop(); <span class="comment">// 当前柱子高于栈顶柱子时，出栈。记得出栈前先保存栈高数据。</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>; <span class="comment">//不可计算体积</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> stackTop = stack.peek();</span><br><span class="line">                    res += ((i - stackTop - <span class="number">1</span>) * (Math.min(height[i], height[stackTop]) - height[heightInfoBeforePop]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i); <span class="comment">// 栈空或当前柱子小于等于于栈顶柱子高度时，入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读代码的一点心得</title>
    <url>/2020/04/04/%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>阅读代码时，要先看整体架构，再看局部细节。<br>明确哪里没变，哪里会变，怎么变的。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1111 有效括号的嵌套深度「Maximum Nesting Depth of Two Valid Parentheses Strings」</title>
    <url>/2020/04/02/LeetCode-1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%E3%80%8CMaximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #20 有效的括号「Valid Parentheses」</title>
    <url>/2020/04/02/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E3%80%8CValid-Parentheses%E3%80%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入: “()”<br>输出: true</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入: “()[]{}”<br>输出: true</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p>输入: “(]”<br>输出: false</p>
</blockquote>
<p><strong>示例4：</strong></p>
<blockquote>
<p>输入: “([)]”<br>输出: false</p>
</blockquote>
<p><strong>示例5：</strong></p>
<blockquote>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<hr>
<h3 id="HashMap辅助的栈解法"><a href="#HashMap辅助的栈解法" class="headerlink" title="HashMap辅助的栈解法"></a>HashMap辅助的栈解法</h3><p>构建一个key为开括号<code>&#39;(&#39;,&#39;[&#39;,&#39;{&#39;</code>value为闭括号<code>&#39;)&#39;&#39;]&#39;&#39;}&#39;</code>的HashMap。<br>遍历String字符串，当遇到开括号，由于将来有机会遇到与之对应的闭括号，故将其入栈。<br>当遇到闭括号，一旦它和栈顶的括号不匹配，可断言整体不是有效括号。（栈为空时，遇到的第一个若为闭括号也可看成与栈顶不匹配，但需做特殊处理）<br>当遍历完String字符串，中途没出现闭括号和栈顶字符不匹配的情况，此时若栈为空，则可断言之前入栈的开括号全部被匹配移除；若栈非空，可断言之前入栈的开括号没有找到匹配的闭括号，整体不属于有效括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cha = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(cha)) &#123;</span><br><span class="line">                stack.push(cha); <span class="comment">//开括号入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 栈为空时，必然return false，但为了用相同的方法让cha能和栈顶元素比较，push一个随便啥的字符</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.isEmpty() ? <span class="string">'!'</span> : stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (map.get(cha) != top) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，判断栈的状态</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯栈解法"><a href="#纯栈解法" class="headerlink" title="纯栈解法"></a>纯栈解法</h3><p>基本思路与上述方法一致，只是在判断闭括号栈顶元素时用一个小技巧代替<code>HashMap</code>。<br>遍历字符串，当遇到开括号时，把相对应的闭括号入栈。比如遇到<code>(</code>，把<code>)</code>入栈。这样，当下一个若是闭括号我们要那它和栈顶元素比较的话，可以不查<code>HashMap</code>而是直接比较是否相等。若相等，则是一对。继续循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cha = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cha == <span class="string">'('</span>) stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cha == <span class="string">'['</span>) stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cha == <span class="string">'&#123;'</span>) stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || cha != stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//此时遇到闭括号且栈为空，则必然无效，或者闭括号与栈顶元素不匹配，必然无效</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a><br><strong>参考题解：</strong> <a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转ffmpeg</title>
    <url>/2020/03/30/%E7%8E%A9%E8%BD%ACffmpeg/</url>
    <content><![CDATA[<h3 id="合并分段视频"><a href="#合并分段视频" class="headerlink" title="合并分段视频"></a>合并分段视频</h3><p><strong>方法1：txt文件保存视频文件名</strong></p>
<blockquote>
<p><code>ffmpeg -f concat -safe 0 -i files.txt -c copy &quot;merge.MP4&quot;</code></p>
</blockquote>
<p>其中files.txt中写入分段视频文件名</p>
<blockquote>
<p>file  name0x0.ts<br>file  name0x1.ts<br>file  name0x2.ts<br>file  name0x3.ts<br>file  name0x4.ts<br>file  name0x5.ts</p>
</blockquote>
<p><strong>方法2：直接写入各个视频文件名</strong></p>
<blockquote>
<p><code>ffmpeg -i &quot;concat:name0x0|name0x1|name0x2|name0x3&quot; -c copy &quot;merge.mp4&quot;</code></p>
</blockquote>
<h3 id="视频转换格式"><a href="#视频转换格式" class="headerlink" title="视频转换格式"></a>视频转换格式</h3><blockquote>
<p><code>ffmpeg -i &quot;video.ts&quot; -vcodec copy -acodec copy &quot;video.mp4&quot;</code></p>
</blockquote>
<h3 id="截取一段视频"><a href="#截取一段视频" class="headerlink" title="截取一段视频"></a>截取一段视频</h3><p>从第12秒截取到294秒：<br><code>ffmpeg  -i 0x0.mkv -ss 12 -c copy -to 294 0x1.mp4</code></p>
<h3 id="提取视频中的音频"><a href="#提取视频中的音频" class="headerlink" title="提取视频中的音频"></a>提取视频中的音频</h3><p><code>ffmpeg -i xxx.mp4 -f mp3 -ar 16000 xxx.mp3</code><br>其中：<br>xxx.mp4 视频文件<br>-f mp3 mp3编码<br>-ar 16000 音频采样率<br>xxx.mp3输出的音频文件</p>
<p><strong>未完待续</strong></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode # 10 卡牌分组（X of a Kind in a Deck of Cards）</title>
    <url>/2020/03/29/LeetCode-10-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84%EF%BC%88X-of-a-Kind-in-a-Deck-of-Cards%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>计数数组</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #9 两数相加（Add Two Numbers）</title>
    <url>/2020/03/29/LeetCode-9-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add%20Two%20Numbers%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<p><strong>示例：</strong></p>
<blockquote>
<p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong> 7 -&gt; 0 -&gt; 8<br><strong>原因：</strong> 342 + 465 = 807</p>
</blockquote>
<hr>
<h3 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h3><p>我们需要创建一个新的链表作为相加后的返回对象，而且在新的链表构造过程中，其头结点需要不断移动，从而导致无法返回整个链表。</p>
<p>我们可以定义独立于新链表的一个 <strong>超级头结点</strong> ，让其指向新的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//超级头结点</span></span><br><span class="line">        ListNode cur = pre; <span class="comment">//超级头结点指向新的链表</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> value2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = value1 + value2 + carry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) carry = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.next; <span class="comment">//返回超级头结点的后面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>超级头结点</tag>
      </tags>
  </entry>
  <entry>
    <title>求最大公约数（gcd）的一点心得</title>
    <url>/2020/03/27/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%88gcd%EF%BC%89%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h3 id="求两个数的最大公约数"><a href="#求两个数的最大公约数" class="headerlink" title="求两个数的最大公约数"></a>求两个数的最大公约数</h3><p>在《算法 第4版》中，给出迭代求最大公约数的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，这里用到了迭代的思想。两数相除，再拿被除数除余数，如此辗转，直到余数为零，返回此时的被除数 。<br>上述代码可简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q == <span class="number">0</span> ? p : gcd(q, p % q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个非迭代版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (y != <span class="number">0</span>) &#123; </span><br><span class="line">         <span class="keyword">int</span> temp = y;</span><br><span class="line">         y = x % y; <span class="comment">// 余数变被除数</span></span><br><span class="line">         x = temp; <span class="comment">//被除数变除数</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="n个数求最大公约数"><a href="#n个数求最大公约数" class="headerlink" title="n个数求最大公约数"></a>n个数求最大公约数</h3><p>一个常见的求法就是设置一个初始的gcd，求它和第一个数的gcd。再将该gcd和第二个数求它们的gcd，如此辗转，直到求第n个数和前n-1个数的gcd。复杂度是O(N)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GcdN</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcdN</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gcd = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> each : arr) </span><br><span class="line">            gcd = gcd(gcd, each);</span><br><span class="line">        <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="number">0</span> ? p : gcd(q, p % q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>About me</title>
    <url>/2020/03/27/About-me/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"zhangxy"</span>; <span class="comment">// Well, good name.</span></span><br><span class="line">    <span class="keyword">char</span> sex = <span class="string">'male'</span>; <span class="comment">// A tough man.</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">25</span>; <span class="comment">// Grasping the little tail of youth.</span></span><br><span class="line">    <span class="keyword">int</span> hight = <span class="number">170</span>; <span class="comment">// Enough to me.</span></span><br><span class="line">    <span class="keyword">float</span> weight = <span class="number">73.7f</span>; <span class="comment">// Emm, a little bit overweight, but everyday going to gym. Gym is second home. </span></span><br><span class="line">    String edu = <span class="string">"UESTC"</span>; <span class="comment">// Where the water tastes like wine. </span></span><br><span class="line">    String pro = <span class="string">"SE"</span>; <span class="comment">// Making cool stuff.</span></span><br><span class="line">    String marriage = <span class="string">"Single"</span>; <span class="comment">// I'm trying...emm...how to be more attractive ?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wish</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"春日宴，浊酒一杯歌一遍。再拜陈三愿：</span></span><br><span class="line"><span class="string">                    一愿父母身体常健，</span></span><br><span class="line"><span class="string">                    二愿自己珍惜时间，</span></span><br><span class="line"><span class="string">                    三愿如同梁上燕，</span></span><br><span class="line"><span class="string">                    岁岁年年，快乐无边！"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moreInfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Stay tuned:)"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>生活</category>
        <category>me</category>
        <category>About me</category>
      </categories>
  </entry>
  <entry>
    <title>方便调试的链表类实现</title>
    <url>/2020/03/26/%E6%96%B9%E4%BE%BF%E8%B0%83%E8%AF%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>链表是一种特殊的数据结构：<br><img src="2020-03-26-%E6%96%B9%E4%BE%BF%E8%B0%83%E8%AF%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="pic0x0"><br>它包含了两部分：<br>$$ListNodePtr<br>\begin{cases}{value} \\<br>{next}\begin{cases}{value} \\<br>                    {next}\begin{cases}{value} \\<br>                                       {next…}<br>                                       \end{cases}<br>                    \end{cases}<br>\end{cases}<br>$$<br>在《算法 第4版》中是这样描述的：</p>
<blockquote>
<p>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>
<p>在我看来，因为链表是一种递归的数据结构，故不要把“结点”看成一个“点”。而应该看成是一个<code>value</code> + 该<code>value</code>后的全部链表———它是全部链表的一部分。<br>关于这个<code>value</code>，它可能是任意数据类型。</p>
<p>一般来说链表类可以写成如下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了在调试代码的时候直观地看到链表形如<code>7 -&gt; 0 -&gt; 8 -&gt; null</code>，链表类可以写成如下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"arr can not be empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        val = nums[<span class="number">0</span>];</span><br><span class="line">        ListNode curr = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(nums[i]); <span class="comment">//创建ListNode实例，调用前面的构造方法</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ListNode cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.append(cur.val);</span><br><span class="line">            s.append(<span class="string">" -&gt; "</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">"null"</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调试的时候，比如向<code>SolutionMe0x0</code>类的<code>testListNode</code>方法中传递链表<code>ListNode lx, ListNode ly</code>，我们可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span>[] test1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] test2 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] test1 = &#123;6, 7, 8, 3, 2, 7&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test2 = &#123;9, 7, 6, 6&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test1 = &#123;2&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test2 = &#123;5&#125;;</span></span><br><span class="line">        ListNode lx = <span class="keyword">new</span> ListNode(test1);</span><br><span class="line">        ListNode ly = <span class="keyword">new</span> ListNode(test2);</span><br><span class="line">        System.out.println(SolutionMe0x0.testListNode(lx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #8 车的可用捕获量（Available Captures for Rook）</title>
    <url>/2020/03/26/LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白&gt; 色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，<br>“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西&gt; 和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动&gt; 到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白&gt; 色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><p><img src="2020-03-26-LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/%E7%A4%BA%E4%BE%8B1.png" alt="pic0x0"></p>
<blockquote>
<p><strong>输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'R'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 3<br><strong>解释：</strong> 在本例中，车能够捕获所有的卒</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><p><img src="2020-03-26-LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/%E7%A4%BA%E4%BE%8B2.png" alt="pic0x1"></p>
<blockquote>
<p><strong>输入：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'R'</span>,<span class="string">'B'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 0<br><strong>解释：</strong> 象阻止了车捕获任何卒</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><p><img src="2020-03-26-LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/%E7%A4%BA%E4%BE%8B3.png" alt="pic0x2"></p>
<blockquote>
<p><strong>输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'R'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'B'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 3<br><strong>解释：</strong> 车可以捕获位置 b5，d6 和 f5 的卒</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ol>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] 可以是 ‘R’，’.’，’B’ 或 ‘p’</li>
<li>只有一个格子上存在 board[i][j] == ‘R’</li>
</ol>
</blockquote>
<hr>
<p>题目所求即白车<code>rock(R)</code>一次移动击杀小卒<code>pawn(p)</code>所有可能的情况。<br>读懂题意后，先找白车<code>R</code>，以<code>R</code>为起点，分别往四个方向寻找<code>p</code>。<br>注意可能会遇到<code>Bishop(B)</code>，表示此路不通。另注意范围。</p>
<h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> y = i, x = j;</span><br><span class="line">                    <span class="comment">//纵上</span></span><br><span class="line">                    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//纵下</span></span><br><span class="line">                    i = y; <span class="comment">//i归位</span></span><br><span class="line">                    <span class="keyword">while</span> (++i &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//横左</span></span><br><span class="line">                    i = y;<span class="comment">//i归位</span></span><br><span class="line">                    <span class="keyword">while</span> (--j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//横右</span></span><br><span class="line">                    j = x;<span class="comment">//j归位</span></span><br><span class="line">                    <span class="keyword">while</span> (++j &lt;=<span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维方向数组"><a href="#二维方向数组" class="headerlink" title="二维方向数组"></a>二维方向数组</h3><p>依然是先找到<code>R</code>，定义方向数组<code>[[-1, 0], [1, 0], [0, 1], [0, -1]]</code>，循环该方向数组可表示依次走一个方向。<br>走其中某个方向时，用<code>i, j</code>分别加方向数组即可完成行走动作，注意在行走时要判断棋盘范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为题目已经明确给出 board.length == board[i].length == 8，所以不做输入检查</span></span><br><span class="line">        <span class="comment">// 定义方向数组，可以认为是四个方向向量，在棋盘问题上是常见的做法</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (burnout(board, i, j, direction)) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代码不会走到这里，返回 0 或者抛出异常均可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * burnout 横冲直撞的意思（来自欧路词典）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board     输入棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x         当前白象位置的横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y         当前白象位置的纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 方向向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消灭一个 p，就返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">burnout</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[] direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x;</span><br><span class="line">        <span class="keyword">int</span> j = y;</span><br><span class="line">        <span class="keyword">while</span> (inArea(i, j)) &#123;</span><br><span class="line">            <span class="comment">// 是友军，路被堵死，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是敌军，拿下一血（不知道一血这个词是不是这么用的）</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += direction[<span class="number">0</span>];</span><br><span class="line">            j += direction[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前位置横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 当前位置纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在棋盘有效范围内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="number">8</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<blockquote>
<ul>
<li>时间复杂度：(N^2)，这里 NN 是输入棋盘的长（宽）。找到白色车，最差情况下需要遍历完整个数组。题目固定了输入是 8 \times 88×8 规格的棋盘，认为是 O(1)O(1) 也是没有问题的。</li>
<li>空间复杂度：O(1)，只使用到常数个临时变量。</li>
</ul>
</blockquote>
<h5 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook/</a></p>
</blockquote>
<h5 id="参考题解："><a href="#参考题解：" class="headerlink" title="参考题解："></a>参考题解：</h5><blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/available-captures-for-rook/solution/mo-ni-ti-an-zhao-ti-mu-yi-si-shi-xian-ji-ke-java-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook/solution/mo-ni-ti-an-zhao-ti-mu-yi-si-shi-xian-ji-ke-java-b/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>方向数组</tag>
        <tag>棋盘</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode # 7 三维形体的表面积（Surface Area of 3D Shapes）</title>
    <url>/2020/03/25/LeetCode-7-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF%EF%BC%88Surface-Area-of-3D-Shapes%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</p>
<p>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</p>
<p>请你返回最终形体的表面积。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入：[[2]]<br>输出：10</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入：[[1,2],[3,4]]<br>输出：34</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><blockquote>
<p>输入：[[1,0],[0,2]]<br>输出：16</p>
</blockquote>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><blockquote>
<p>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32</p>
</blockquote>
<h3 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h3><blockquote>
<p>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
</blockquote>
<hr>
<p>用示例5举例，二维数组<code>[[2,2,2],[2,1,2],[2,2,2]]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] grid = &#123;</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表明一个3*3网格，每个格子分别放置对应数字的方块。<br>那么，表面积 = 总数 * 6 - 2(x + y + z)，其中x, y, z分别表示x, y, z方向重叠面数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this surface means hidden surface</span></span><br><span class="line">        <span class="keyword">int</span> surfaceZ = <span class="number">0</span>, surfaceY = <span class="number">0</span>, surfaceX = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// value count</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> raw = <span class="number">0</span>; raw &lt; grid.length; raw++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; grid[raw].length; column++) &#123;</span><br><span class="line">                <span class="comment">// count value</span></span><br><span class="line">                value += grid[raw][column];</span><br><span class="line">                <span class="comment">// for each X, Y ,Z count hidden surface</span></span><br><span class="line">                <span class="keyword">if</span> (raw &lt; grid.length - <span class="number">1</span>)</span><br><span class="line">                    surfaceX += Math.min(grid[raw][column], grid[raw+<span class="number">1</span>][column]);</span><br><span class="line">                <span class="keyword">if</span> (column &lt; grid[raw].length - <span class="number">1</span>)</span><br><span class="line">                    surfaceY += Math.min(grid[raw][column], grid[raw][column+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (grid[raw][column] &gt; <span class="number">0</span>)</span><br><span class="line">                    surfaceZ += (grid[raw][column] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this surface is real "surface"</span></span><br><span class="line">        <span class="keyword">int</span> surface = <span class="number">0</span>;</span><br><span class="line">        surface = value * <span class="number">6</span> - surfaceX * <span class="number">2</span> - surfaceY * <span class="number">2</span> - surfaceZ * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> surface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N^2)，其中 NN 是 grid 中的行和列的数目</li>
<li>空间复杂度：O(1)</li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-surface-area-of-3d-shapes"><a href="#题目链接https-leetcode-cn-com-problems-surface-area-of-3d-shapes" class="headerlink" title="题目链接https://leetcode-cn.com/problems/surface-area-of-3d-shapes/"></a>题目链接<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes/</a></h5>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #6 按摩师（The Masseuse LCCI）</title>
    <url>/2020/03/24/LeetCode-6-%E6%8C%89%E6%91%A9%E5%B8%88%EF%BC%88The-Masseuse-LCCI%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或&gt; 不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。&gt; 给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>注意</strong>：本题相对原题稍作改动</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 &gt; = 12。</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><blockquote>
<p>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = &gt; 2 + 4 + 3 + 3 = 12。</p>
</blockquote>
<hr>
<h3 id="一维状态数组"><a href="#一维状态数组" class="headerlink" title="一维状态数组"></a>一维状态数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];<span class="comment">//or i-1 because i++ in last step</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)O(N)，NN 是数组的长度；</li>
<li>空间复杂度：O(N)O(N)，状态数组的大小为 N</li>
</ul>
<h3 id="一维状态数组-「滚动数组」"><a href="#一维状态数组-「滚动数组」" class="headerlink" title="一维状态数组+「滚动数组」"></a>一维状态数组+「滚动数组」</h3><p>使用 3 个变量滚动完成计算，将空间优化到常数级别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionSO1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre = <span class="number">0</span>, cur = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            cur = Math.max(pre, pre2 + num);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)，N是数组的长度；</li>
<li>空间复杂度：O(1)，状态数组的大小为 3，常数空间。</li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-the-masseuse-lcci"><a href="#题目链接https-leetcode-cn-com-problems-the-masseuse-lcci" class="headerlink" title="题目链接https://leetcode-cn.com/problems/the-masseuse-lcci/"></a>题目链接<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/</a></h5><h5 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #5 链表的中间结点（Middle of the Linked List）</title>
    <url>/2020/03/23/LeetCode-5-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%EF%BC%88Middle-of-the-Linked-List%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 1 和 100 之间。</li>
</ul>
<hr>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>定义一个快指针，定义一个慢指针。其中快指针每个循环走两部，慢指针走一步。这样，当快指针走慢整个链表，由于其速度是慢指针的二倍，故慢指针停留的位置即为链表的中间结点。</p>
<p>注意到，当链表结点个数为偶时，即链表有两个中间结点。此时，题干要求返回第二个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">            <span class="keyword">else</span> fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若题干要求返回第一个结点，应该这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return secondary node while we got a even node linkedList</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表类数组"><a href="#链表类数组" class="headerlink" title="链表类数组"></a>链表类数组</h3><p>换个思路，当我们知道链表结点个数，个数/2即为中间结点位置。我们可以创建一个链表类数组（记得曾经用过的计数数组吗？数组是个好东西，我们要把它玩坏！）循环链表每个结点，把它放在数组里。</p>
<p>注意到，由于题干给出当有两个中间结点取其第二个，我们正好可以利用整形变量特征————int a = 5 / 2，则a被强制转换向下取整为2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode[] arr = <span class="keyword">new</span> ListNode[<span class="number">100</span>]; <span class="comment">//we have restriction about length of linkedList</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr[i++] = head;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[count / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用ArratList可以稍微稍微节省点空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;ListNode&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr.add(head);</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.get(arr.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #4 使数组唯一的最小增量（Minimum Increment to Make Array Unique）</title>
    <url>/2020/03/22/LeetCode-4-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F%EF%BC%88Minimum%20Increment%20to%20Make%20Array%20Unique%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p>
<p>返回使 A 中的每个值都是唯一的最少操作次数。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入：[1,2,2]<br>输出：1<br>解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入：[3,2,1,2,1,7]<br>输出：6<br>解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。<br>可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ul>
<li>0 &lt;= A.length &lt;= 40000</li>
<li>0 &lt;= A[i] &lt; 40000</li>
</ul>
</blockquote>
<hr>
<h3 id="先排序再遍历"><a href="#先排序再遍历" class="headerlink" title="先排序再遍历"></a>先排序再遍历</h3><p>首先将数组进行排序，然后从左到右遍历数组：</p>
<ul>
<li>如果当前元素大于上一个元素，保持不变；</li>
<li>如果当前元素小于等于上一个元素，就需要增加当前元素，直到大于上一个元素。<br>例如输入 <code>[3, 2, 1, 2, 1, 7]</code>，排序后为<code>[1, 1, 2, 2, 3, 7]</code>。遍历数组的过程如下图所示：<br>![pic0x0](2020-03-22-LeetCode-4-使数组唯一的最小增量（Minimum Increment to Make Array Unique）/使数组唯一的最小增量 先排序再遍历.gif)<br>写成代码，只需要用一个变量保存当前的最大值即可。题解代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//排序再遍历计数，最基础的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="comment">//下个数不比当前数大，则计算下个数需要加的次数res，同时</span></span><br><span class="line">        <span class="comment">//由于每次move操作+1，故下个数+res刚好大于当前数</span></span><br><span class="line">        <span class="comment">//注意此时数组排序会被打乱，不能认为判断条件仅是相等情况.</span></span><br><span class="line">        <span class="comment">//另外，注意边界，最多判定到lengh - 2位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i+<span class="number">1</span>] &lt;= A[i])&#123;</span><br><span class="line">                res += (A[i] - A[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                A[i+<span class="number">1</span>] += (A[i] - A[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="构建计数数组"><a href="#构建计数数组" class="headerlink" title="构建计数数组"></a>构建计数数组</h3><p>上面方法中，排序需要 O(n \log n)O(nlogn) 的时间，比较昂贵。我们尝试不进行排序的方法。</p>
<p>例如输入 <code>[3, 2, 1, 2, 1, 7]</code>，计数之后有两个 1 和两个 2。我们先看最小的数，两个 1 重复了，需要有一个增加到 2，这样 2 的数量变成了三个。在三个 2 中，又有两个需要增加到 3，然后又出现了两个 3…… 以此类推，可以计算出需要增加的次数。</p>
<p>我们可以用 map（如 C++ 的 <code>unordered_map</code>，Java 的 <code>HashMap</code>）来做计数。不过既然题目中说明了整数的范围在 0 到 40000 之间，我们不妨直接用一个大小为 40000 的数组做计数。</p>
<p>需要注意的是，虽然整数的范围是 0 到 40000，但是由于整数还会因为增加而变大，超出 40000 的范围。例如极端的情况：所有数都是 39999。所以需要对整数中最大的数单独处理。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计数数组（有序）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//核心思想，是record数组的构建</span></span><br><span class="line">        <span class="comment">//record数组是有序数组，index表示A数组中的值，value表示A数组中数值出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40000</span>];</span><br><span class="line">        <span class="keyword">int</span> max= A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            record[a]++;</span><br><span class="line">            max = Math.max(max, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A数组中最大数max一定在record数组最后面，等下要加以特殊处理</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += (record[i] -<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//record是动态的</span></span><br><span class="line">                <span class="comment">//如果当前位置数值&gt;1，说明下个位置数值会增加当前位置数值-1</span></span><br><span class="line">                record[i+<span class="number">1</span>] += (record[i] -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A数组最大值max在record数组中特殊处理</span></span><br><span class="line">        <span class="comment">//max位于record右边界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (record[max] &gt; <span class="number">1</span>) &#123; <span class="comment">//否则不用担心越界</span></span><br><span class="line">            <span class="keyword">int</span> plus = record[max] - <span class="number">1</span>; <span class="comment">//首项（尾项1）</span></span><br><span class="line">            res += (plus + <span class="number">1</span>) * plus / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性探测法O-N-（含路径压缩）"><a href="#线性探测法O-N-（含路径压缩）" class="headerlink" title="线性探测法O(N) （含路径压缩）"></a>线性探测法O(N) （含路径压缩）</h3><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h5 id="题目链接https-leetcode-cn-com-problems-minimum-increment-to-make-array-unique"><a href="#题目链接https-leetcode-cn-com-problems-minimum-increment-to-make-array-unique" class="headerlink" title="题目链接https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/"></a>题目链接<a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/</a></h5><h5 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h5><blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计数数组</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #3 水壶问题（Water and Jug Problem）</title>
    <url>/2020/03/21/LeetCode-3-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88Water-and-Jug-Problem%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
</blockquote>
<h3 id="示例-1-From-the-famous-“Die-Hard”-example"><a href="#示例-1-From-the-famous-“Die-Hard”-example" class="headerlink" title="示例 1: (From the famous “Die Hard” example)"></a>示例 1: (From the famous “Die Hard” example)</h3><blockquote>
<p>输入: x = 3, y = 5, z = 4<br>输出: True</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><blockquote>
<p>输入: x = 2, y = 6, z = 5<br>输出: False</p>
</blockquote>
<hr>
<h3 id="贝祖定理方法"><a href="#贝祖定理方法" class="headerlink" title="贝祖定理方法"></a>贝祖定理方法</h3><p>关键在于划分成功条件。<br>题干默认z &gt;= 0，首先当z = 0 时，x和y取任意值，一定成功。<br>当z &gt; 0时：</p>
<ul>
<li>当x + y &lt; z时，即使两盏杯子装满水，依然不可能成功。</li>
<li>当x + y = z时，x, y, z取任意值，一定成功。</li>
<li>当x + y &gt; z时，不一定。问题的核心在此，用贝祖定理判定成功条件。<br>由贝祖定理可知，对任何整数x、y和它们的最大公约数gcd(x, y)，对于它们的的任意整数倍数a,b,c，都有<br>ax + by = c·gcd(x, y)恒成立。<br>由题干给出的几种操作，要完成目标，一定有ax + by = z。<br>和贝祖定理完美锲合，那么，只要z % (gcd(x, y)) = 0为真，则一定成功。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//贝祖定理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认z &gt;= 0</span></span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//z&gt;0</span></span><br><span class="line">        <span class="keyword">if</span> (x +y &lt;z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x + y == z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//only x!=0,y!=0; x!=0,y==0; x==0,y!=0</span></span><br><span class="line">            <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123; <span class="comment">//辗转相除法</span></span><br><span class="line">            <span class="keyword">int</span> temp = y;</span><br><span class="line">            y = x % y;</span><br><span class="line">            x = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3></li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-water-and-jug-problem"><a href="#题目链接https-leetcode-cn-com-problems-water-and-jug-problem" class="headerlink" title="题目链接https://leetcode-cn.com/problems/water-and-jug-problem/"></a>题目链接<a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/</a></h5>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>贝祖定理</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #2 最小的k个数「TopK」 0x1</title>
    <url>/2020/03/20/LeetCode-2-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E3%80%8CTopK%E3%80%8D%200x1/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br><strong>示例2：</strong><br>输入：arr = [0,1,2,1], k = 1<br>输出：[0]<br><strong>限制：</strong><br>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p>
</blockquote>
<hr>
<h3 id="快速查找方法-分治法，快速排序思想"><a href="#快速查找方法-分治法，快速排序思想" class="headerlink" title="快速查找方法(分治法，快速排序思想)"></a>快速查找方法(分治法，快速排序思想)</h3><p><img src="2020-03-20-LeetCode-2-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%EF%BC%88TopK%EF%BC%89/quickSort.png" alt="pic0x0"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getTopK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= arr.length)</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length -<span class="number">1</span>;</span><br><span class="line">        partitionArray(arr, low, high, k);</span><br><span class="line">        <span class="comment">//copy array</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> copy = <span class="number">0</span>; copy &lt; k; copy++)&#123;</span><br><span class="line">            result[copy] = arr[copy];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span> (k == m) <span class="comment">//as we expect，反复递归，k会在m左右两侧摇摆，直到恰好等于m</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m)</span><br><span class="line">            partitionArray(arr, low, m -<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            partitionArray(arr, m + <span class="number">1</span>, high, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = arr[low];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == high) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == low) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123; <span class="comment">//碰头了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆方法"><a href="#堆方法" class="headerlink" title="堆方法"></a>堆方法</h3><p>维护一个大顶堆，堆中始终保持当前状态最小k个数。<br><img src="2020-03-20-LeetCode-2-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%EF%BC%88TopK%EF%BC%89/%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E5%A4%A7%E9%A1%B6%E5%A0%86.gif" alt="pic0x1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆,or we can do it like this:</span></span><br><span class="line">        <span class="comment">// Collections.reverseOrder()</span></span><br><span class="line">        <span class="comment">//PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">            <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123; <span class="comment">//Queue.peek()返回堆顶最大元素（不删除），空堆返回null</span></span><br><span class="line">                heap.offer(e); <span class="comment">//Queue.offer()插入元素e，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll(); <span class="comment">// Queue.poll()推出堆顶最大元素作为返回值，空堆返回null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123; <span class="comment">//遍历堆</span></span><br><span class="line">            res[j++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>TopK</tag>
        <tag>快速选择</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>In just 24 hours, US coronavirus cases soar by more than 40%</title>
    <url>/2020/03/19/In-just-24-hours-US-coronavirus-cases-soar-by-more-than-40/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #1 两数之和「twoSum」 0x0</title>
    <url>/2020/03/19/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%8CtwoSum%E3%80%8D%200x0/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。而且，你不能重复利用这个数组中同样的元素。</p>
</blockquote>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<hr>
<h3 id="Java-HashMap-method"><a href="#Java-HashMap-method" class="headerlink" title="Java HashMap method"></a>Java HashMap method</h3><p>key: target - nums[v]<br>value: v<br>每次迭代，判断nums[v]在不在hashmap中。<br>如果在，则nums[v]一定是之前target - nums[index_before]的值。此时返回{index_before, v}；<br>如果不在，则把key: target - nums[v]和value: v放到hashmap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Java HashMap method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; nums.length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.get(nums[v]) != <span class="keyword">null</span>) &#123; <span class="comment">//found value what is index v</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashMap.get(nums[v]), v&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(target - nums[v], v); <span class="comment">//found nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-time-for-loop"><a href="#2-time-for-loop" class="headerlink" title="2 time for loop"></a>2 time for loop</h3><p>注意到数组中同样元素不可重复利用，意思是某元素不能和自己相加和target比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   2 7 11 15</span><br><span class="line">2  x</span><br><span class="line">7    x</span><br><span class="line">11     x</span><br><span class="line">15        x</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i] + nums[j] == target) &amp;&amp; (i != j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈java的static关键字</title>
    <url>/2020/03/14/%E6%B5%85%E8%B0%88java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><h3 id="Why-we-have-to-use-a-static-key-word"><a href="#Why-we-have-to-use-a-static-key-word" class="headerlink" title="Why we have to use a static key word?"></a>Why we have to use a <code>static</code> key word?</h3><p>一般来说，要想引用类成员变量、使用类方法或者分配存储空间，需要创建一个对象。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用类变量，注意到st1.i和st2.i指向同一存储空间，具有相同值47</span></span><br><span class="line">Class StaticTest &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">st1.i</span><br><span class="line">st2.i</span><br><span class="line"><span class="comment">//使用类方法</span></span><br><span class="line">Class Incrementable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Incrementable sf = <span class="keyword">new</span> INcrementable();</span><br><span class="line">sf.increment;</span><br></pre></td></tr></table></figure>
<p>那么，如果我们遇到特殊需求。比如我们希望为特定域（field）分配单一存储空间，而不去考虑究竟需要创建多少对象，甚至不用创建对象；再比如我们希望某个方法不与包含它的类的对象相关联，就是说，可以不用创建对象而使用方法。</p>
<p>此时，我们可以使用<code>static</code>关键字。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="How-do-we-use-static"><a href="#How-do-we-use-static" class="headerlink" title="How do we use static"></a>How do we use <code>static</code></h3><p>当声明一个事物是static时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起。</p>
<p>回顾上述两个类，我们可以声明类变量<code>i</code>和类方法<code>increment()</code>是<code>static</code>，再直接使用类名引用它们:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class StaticTest &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不必创建对象而使用i</span></span><br><span class="line">StaticTest.i++</span><br><span class="line"><span class="comment">//不必创建对象而使用方法</span></span><br><span class="line">Class Incrementable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Incrementable <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//另一个广为人知的例子  wow, that was epic.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><blockquote>
<ul>
<li>类中<code>static</code>方法不能访问非<code>static</code>变量。</li>
<li>类中<code>static</code>方法不能使用<code>this</code>关键字。<br>原因就是<code>Static</code>方法是类方法，先于任何的实例（对象）存在。即<code>Static</code>方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成。</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li>声明为<code>static</code>的事物也可以用前文所述常规方法引用。</li>
<li>通过类名直接引用是引用<code>static</code>事物的首选方式，这不仅是因为它强调了事物的<code>static</code>结构，而且在某些情况下它还为编译器进行优化提供了更好的机会。</li>
</ul>
</blockquote>
<p><em>总结自《Thinking in Java 4th edition》P29 - P30</em></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>[Daily Readings]  Trump address sparks chaos as coronavirus crisis deepens</title>
    <url>/2020/03/12/Trump-address-sparks-chaos-as-coronavirus-crisis-deepens/</url>
    <content><![CDATA[<hr>
<p>(CNN)President Donald Trump set out to steady a rattled nation and a diving economy in a solemn Oval Office address, but instead sowed more confusion and doubts that he is up to handling the fast-worsening coronavirus crisis.</p>
<ul>
<li>set out to着手；steady稳定；rattled nation摇摇欲坠的；solemn庄严的；sowed引起了；fast-worsening快速恶化的</li>
</ul>
<p>Trump spoke to the nation at a fearful moment, when the rhythms of everyday American life are starting to shut down – with schools closing, the NBA suspended, hospitals on high alert and movie icon Tom Hanks saying he and his wife have the disease.</p>
<ul>
<li>rhythms节奏</li>
</ul>
<p>“The virus will not have a chance against us. No nation is more prepared or more resilient than the United States,” the President said, before painting a rosy picture of an economy that is already taking a beating from the virus fallout. </p>
<ul>
<li>resilient弹性的；before painting a rosy picture of an economy在描绘经济乐观的面纱之前；beating打击；fallout辐射，影响</li>
</ul>
<p>The New York Stock Exchange halted trading for 15 minutes after the S&amp;P 500 fell 7% on Thursday morning.</p>
<ul>
<li>stock证券，股票；halt停止</li>
</ul>
<p>The President unveiled several measures to help on that score, to help workers who lack sick pay but have to self-isolate and are hard-hit by shutdowns, though his call for a payroll tax cut is not popular in Congress.</p>
<ul>
<li>unveil公布，揭幕；measure措施；on that score实现那目标；sick pay病假工资；self-isolate自我隔离；shutdown停工；payroll工资单；congress国会</li>
</ul>
<p>Trump’s big announcement for keeping the virus at bay – what he said was a 30-day ban on travel to the US by Europeans and restrictions on cargo – was immediately engulfed in confusion.</p>
<ul>
<li>bay绝路；engulf吞噬</li>
</ul>
<p>The President later rushed to clarify on Twitter that he was stopping travel and not trans-Atlantic trade in goods, and officials said his plan did not apply to Americans or US permanent residents – though such travelers would face mandatory quarantines.</p>
<ul>
<li>apply to适用于；mandatory强制性的；quarantine隔离检疫</li>
</ul>
<p>“The restriction stops people not goods,” Trump tweeted after his speech.</p>
<p>Trump also caused a muddle when he said he had convinced health insurance providers to waive all copayments for coronavirus treatments.</p>
<ul>
<li>muddle混乱；convince说服；waive放弃；copayment自付费用</li>
</ul>
<p>A White House official later said the President had meant to say that the copayments would be waived for coronavirus tests – but would still apply to treatments for the disease.</p>
<p>On Thursday morning, Vice President Mike Pence defended Trump’s presentation.</p>
<ul>
<li>Vice President副总统；defend辩护</li>
</ul>
<p>“I don’t think there’s confusion,” Pence said on CNN’s “New Day,” praising the President for taking another historic step to suspend all travel from Europe … for the next 30 days.</p>
<ul>
<li>praise称赞</li>
</ul>
<p>Pence then announced that “Americans coming home will be funneled through 13 different airports,” and would be screened at those airports.</p>
<ul>
<li>funnel [v]漏进 [n]漏斗；screen[v]遮掩</li>
</ul>
<p>“Then we’re going to ask every American and legal resident returning to the United States to self-quarantine for 14 days,” he said.</p>
<p>European Union leaders said Thursday they disapprove of Trump’s decision.</p>
<ul>
<li>disapprove不赞同</li>
</ul>
<p>In a statement, the Presidents of the European Council and the European Commission, Charles Michel and Ursula von der Leyen, respectively, said that the outbreak is a “global crisis, not limited to any continent and it requires cooperation rather than unilateral action.”</p>
<ul>
<li>respectively分别地；outbreak[n]发病；continent大陆；’u[ju]nilateral单方面的</li>
</ul>
<p>“The European Union disapproves of the fact that the US decision to impose a travel ban was taken unilaterally and without consultation,” the statement read.</p>
<ul>
<li>impose强加；consultation协商</li>
</ul>
<h4 id="Sowing-confusion"><a href="#Sowing-confusion" class="headerlink" title="Sowing confusion"></a>Sowing confusion</h4><p>The confusion was symptomatic of an administration that has often struggled to frame detailed policies and present them coherently. Trump’s top assignment on Wednesday was to show that he was in charge and that he appreciated, finally, the grave nature of the weeks that lie ahead. But the confusion over the travel ban turned his speech into something of a debacle and may up exacerbating uncertainty over his leadership.</p>
<ul>
<li>symptonatic征兆；administration行政部门；struggle努力；frame[v]制定；co’he[i]rently连贯地；assignment任务，分配；grave严重；nature性质；weeks lie ahead未来几周；de[i]’ba[a]cle崩溃；e’xacerbate加剧，恶化；</li>
</ul>
<p><u>And his travel ban announcement was made apparently without consultation with the travel industry or US allies and seems set to cause massive disruption that will deepen already cascading economic damage unleashed by the crisis.</u></p>
<ul>
<li>disruption破坏；deepen加深；cascading一系列的，级联；unleash发动</li>
</ul>
<p>The move could cause mass cancellation of trans-Atlantic flights, which could throw the aviation industry into a moment of existential challenge. Trump acted after Italy, which has now recorded over 12,000 cases, experienced <u>a record jump in confirmed infections with 2,313 on Wednesday.</u></p>
<ul>
<li>aviation航空；infection感染；a record jump in confirmed infection with 2,313 on Wednsday周三确认感染病例达到创纪录的2313例</li>
</ul>
<p>US Travel Association President and CEO Roger Dow called on Trump to <u>match his aggressive action with equally bold moves</u> to shore up the travel industry.</p>
<ul>
<li>call on呼吁；aggressive积极的；bold大胆的；shore up支撑</li>
</ul>
<p>“Temporarily shutting off travel from Europe is going to exacerbate the already-heavy impact of coronavirus on the travel industry and the 15.7 million Americans whose jobs depend on travel,” Dow said in a statement. The Association said that 850,000 international visitors flew to the US from parts of Europe other than the UK in March 2019 and spent around $3.4 billion in this country.</p>
<ul>
<li>other than以外</li>
</ul>
<p>Such figures will do nothing to quell investor panic after Wall Street on Wednesday dipped into a bear market. For example, Dow Futures plunged more than 1,000 points after Trump’s speech, despite the President’s arguments the strong US economy will emerge from the crisis unscathed.</p>
<ul>
<li>figures数字；quell平息；dip into浸入；bear market熊市; plung[dʒ]e暴跌；despite尽管；argument观点；emerge摆脱困境，出现；unscathed毫发无损地</li>
</ul>
<p>“This is not a financial crisis. This is just a temporary moment of time that we will overcome together as a nation and as a world,” Trump said in his address.</p>
<ul>
<li>address讲话</li>
</ul>
<p>US stocks sold off sharply for the second straight day on Thursday, after Trump’s announcement. Wall Street investors are worried about the scale of the coronavirus pandemic and its economic consequences.</p>
<ul>
<li>sold off跌价；second straight day连续第二天；pan’demic（全球性的）流行病；concequence后果</li>
</ul>
<p>On a more fundamental level, the travel ban plan raised basic questions about the President’s understanding of a crisis he has minimized, blamed on Democrats and predicted will just go away soon.</p>
<ul>
<li>fundamental根本的；raise提出；blamed on归咎于；’Demo[ə]crats民主党人；predict预计</li>
</ul>
<p>Department of Homeland Security guidance suggested the restrictions exempted US nationals and permanent residents, who would face quarantine when they came home. And the President did not explain why his ban did not include citizens of the UK – where the virus has also taken root.</p>
<ul>
<li>guidance指导；restriction限制；exempt豁免；</li>
</ul>
<p><u>But the biggest problem facing the US is not more cases of coronavirus coming from Europe</u> – it is that the disease has taken root on US soil itself by community spread.</p>
<p>Pressing issues now revolve around how Americans should respond to the situation and to what extent they should change their daily patterns. Trump did advise halting nonessential visits to care homes for the elderly – the highest risk group from the virus.</p>
<ul>
<li>pressing issue紧迫的问题；revolve围绕；respond to应对；extent程度；pattern模式；daily pattern生活习惯；nonessential不必要的；</li>
</ul>
<p><u>But he didn’t explain how he would alleviate what health officials fear will be a crowding of hospitals</u>, the continuing lack of proper testing or the coming strain on resources such as breathing machines needed to keep the sickest patients alive.</p>
<ul>
<li>alleviate缓解；the continuing lack持续缺乏；proper合适的；strain紧张，压力</li>
</ul>
<p>He argued that the threat was still “very low” for all but the old and infirm, on a day when one of his top public health officials, Dr. Anthony Fauci, predicted the current scenario – with more than 1,200 people sick in the US and 38 dead, is “going to get worse.”</p>
<ul>
<li>infirm体弱的；predict预测；sce[ə]’na[æ]rio情景；</li>
</ul>
<p>Local officials in some hard-hit areas are meanwhile warning that failures in the federal response are making the situation worse.</p>
<ul>
<li>hard-hit area重灾区；federal联邦政府；response应对措施；</li>
</ul>
<p><u>The mayor of Seattle, Jenny Durkan, said that a lack of testing kits earlier in the pandemic that continues to this day was preventing patients getting the treatment they needed and officials from understanding the community spread of the disease.</u> She told CNN’s Don Lemon that stringent measures to restrict public gatherings and close schools were therefore vital to saving lives.</p>
<ul>
<li>mayor市长；prevent阻止；stringent严格的；measure措施；vital重要的</li>
</ul>
<p>“By doing some modeling and looking at the tests, (scientists) calculate that if we didn’t take the kind of actions that the governor and I and the executives announced today, that by April 7th, we would have over 25,000 cases in the city of Seattle in this region. And 400 deaths,” Durkan said.</p>
<ul>
<li>executive高管</li>
</ul>
<h4 id="Trump-speech-likely-to-split-the-nation"><a href="#Trump-speech-likely-to-split-the-nation" class="headerlink" title="Trump speech likely to split the nation"></a>Trump speech likely to split the nation</h4><p>To Trump’s supporters, his address likely came across as a decisive and bold move to face up to a national challenge.</p>
<ul>
<li>come across给人以印象；de’ci[aɪ]sive果断的；bold大胆的；</li>
</ul>
<p>But to critics it followed a familiar playbook – as he blamed others for the crisis, basked in self-congratulation and xenophobia, and misled the country about his actions so far.</p>
<ul>
<li>critic批评者；playbook剧本；bask沐浴阳光；xe[ze]no’phobia排外主义；mis’led误导</li>
</ul>
<p>“This is the most aggressive and comprehensive effort to confront a foreign virus in modern history,” Trump said, misrepresenting his own and his administration’s catalog of missteps.</p>
<ul>
<li>comprehensive全面的；confront对抗；misrepresent歪曲；catalog of missteps让自己处于尴尬境地的list</li>
</ul>
<p>The President did not mention, for example, the shortage of testing kits, which means officials cannot even get a strong read on how far the disease has spread across the nation.</p>
<ul>
<li>get a strong read好好理解一下</li>
</ul>
<p>Presidents use Oval Office addresses in moments of extremis, to bind Americans together to confront a challenge that threatens their collective security.</p>
<ul>
<li>in extremis | in an extremely difficult situation；bind捆绑；collective集体的</li>
</ul>
<p>But Trump’s toneless, almost resentful address as he faces a challenge from outside that could threaten his reelection hopes is unlikely to fulfill the soaring mission of the presidency.</p>
<ul>
<li>toneless无言；resentful不满的；reelection连任；full’fill完成；soaring高涨的；presidency任期</li>
</ul>
<p>His central remedy – blaming China, where the crisis was spawned, and Europe for becoming afflicted with it – was consistent with his political mantra of demonizing foreigners.</p>
<ul>
<li>re[e]me[ə]dy补救方法；afflict折磨；consistent一致的；mantra口头禅；’de[i]monize妖魔化</li>
</ul>
<p><u>The idea that a virus that affects all humans and is a naturally occurring force was some kind of foreign-brewed threat sent to attack Americans is in itself staggering in its conception.</u></p>
<ul>
<li>brew酿造；in itself本身，本质上；staggering相当震惊；</li>
</ul>
<p>The President did announce a raft of measures to support businesses and individuals with tax relief and low interest rates as the virus tightens its grip on the US.</p>
<ul>
<li>raft一系列的；measure措施；individual个体；relief救济；tighten束紧；grip | [n]a tight hold on something or someone</li>
</ul>
<p>But Trump’s plan to self-isolate the US from Europe appears to be a case of closing the stable door after the horse has bolted – the virus is already here and infecting more Americans by the day.</p>
<ul>
<li>bolt闩上</li>
</ul>
<h5 id="link-https-www-cnn-com-2020-03-12-politics-donald-trump-coronavirus-europe-travel-index-html"><a href="#link-https-www-cnn-com-2020-03-12-politics-donald-trump-coronavirus-europe-travel-index-html" class="headerlink" title="link: https://www.cnn.com/2020/03/12/politics/donald-trump-coronavirus-europe-travel/index.html"></a>link: <a href="https://www.cnn.com/2020/03/12/politics/donald-trump-coronavirus-europe-travel/index.html" target="_blank" rel="noopener">https://www.cnn.com/2020/03/12/politics/donald-trump-coronavirus-europe-travel/index.html</a></h5>]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2020/03/12/Test-0/</url>
    <content><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="emmm-this-is-a-test-too"><a href="#emmm-this-is-a-test-too" class="headerlink" title="emmm this is a test , too."></a>emmm this is a test , too.</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/03/12/test/</url>
    <content><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="this-is-a-test"><a href="#this-is-a-test" class="headerlink" title="this is a test."></a>this is a test.</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>给您拜个晚年，祝您新的一年心明眼亮，百毒不侵</title>
    <url>/2020/03/07/%E7%BB%99%E6%82%A8%E6%8B%9C%E4%B8%AA%E6%99%9A%E5%B9%B4%EF%BC%8C%E7%A5%9D%E6%82%A8%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4%E5%BF%83%E6%98%8E%E7%9C%BC%E4%BA%AE%EF%BC%8C%E7%99%BE%E6%AF%92%E4%B8%8D%E4%BE%B5/</url>
    <content><![CDATA[<h1 id="给您拜个晚年，祝您新的一年心明眼亮，百毒不侵"><a href="#给您拜个晚年，祝您新的一年心明眼亮，百毒不侵" class="headerlink" title="给您拜个晚年，祝您新的一年心明眼亮，百毒不侵"></a>给您拜个晚年，祝您新的一年心明眼亮，百毒不侵</h1><h2 id="一点感悟"><a href="#一点感悟" class="headerlink" title="一点感悟"></a>一点感悟</h2><h3 id="知乎有提问，新冠蔓延能带来哪些正面意义。"><a href="#知乎有提问，新冠蔓延能带来哪些正面意义。" class="headerlink" title="知乎有提问，新冠蔓延能带来哪些正面意义。"></a>知乎有提问，新冠蔓延能带来哪些正面意义。</h3><h3 id="当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？"><a href="#当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？" class="headerlink" title="当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？"></a>当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？</h3><h3 id="这他妈是灾难-ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。"><a href="#这他妈是灾难-ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。" class="headerlink" title="这他妈是灾难,ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。"></a>这他妈是灾难,ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。</h3><h3 id="惊蛰刚过，我仿佛已经看见万物复苏。祝好！"><a href="#惊蛰刚过，我仿佛已经看见万物复苏。祝好！" class="headerlink" title="惊蛰刚过，我仿佛已经看见万物复苏。祝好！"></a>惊蛰刚过，我仿佛已经看见万物复苏。祝好！</h3>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>新冠</tag>
      </tags>
  </entry>
</search>
