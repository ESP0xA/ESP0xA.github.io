<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构模板</title>
    <url>/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>详尽地记录了各种数据结构模板，以及一些个人理解。</p>
<a id="more"></a>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="何为单链表"><a href="#何为单链表" class="headerlink" title="何为单链表"></a>何为单链表</h3><p>首先什么是链表呢，链表是一堆离散的结点，每个结点存了两个值，一个表示结点的数值，一个是next指针，它指向了下一个结点的位置。链表是一个递归的数据结构（俄罗斯套娃），如果给我们一个链表的头结点，我们可以遍历整个链表。可以认为链表某结点的next指针指向了其后面整个链表。<br>一个链表结点可以形象地看成：<br>[value]<br>[next ]<br>用数组模拟链表，一定要理解其本质。</p>
<h3 id="数组模拟链表的本质"><a href="#数组模拟链表的本质" class="headerlink" title="数组模拟链表的本质"></a>数组模拟链表的本质</h3><p>我们用一个数组A来存储数值，一个数组B来存储指针。一个链表结点分别由同一下标的两个数组元素构成。因为是用数组模拟链表，所以结点的指针用数组下标表示。<br>从0开始遍历两个数组，0代表第0次插入操作，每一次向链表中新插入数值，下标后移一位，相当于new一个新的结点。但是当删除操作时，下标不会移动。也就是说，删除结点时，结点依然在数组中，只是链表不会指向它。<br>另外，需要一个下标来表示整个链表的头结点，注意，头结点不一定在0位置（可能会在头结点前面插入新的结点）。<br>为什么要有头结点下标呢？这样可以很方便地对整个链表遍历，也很方便地在头结点出进行插入和删除操作。</p>
<h3 id="单链表模板"><a href="#单链表模板" class="headerlink" title="单链表模板"></a>单链表模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>题目链接：</strong> <a href="https://fingerdance.plus/2020/11/12/AcWing-826-单链表/" target="_blank" rel="noopener">Acwing 826.单链表</a></p>
          </div>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h2 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h2><h2 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h2><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>和双指针思想类似，单调栈也是利用已知的某种性质，对暴力方法进行优化。</p>
<h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
        <tag>字符串</tag>
        <tag>算法模板</tag>
        <tag>AcWing</tag>
        <tag>单链表</tag>
        <tag>双链表</tag>
        <tag>队列</tag>
        <tag>循环队列</tag>
        <tag>单调队列</tag>
        <tag>滑动窗口</tag>
        <tag>KMP</tag>
        <tag>Trie树</tag>
        <tag>并查集</tag>
        <tag>一般哈希</tag>
        <tag>字符串哈希</tag>
        <tag>C++ STL</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectNowCoder学习笔记</title>
    <url>/2020/09/04/ProjectNowCoder%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录ProjectNowCoder学习过程中的一些重点。</p>
<a id="more"></a>
<h2 id="第一章-开发工具和Java语言介绍"><a href="#第一章-开发工具和Java语言介绍" class="headerlink" title="第一章 开发工具和Java语言介绍"></a>第一章 开发工具和Java语言介绍</h2><p>略</p>
<h2 id="第二章-Spring入门和模板语法"><a href="#第二章-Spring入门和模板语法" class="headerlink" title="第二章 Spring入门和模板语法"></a>第二章 Spring入门和模板语法</h2><h3 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h3><p><img src="project_structure.jpg" alt="project_structure"></p>
<blockquote>
<ul>
<li>pom文件记录了项目依赖的所有包。<br>当我们第一次打开项目时，会loading很久，是因为编译器正在导入pom文件中的包所依赖的其他jar包。</li>
<li><code>java</code>目录下是项目源代码。<br>包括处理url请求的<code>controller</code>、程序入口<code>ProjectxApplication</code></li>
<li><code>resources</code>目录下是项目资源文件<br>包括静态的<code>css</code>，<code>js</code>代码、图片文件等，这些放在<code>static</code>目录下。<br>templates目录下是项目使用的模板，写的一般是<code>html</code>代码。</li>
<li><code>test</code>是测试目录</li>
</ul>
</blockquote>
<h3 id="2-2-一个简单demo"><a href="#2-2-一个简单demo" class="headerlink" title="2.2 一个简单demo"></a>2.2 一个简单demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(map = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很简单的一个demo，它实现了在访问<code>localhost:8080/</code>或者<code>localhost:8080/index</code>时返回一个<code>Hello World</code>。<br>注意到<code>@RequestMapping(map = {&quot;/&quot;, &quot;/index&quot;})</code>：我们已经可以一窥SpingBoot的「依赖注入」端倪。</p>
<h4 id="2-2-1-指定HTTP请求方法"><a href="#2-2-1-指定HTTP请求方法" class="headerlink" title="2.2.1 指定HTTP请求方法"></a>2.2.1 指定HTTP请求方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(map = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;, method = &#123;Requstmethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样在访问<code>localhost:8080/</code>或者<code>localhost:8080/index</code>时只能通过HTTP的GET方法访问，当通过其他方法访问时会报错。在处理一些只需要提交数据的情况时，我们可以指定为HTTP请求方法为POST以避免不必要的数据拉取操作。</p>
<h4 id="2-2-2-HTTP-METHOD"><a href="#2-2-2-HTTP-METHOD" class="headerlink" title="2.2.2 HTTP METHOD"></a>2.2.2 HTTP METHOD</h4><blockquote>
<ul>
<li><code>GET</code> ：获取接口信息</li>
<li><code>HEAD</code> ：仅查看接口的<code>HTTP</code>的头</li>
<li><code>POST</code> ：提交数据到服务器</li>
<li><code>PUT</code> ：支持幂等性的<code>POST</code>。client对一个URI发送一个Entity，服务器在这个URI下如果已经有了一个Entity，那么此刻服务器应该替换成client重新提交的，也由此保证了<code>PUT</code>的 <strong>幂等性</strong> 。如果服务器之前没有Entity ，那么服务器就应该将client提交的放在这个URI下。</li>
<li><code>DELETE</code> ：删除服务器上的资源</li>
<li><code>OPTIONS</code> ：查看支持的方法</li>
</ul>
</blockquote>
<h3 id="2-3-路径和请求的参数传递"><a href="#2-3-路径和请求的参数传递" class="headerlink" title="2.3 路径和请求的参数传递"></a>2.3 路径和请求的参数传递</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/profile/&#123;groupId&#125;/&#123;userId&#125;"</span>&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span>         </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">profile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> <span class="keyword">int</span> uId,                                                   <span class="comment">// 1 </span></span></span><br><span class="line"><span class="function">                      @<span class="title">PathVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String gId,                                               <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">                      @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"type"</span>, defaultValue = <span class="string">"1"</span>, required = <span class="keyword">false</span>)</span> <span class="keyword">int</span> type,      <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">                      @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"key"</span>, defaultValue = <span class="string">"zz"</span>, required = <span class="keyword">false</span>)</span> String key) </span>&#123;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Profile Page of %d who belong to %s; "</span> +</span><br><span class="line">            <span class="string">"Type: %d Key: %s"</span>, uId, gId, type, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>profile</code>方法实现了当访问：<br><code>http://localhost:8080/profile/admins/001?type=1&amp;key=add</code><br>时返回：</p>
<blockquote>
<p><strong>Profile Page of 1 who belong to admins; Type: 1 Key: add</strong></p>
</blockquote>
<blockquote>
<ul>
<li><ol>
<li>路径参数传递。将url中的路径参数通过框架解析到方法中。</li>
</ol>
</li>
<li><ol start="2">
<li>请求参数传递。将url中的请求参数通过框架解析到方法中。</li>
</ol>
</li>
<li>&emsp; 注意默认值的用法：<code>defaultValue</code>是参数的默认值，在url未指定该值时使用它。<code>required</code>标明是否需要参数，默认为是。如果在默认状态下url未指定参数，则报错；如果设置成 <code>false</code>，则一旦参数缺失，则被指定为null。</li>
</ul>
</blockquote>
<h3 id="2-4-通过模板返回"><a href="#2-4-通过模板返回" class="headerlink" title="2.4 通过模板返回"></a>2.4 通过模板返回</h3><p>注意到2.2的demo我们用<code>@ResponseBody</code>修饰方法时，方法会以字符串方式返回”Hello World”。可以去掉这个<code>@ResponseBody</code>让方法通过框架返回一个模板。<br>一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/template"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">template</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"template"</span>;                     <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/main/resources/templates目录中的template.html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">hello this is a template</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在src/main/resources/templates目录中的application.properties中添加：<br><code>spring.freemarker.suffix= .html</code><br>这样可以让框架默认方法返回的模板后缀为html。注意到在注释1处是<code>return &quot;template&quot;;</code>。</p>
<h3 id="2-5-FreeMarker模板语法"><a href="#2-5-FreeMarker模板语法" class="headerlink" title="2.5 FreeMarker模板语法"></a>2.5 FreeMarker模板语法</h3><p>通过<code>Model</code>对象的<code>addAttribute()</code>方法向模板传递参数。<br>查看Model.class的反编译文件，注意到<code>Model</code>类属于springMVC中ui的框架，就是那个View：<br><code>package org.springframework.ui;</code><br>查看<code>addAttribute()</code>的反编译文件，注意到<code>addAttribute()</code>方法可以接收两个参数：<br><code>Model addAttribute(String var1, @Nullable Object var2);</code></p>
<blockquote>
<ul>
<li><code>String</code>类型变量为后端变量传递到前端时使用的变量</li>
<li><code>object</code>类型变量为后端变量</li>
</ul>
</blockquote>
<h4 id="2-5-1-简单参数传递"><a href="#2-5-1-简单参数传递" class="headerlink" title="2.5.1 简单参数传递"></a>2.5.1 简单参数传递</h4><p>下面是向模板传递<code>String</code>类型变量的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向welcome.html模板传递参数并且返回模板</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/welcome"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"tValue"</span>, <span class="string">"Wow!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"welcome"</span>; <span class="comment">//welcome.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    $&#123;tValue&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>后端的<code>String</code>类型变量<code>Wow!</code>会被传递到前端，并且在前端用<code>tValue</code>表示。<br>在FreeMarker模板语法中，<code>${}</code>中写入后端参数即可传递参数。<br>以上实现了在访问<code>http://localhost:8080/welcome</code>时显示</p>
<blockquote>
<p>Wow!<br>如果变量在后端中不存在则报错。在<code>$</code>和<code>{}</code>中加入任意字段则不会传递参数，全部会被当成文本解析。</p>
</blockquote>
<h4 id="2-5-2-复杂参数传递"><a href="#2-5-2-复杂参数传递" class="headerlink" title="2.5.2 复杂参数传递"></a>2.5.2 复杂参数传递</h4><h5 id="2-5-2-1-传递List"><a href="#2-5-2-1-传递List" class="headerlink" title="2.5.2.1 传递List:"></a>2.5.2.1 传递List:</h5><ol>
<li><p>通过<code>List</code>的<code>toString()</code>方法将<code>List</code>变量以<code>String</code>类型传递到前端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"tColors1"</span>, colors.toString());</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    $&#123;tColors1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p><strong>[RED, BLUE, GREEN]</strong></p>
</blockquote>
</li>
<li><p>直接将<code>List</code>对象传递给前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"tColors2"</span>, colors);</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors</span> <span class="attr">as</span> <span class="attr">x</span>&gt;</span></span><br><span class="line">        This is color $&#123;x?index&#125;: $&#123;x&#125; ,count: $&#123;x?counter&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>This is color 0: RED ,count: 1<br>This is color 1: BLUE ,count: 2<br>This is color 2: GREEN ,count: 3</p>
</blockquote>
</li>
</ol>
<h5 id="2-5-2-2-传递Map"><a href="#2-5-2-2-传递Map" class="headerlink" title="2.5.2.2 传递Map:"></a>2.5.2.2 传递Map:</h5><ol>
<li><p>一般是向模板传递map，再在模板中使用<code>${map?keys}</code>循环keySet迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), String.valueOf(i*i));</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"tMap"</span>, map);</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">tMap</span>?<span class="attr">keys</span> <span class="attr">as</span> <span class="attr">key</span>&gt;</span></span><br><span class="line">    key: $&#123;key&#125; - value: $&#123;tMap[key]&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>key: 0 - value: 0<br>key: 1 - value: 1<br>key: 2 - value: 4<br>key: 3 - value: 9</p>
</blockquote>
</li>
<li><p>甚至可以直接向模板传递一个<code>entrySet()</code>，接着在模板中迭代它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), String.valueOf(i*i));</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"tEntry"</span>, map.entrySet());</span><br></pre></td></tr></table></figure>
<p><strong>这里<code>${entry.key}</code>是直接调用了<code>Java</code>对象方法。</strong><br>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">tEntry</span> <span class="attr">as</span> <span class="attr">entry</span>&gt;</span>                 <span class="tag">&lt;<span class="name">#--</span> <span class="attr">ftl</span>语言<span class="attr">map</span>不能<span class="attr">get</span>一个<span class="attr">entry</span>，要想循环<span class="attr">entry</span> <span class="attr">set</span>得从后端传过来 <span class="attr">--</span>&gt;</span></span><br><span class="line">    key: $&#123;entry.key&#125; - value: $&#123;entry.value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span>                                <span class="tag">&lt;<span class="name">#--</span> 这个太神奇了 <span class="attr">--</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它也实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>key: 0 - value: 0<br>key: 1 - value: 1<br>key: 2 - value: 4<br>key: 3 - value: 9</p>
</blockquote>
</li>
</ol>
<h5 id="2-5-2-3-传递自定义对象"><a href="#2-5-2-3-传递自定义对象" class="headerlink" title="2.5.2.3 传递自定义对象:"></a>2.5.2.3 传递自定义对象:</h5><p>除了向模板传递List Map这类Java内置类对象外，还可以传递自定义类。<br>在..src\main\java\plus\fingerdance\projectx\model中创建User类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> plus.fingerdance.projectx.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Controller中加入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"ESP"</span>));</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">User: $&#123;user.name&#125;                            <span class="tag">&lt;<span class="name">#--</span> <span class="attr">1</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">Description:</span><br><span class="line">      $&#123;user.getDescription()&#125;                <span class="tag">&lt;<span class="name">#--</span> <span class="attr">2</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">      $&#123;user.description&#125;                     <span class="tag">&lt;<span class="name">#--</span> <span class="attr">3</span> <span class="attr">--</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它也实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>User: ESP<br>Description:<br>      This is ESP<br>      This is ESP</p>
</blockquote>
<blockquote>
<ul>
<li><ol>
<li>这里模板直接搜索后端Java类User中有没有类似于getxxx isxxx这类方法，接着调用它。</li>
</ol>
</li>
<li><ol start="2">
<li>这里模板是直接调用了Java类方法。</li>
</ol>
</li>
<li><ol start="3">
<li>同1。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="2-5-3-在模板中自定义变量"><a href="#2-5-3-在模板中自定义变量" class="headerlink" title="2.5.3 在模板中自定义变量"></a>2.5.3 在模板中自定义变量</h4><p>除了从后端传递参数到模板之外，还可以在模板中直接定义参数。<br>在…src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">title</span> = <span class="string">"NowCoder"</span>&gt;</span></span><br><span class="line">$&#123;title&#125;</span><br></pre></td></tr></table></figure>
<p>它也实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>NowCoder</p>
</blockquote>
<h4 id="2-5-4-模板的继承和引用"><a href="#2-5-4-模板的继承和引用" class="headerlink" title="2.5.4 模板的继承和引用"></a>2.5.4 模板的继承和引用</h4><p>可以在一个模板中引用其他模板，工程中一般用于多个页面存在相同部分时。比如网站的头部和尾部，不可能每个页面都写一个头一个尾。这时我们可以单独写一个头模板一个尾模板，接着我们只需要在每个需要用到它们的地方引用它们即可。<br>比如我们定义一个尾模板，在…\src\main\resources\templates中新建tail.html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Copyright 2020-2025 $&#123;title&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">All rights reserved.</span><br></pre></td></tr></table></figure>
<p>在…src/main/resources/templates/welcome.html中写入引用代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#include</span> "<span class="attr">tail.html</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>模板会自动引用tail.html，然后解析其中的变量。因为上文中已经在模板中定义了变量<code>title</code>，所以<br>在访问<code>http://localhost:8080/welcome</code>时页面尾端显示：</p>
<blockquote>
<p>Copyright 2020-2025 NowCoder<br>All rights reserved.</p>
</blockquote>
<p>引用单独的模板文件可以提高代码的复用性，类似地，自定义宏也可以实现这一特性。</p>
<h4 id="2-5-5-模板自定义宏（函数）"><a href="#2-5-5-模板自定义宏（函数）" class="headerlink" title="2.5.5 模板自定义宏（函数）"></a>2.5.5 模板自定义宏（函数）</h4><p>使用<macro>标签自定义一个宏，在标签中需要指明函数名，函数参数；在函数体中指明函数用法。<br>在…src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">render_color</span> <span class="attr">index</span> <span class="attr">color</span>&gt;</span>                   <span class="tag">&lt;<span class="name">#--</span> <span class="attr">1</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    Color Render Macro $&#123;index&#125;, $&#123;color&#125;           <span class="tag">&lt;<span class="name">#--</span> <span class="attr">2</span> <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>macro标签中指明了函数名<code>render_color</code>，以及函数的两个参数<code>index</code>和<code>color</code>。</li>
<li>函数体中指明了函数用法：当调用函数时，会显示这一行语句<code>Color Render Macro ${index}, ${color}</code>，其中，参数会被模板解析。</li>
</ol>
</blockquote>
<p>函数调用：<br>在…src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">@render_color</span> <span class="attr">index</span>=<span class="string">"$&#123;color?index&#125;"</span> <span class="attr">color</span>=<span class="string">"$&#123;color&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>Color Render Macro 0, RED<br>Color Render Macro 1, BLUE<br>Color Render Macro 2, GREEN</p>
</blockquote>
<p>使用宏的好处就是，我可以在多个页面调用它，而不必写重复代码。</p>
<h4 id="2-5-6-字符串拼接"><a href="#2-5-6-字符串拼接" class="headerlink" title="2.5.6 字符串拼接"></a>2.5.6 字符串拼接</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">hello</span> = <span class="string">"Hello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld1</span> = <span class="string">"$&#123;hello&#125; World ! [1]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld2</span> = <span class="string">'$&#123;hello&#125; World ! [2]'</span>&gt;</span></span><br><span class="line">$&#123;hello&#125;</span><br><span class="line">$&#123;helloworld1&#125;</span><br><span class="line">$&#123;helloworld2&#125;</span><br></pre></td></tr></table></figure>
<p>字符串变量<code>helloworld1</code>拼接了变量<code>hello</code>，但由于变量<code>helloworld2</code>使用了单引号<code>&#39;</code>，模板直接将内容解析为字符串，而并没有拼接变量<code>hello</code>。<br>在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>Hello<br>Hello World ! [1]<br>Hello World ! [2]</p>
</blockquote>
<h4 id="2-5-7-本节项目代码"><a href="#2-5-7-本节项目代码" class="headerlink" title="2.5.7 本节项目代码"></a>2.5.7 本节项目代码</h4><p>代码可能与上文略有出入，但主要体现在格式方面，不用在意这些细节。<br>..src\main\java\plus\fingerdance\projectx\controller\IndexController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以welcome.html模板的方式返回</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/welcome"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"tValue"</span>, <span class="string">"Wow!"</span>);</span><br><span class="line">        List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"tColors1"</span>, colors.toString()); <span class="comment">//不加toString会报错：意思就是期待一个String类型啥的，而你给的是一个sequence bla bla</span></span><br><span class="line">        model.addAttribute(<span class="string">"tColors2"</span>, colors);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            map.put(String.valueOf(i), String.valueOf(i*i));</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">"tMap"</span>, map);</span><br><span class="line">        model.addAttribute(<span class="string">"tEntry"</span>, map.entrySet());</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"ESP"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"welcome"</span>; <span class="comment">//welcome.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…\src\main\resources\templates\welcome.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Value:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        $&#123;tValue&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>List:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>list toString represent:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            $&#123;tColors1&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>list loop:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">x</span>&gt;</span></span><br><span class="line">                This is color $&#123;x?index&#125;: $&#123;x&#125; ,count: $&#123;x?counter&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Map:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>map keySet:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tMap</span>?<span class="attr">keys</span> <span class="attr">as</span> <span class="attr">key</span>&gt;</span></span><br><span class="line">                key: $&#123;key&#125; - value: $&#123;tMap[key]&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>map entrySet:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tEntry</span> <span class="attr">as</span> <span class="attr">entry</span>&gt;</span>                 <span class="tag">&lt;<span class="name">#--</span> <span class="attr">ftl</span>语言<span class="attr">map</span>不能<span class="attr">get</span>一个<span class="attr">entry</span>，要想循环<span class="attr">entry</span> <span class="attr">set</span>得从后端传过来 <span class="attr">--</span>&gt;</span></span><br><span class="line">                key: $&#123;entry.key&#125; - value: $&#123;entry.value&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">#list</span>&gt;</span>                                <span class="tag">&lt;<span class="name">#--</span> 这个太神奇了 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>User:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>User: $&#123;user.name&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Description:</span><br><span class="line">            $&#123;user.getDescription()&#125;</span><br><span class="line">            $&#123;user.description&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Customized value:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">title</span> = <span class="string">"NowCoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>$&#123;title&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Include template:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#include</span> "<span class="attr">tail.html</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Customized macro:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#macro</span> <span class="attr">render_color</span> <span class="attr">index</span> <span class="attr">color</span>&gt;</span></span><br><span class="line">            Color Render Macro $&#123;index&#125;, $&#123;color&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">color</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">@render_color</span> <span class="attr">index</span>=<span class="string">"$&#123;color?index&#125;"</span> <span class="attr">color</span>=<span class="string">"$&#123;color&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">hello</span> = <span class="string">"Hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld1</span> = <span class="string">"$&#123;hello&#125; World ! [1]"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld2</span> = <span class="string">'$&#123;hello&#125; World ! [2]'</span>&gt;</span></span><br><span class="line">    $&#123;hello&#125;</span><br><span class="line">    $&#123;helloworld1&#125;</span><br><span class="line">    $&#123;helloworld2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-Sping中的Request和Response对象"><a href="#2-6-Sping中的Request和Response对象" class="headerlink" title="2.6 Sping中的Request和Response对象"></a>2.6 Sping中的Request和Response对象</h3><h4 id="2-6-1-Request对象"><a href="#2-6-1-Request对象" class="headerlink" title="2.6.1 Request对象"></a>2.6.1 Request对象</h4><p>Spring对Request和Response对象的一些参数有着很好的封装，可以通过参数方式获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request和respons对象</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/request"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requests</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String[] str = &#123;<span class="string">"request.getMethod(): "</span>, request.getMethod(),</span><br><span class="line">                    <span class="string">"request.getQueryString(): "</span>, request.getQueryString(),</span><br><span class="line">                    <span class="string">"request.getPathInfo(): "</span>, request.getPathInfo(),</span><br><span class="line">                    <span class="string">"request.getRequestURI(): "</span>, request.getRequestURI()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length; i ++ ) &#123;</span><br><span class="line">        sb.append(str[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以在访问<code>http://localhost:8080/request</code>时显示：</p>
<blockquote>
<p>request.getMethod(): GET<br>request.getQueryString(): null<br>request.getPathInfo(): null<br>request.getRequestURI(): /request</p>
</blockquote>
<p>我们还可以通过<code>request.getHeader()</code>获取请求头信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Enumeration&lt;String&gt; headerNames = request.getHeaderNames();headerNames.hasMoreElements();) &#123;</span><br><span class="line">    String name = headerNames.nextElement();</span><br><span class="line">    sb.append(name).append(<span class="string">":"</span>).append(request.getHeader(name)).append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sb</code>添加了如上信息后，会在访问<code>http://localhost:8080/request</code>时多显示如下信息：</p>
<blockquote>
<p>host: localhost:8080<br>connection: keep-alive<br>cache-control: max-age=0<br>upgrade-insecure-requests: 1<br>user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36 Edg/86.0.622.69<br>accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>sec-fetch-site: none<br>sec-fetch-mode: navigate<br>sec-fetch-user: ?1<br>sec-fetch-dest: document<br>accept-encoding: gzip, deflate, br<br>accept-language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6<br>cookie: Idea-510111fa=6e59ec78-c3df-46b6-9a42-f2f1d838f830; _ga=GA1.1.234834870.1604220367; _ga_23PFYL4751=GS1.1.1605340925.4.1.1605340955.0; JSESSIONID=E380D4FA65A20F296103B854C08FA844</p>
</blockquote>
<p>其中,cookie可以分开读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        sb.append(<span class="string">" Cookie:"</span> ).append(cookie.getName()).append(<span class="string">" Value:"</span>).append(cookie.getValue()).append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sb</code>添加了如上信息后，会在访问<code>http://localhost:8080/request</code>时多显示如下信息：</p>
<blockquote>
<p>Cookie:Idea-510111fa Value:6e59ec78-c3df-46b6-9a42-f2f1d838f830<br>Cookie:_ga Value:GA1.1.234834870.1604220367<br>Cookie:_ga_23PFYL4751 Value:GS1.1.1605340925.4.1.1605340955.0<br>Cookie:JSESSIONID Value:416A8479B0D9CE8C912E3B4AF710D850</p>
</blockquote>
<p>cookies的构成是很多组的<code>Cookie</code>和对应的<code>Value</code>，我们甚至可以通过注解的方式，直接读取cookies中的<code>Value</code>值。<br>在方法参数中加入注解<code>@CookieValue(&quot;JSESSIONID&quot;) String sessionId</code>获取<code>Cookie</code>为<code>JSESSIONID</code>对应的<code>Value</code>值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/request"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requests</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        @CookieValue(<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">sb.append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">sb.append(<span class="string">"COOKIEVALUE:"</span>).append(sessionId);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p><code>sb</code>添加了如上信息后，会在访问<code>http://localhost:8080/request</code>时多显示如下信息：</p>
<blockquote>
<p>COOKIEVALUE:416A8479B0D9CE8C912E3B4AF710D850</p>
</blockquote>
<h4 id="2-6-2-Response对象"><a href="#2-6-2-Response对象" class="headerlink" title="2.6.2 Response对象"></a>2.6.2 Response对象</h4><p>除了操作客户端向服务器请求的<code>Request</code>对象外，我们还可以操作服务器向客户端发送的<code>Response</code>对象。<br>向响应头中添加字段<code>nowcoderID:hello</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/request"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requests</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        @CookieValue(<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function">response.<span class="title">addHeader</span><span class="params">(<span class="string">"nowcoderID"</span>, <span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>在操作Response对象前需要先在函数参数中声明对象。如上会在访问<code>http://localhost:8080/request</code>时用F12浏览器调试页面看到响应头已经包含了我们添加的字段：</p>
<blockquote>
<p><strong>nowcoderID:</strong> hello</p>
</blockquote>
<p>另外我们还可以向响应头中添加cookies对象，例如，我们可以添加一组cookies：name:<code>username</code>, value:<code>nowcoder</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"username"</span>, <span class="string">"nowcoder"</span>));</span><br></pre></td></tr></table></figure>
<p>添加后会在访问<code>http://localhost:8080/request</code>时用F12浏览器调试页面看到响应头中已经添加了cookies：</p>
<blockquote>
<p><strong>Set-Cookie:</strong> username=nowcoder</p>
</blockquote>
<h3 id="2-7-重定向"><a href="#2-7-重定向" class="headerlink" title="2.7 重定向"></a>2.7 重定向</h3><p>重定向在工业中应用广泛。比如，一个网站制作了一个PC端网页<code>www.nowcoder.com</code>和一个手机端网页<code>m.nowcoder.com</code>，当服务器通过用户的UserAgent判断用户是使用了手机访问网页时，我们就可以让它跳转到手机端的网页。这样可以很好地提高用户体验。<br>再比如，网站新开发了一个网页，当我们已经将网页部署上线了，但是突然需要对网页做一个更改，又不能临时将网页下线。此时我们就可以为网页做一个跳转，跳转到更改之后部署的页面去。</p>
<h4 id="2-7-1-302临时跳转"><a href="#2-7-1-302临时跳转" class="headerlink" title="2.7.1 302临时跳转"></a>2.7.1 302临时跳转</h4><p>我们可以使用Spring框架为网站自定义跳转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//302临时性跳转</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect302</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回一个<code>&quot;redirect:/&quot;</code>这样当我们访问：<code>http://localhost:8080/redirect/113</code>时（<code>code</code>可以是任意整型变量），就会临时性地跳转到首页。</p>
<blockquote>
<p>Hello World</p>
</blockquote>
<p>我们可以设置在跳转时，通过<code>HttpSession</code>对象传递一个消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//302临时性跳转</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect302</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code,</span></span><br><span class="line"><span class="function">                        HttpSession httpSession) </span>&#123;</span><br><span class="line">    httpSession.setAttribute(<span class="string">"msg"</span>, <span class="string">" --jump from redirect"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为函数添加一个<code>HttpSession</code>对象作为参数，并且为该对象设置一个属性，该属性由一个<code>String</code>对象和一个<code>Object</code>对象构成。前者定义了消息的名称，后者为消息对象本身。<br>接着，我们给定义地首页的<code>index</code>方法设置一个<code>Httpsession</code>对象作为参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span> + httpSession.getAttribute(<span class="string">"msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当我们访问：<code>http://localhost:8080/redirect/113</code>时，会临时性地跳转到首页，并且将消息<code>--jump from redirect</code>传递到首页，首页会显示：</p>
<blockquote>
<p>Hello World –jump from redirect</p>
</blockquote>
<p>除了让方法通过返回<code>String</code>对象<code>&quot;redirect:/&quot;</code>的方式实现跳转之外，我们还可以让其返回<code>RedirectView</code>对象实现跳转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//302临时性跳转</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">redirect302</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code,</span></span><br><span class="line"><span class="function">                                HttpSession httpSession) </span>&#123;</span><br><span class="line">    httpSession.setAttribute(<span class="string">"msg"</span>, <span class="string">" --jump from redirect"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上302跳转的情况，我们事先打开浏览器F12控制台，在跳转之后会看到当前网页的网络状态码为<code>302</code>。</p>
<h4 id="2-7-2-301永久性跳转"><a href="#2-7-2-301永久性跳转" class="headerlink" title="2.7.2 301永久性跳转"></a>2.7.2 301永久性跳转</h4><p>除了设置302临时性跳转之外，我们还可以设置永久性跳转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//301 permanently moved</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">redirect301</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code,</span></span><br><span class="line"><span class="function">                                HttpSession httpSession) </span>&#123;</span><br><span class="line">    httpSession.setAttribute(<span class="string">"msg"</span>, <span class="string">" --jump from redirect"</span>);  </span><br><span class="line">    RedirectView red = <span class="keyword">new</span> RedirectView(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">301</span>) &#123;  <span class="comment">//当我们url的code填入301时，触发301跳转，否则为302跳转</span></span><br><span class="line">        red.setStatusCode(HttpStatus.MOVED_PERMANENTLY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依然是通过访问url的<code>/request/{code}</code>实现跳转，当我们访问的code为指定的<code>301</code>时，方法内部设置<code>RedirectView</code>的状态码为<code>301</code>，这样当我们访问：<code>http://localhost:8080/redirect/301</code>时，会永久性地跳转到首页，并且将消息<code>--jump from redirect</code>传递到首页，首页会显示：</p>
<blockquote>
<p>Hello World –jump from redirect</p>
</blockquote>
<p>并且当前网页状态码为：<code>301</code>。</p>
<h3 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h3><p>工业上写网站的时候，经常会用到异常处理。比如说对于有些不存在也页面，访问的时候会显示404 page not found，这其实就是一个统一的异常处理。<br>看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/admin"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.equals(<span class="string">"adminParameter"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不对"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExceptionHandler</span>()</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error:"</span> + e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个admin页面，访问这个页面需要提供一个参数。当我们提供的参数为<code>adminParameter</code>时，即当我们访问：<code>http://localhost:8080/admin?key=adminParameter</code>时页面返回一个:</p>
<blockquote>
<p>hello admin</p>
</blockquote>
<p>否则就抛出一个异常对象:</p>
<blockquote>
<p>error:参数不对</p>
</blockquote>
<p>我们另外在<code>error</code>函数中对异常进行统一的处理。</p>
<h3 id="2-9-IOC-aka-DI"><a href="#2-9-IOC-aka-DI" class="headerlink" title="2.9 IOC aka DI"></a>2.9 IOC aka DI</h3><h4 id="2-9-1-什么是IOC-DI"><a href="#2-9-1-什么是IOC-DI" class="headerlink" title="2.9.1 什么是IOC DI"></a>2.9.1 什么是IOC DI</h4><p>IOC，控制反转（Inversion of Contro）。<br>软件系统在没有引入IOC容器之前，比如说对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是 <strong>控制反转</strong> 这个名称的由来。</p>
<p>DI，依赖注入（Dependency Injection）。<br>控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。所以 <strong>控制反转</strong> 更合适的名字叫做 <strong>依赖注入</strong></p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<h4 id="2-9-2-举例"><a href="#2-9-2-举例" class="headerlink" title="2.9.2 举例"></a>2.9.2 举例</h4><p>在…/src/main/java/plus.fingerdance.projectx/service 目录下创建新的类<code>ProjectxService</code>。<br>注意要想能让IOC容器在别的地方注入这个类的对象，这里一定要有注解<code>@Service</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectxService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Message: "</span> + String.valueOf(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在…/src/main/java/plus.fingerdance.projectx/controller 目录下创建新的类<code>SettingController</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/setting"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setting</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Setting OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>ProjectxService</code>类，如果我们想在<code>IndexController</code>和<code>SettingController</code>两个类里同时使用，一般来说需要在两个地方各都<code>new</code>出来一个。<br>但是使用IOC的方式，我们只需在两个地方通过注解的方式让IOC容器帮我们注入进来。<br>在<code>SettingController</code>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>                                                                  <span class="comment">// IOC容器注入对象</span></span><br><span class="line">    ProjectxService projectxService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/setting"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setting</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Setting OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>IndexController</code>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>                                                                  <span class="comment">// IOC容器注入对象</span></span><br><span class="line">    ProjectxService projectxService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span> + httpSession.getAttribute(<span class="string">"msg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，不难注意到<code>httpSession</code>对象也是通过IOC容器注入的。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 789.数的范围</title>
    <url>/2021/02/07/AcWing-789-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二分查找模板题。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。</p>
<p><strong>输入格式</strong><br>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。</p>
<p><strong>输出格式</strong><br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。</p>
<p><strong>数据范围</strong><br>$ 1≤n≤100000 $<br>$ 1≤q≤10000 $<br>$ 1≤k≤10000 $</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3 4<br>5 5<br>-1 -1</p>
</blockquote>
<p>__</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, q, a[N], qry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; q--;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; qry;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt; qry) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[lo] == qry) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; lo &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            </span><br><span class="line">            lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; lo &lt; hi;) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = lo + hi + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[mid] &gt; qry) hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> lo = mid;</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; hi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">AcWing 789.数的范围</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1230.K倍区间[第八届蓝桥杯省赛B组]</title>
    <url>/2021/02/04/AcWing-1230-K%E5%80%8D%E5%8C%BA%E9%97%B4-%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9BB%E7%BB%84/</url>
    <content><![CDATA[<p><strong>摘要：</strong></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Git Cmd Line All-in-one</title>
    <url>/2021/01/30/Git-Cmd-Line-All-in-one/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>The Git Commands All-in-one</p>
<a id="more"></a>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote>
<p><code>git config -l</code><br>查看当前生效的配置信息<br><code>git config [--global|--system] -e</code><br>编辑配置文件，–global: 全局级， –system: 系统级，默认本地级<br><code>git config [--global|--system][--add]&lt;name&gt;&lt;value&gt;</code><br>设置单值或多值（–add）配置项<br><code>git config [--global|--system]--unset&lt;name&gt;</code><br>删除配置项<br><code>git config [--global|--system][--get-all]&lt;name&gt;</code><br>查询单值或多值（–get-all）配置项</p>
</blockquote>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><blockquote>
<p><code>git init [--bare]&lt;仓库路径&gt;</code><br>创建一个新仓库<br><code>git clone &lt;远程仓库网址&gt;[本地目录]</code><br>克隆远程仓库到本地</p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[GAME HACKING] 基于FOV的通用 world-to-screen 方法</title>
    <url>/2021/01/24/GAME-HACKING-%E5%9F%BA%E4%BA%8EFOV%E7%9A%84%E9%80%9A%E7%94%A8-world-to-screen-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>[GAME HACKING] 找ViewMatrix的一般方法</title>
    <url>/2021/01/19/GAME-HACKING-%E6%89%BEViewMatrix%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>总结了找游戏ViewMatrix的一般性方法。</p>
<a id="more"></a>

<h3 id="ViewMatrix结构："><a href="#ViewMatrix结构：" class="headerlink" title="ViewMatrix结构："></a>ViewMatrix结构：</h3><blockquote>
<p>它分为四行或四列.<br>四行中，第一行为Left(X)轴，第二行为Up(Y)轴，第三行为Forward(Z)轴，第四行为Translation(用于计算).</p>
</blockquote>
<h3 id="ViewMatrix的特性"><a href="#ViewMatrix的特性" class="headerlink" title="ViewMatrix的特性"></a>ViewMatrix的特性</h3><blockquote>
<ol start="0">
<li>pitch和yaw变化时, 矩阵中前三行绝大部分数字一定发生变化；反之一定不变。</li>
<li>前三行每个数字均在[-2, 2]之间</li>
<li>第三行每个数字均在[-1, 1]之间</li>
<li>第四行数字较大</li>
<li>当pitch在[-90, 90]范围内变化时，对应第三行（Forward行）某个数字在[-1, 1]范围内变化，他们具有良好的正相关性。</li>
<li>如果pitch变化，yaw保持不变，则第三行部分数字变化，前两行部分数字不变；反之，如果pitch保持不变，yaw发生变化，则第三行部分数字不变，前两行部分数字变化。</li>
<li>视角变小时（机瞄），第一行第一个数字的绝对值增大。</li>
<li>前三行后两位数字相同，矩阵中存在一个为0的数。（GTA5和Assault Cube已验证）</li>
</ol>
</blockquote>
<h3 id="利用以上特性搜索ViewMatrix地址"><a href="#利用以上特性搜索ViewMatrix地址" class="headerlink" title="利用以上特性搜索ViewMatrix地址"></a>利用以上特性搜索ViewMatrix地址</h3><blockquote>
<p>一般利用第4条特性，配合pitch的变化搜索第三行特定数字。注意这种方法搜到的数字并非matrix首位，需要在浏览内存区域时，先对齐数组，判断数组首位。</p>
<blockquote>
<p>搜索unknow initial value<br>改变pitch和yaw，搜索changed value<br>搜索value between -1 and 1<br>不断增加和减少pitch，分别搜索increased value和decreased value<br>将结果控制在几千个以内，删除非静态地址，在静态地址中进一步筛选。<br>注意到静态地址是分成一个个内存段的，对于每一个段，选择段首地址和段尾地址，浏览内存区域。<br>一般来说，view matrix存在在静态地址中跨度较大的段中。</p>
</blockquote>
</blockquote>
<blockquote>
<p>直接搜索矩阵第一个数字。</p>
<blockquote>
<p>搜索unknow initial value<br>改变pitch和yaw，搜索changed value<br>搜索value between -2 and 2<br>改变pitch和yaw，搜索changed value<br>保持pitch和yaw不变，搜索unchanged value<br>剩下和上面一致。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>GAME HACKING</tag>
        <tag>游戏外挂开发</tag>
        <tag>ViewMatrix</tag>
      </tags>
  </entry>
  <entry>
    <title>[GAME HACKING] 聊一聊Funtion Hook/Detour</title>
    <url>/2020/12/14/GAME-HACKING-%E8%81%8A%E4%B8%80%E8%81%8AFuntion-Hook-Detour/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>聊一聊游戏外挂开发中常用的HOOK技术。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* toHook: the memory address where we place the jmp</span></span><br><span class="line"><span class="comment">* ourFunct: the memory address where we place our function</span></span><br><span class="line"><span class="comment">* len: the numbers of bytes used by the instruction you're overwritting(typically 5 but deppending what we overwrrite it maybe more)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Hook</span><span class="params">(<span class="keyword">void</span> * toHook, <span class="keyword">void</span> * ourFunct, <span class="keyword">int</span> len)</span> </span>&#123;                        </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">5</span>) &#123;                                                          <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD curProtection;</span><br><span class="line">    VirtualProtect(toHook, len, PAGE_EXECUTE_READWRITE, &amp;curProtection);    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(toHook, <span class="number">0x90</span>, len);                                              <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    DWORD relativeAddress = ((DWORD)ourFunct - (DWORD)toHook) - <span class="number">5</span>;          <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    *(BYTE*)toHook = <span class="number">0xE9</span>;                                                  <span class="comment">// 5</span></span><br><span class="line">    *(DWORD*)((DWORD)toHook + <span class="number">1</span>) = relativeAddress;</span><br><span class="line"></span><br><span class="line">    DWORD temp;                                         </span><br><span class="line">    VirtualProtect(toHook, len, curProtection, &amp;temp);                      <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD jmpBackAddy;</span><br><span class="line"><span class="keyword">void</span> __declspec(naked) outFunct() &#123;                                         <span class="comment">// 7</span></span><br><span class="line">    _asm &#123;                                                                  <span class="comment">// 8</span></span><br><span class="line">        add ecx, ecx                                                        <span class="comment">// 9</span></span><br><span class="line">		mov edx, [ebp - <span class="number">8</span>]                                                  <span class="comment">// 10</span></span><br><span class="line">        jmp[jmpBackAddy]                                                    <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">MainThread</span><span class="params">(LPVOID param)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* the assembly lines where we are going to hook is looks like this :</span></span><br><span class="line"><span class="comment">		2B 4D 08      subecx, [ebp + 08]</span></span><br><span class="line"><span class="comment">		8B 55 F8      movedx, [ebp - 08]</span></span><br><span class="line"><span class="comment">		89 0A         mov[edx], ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> hookLength = <span class="number">6</span>;	<span class="comment">//There are 3 bytes(&lt; 5) in the first line, the hook funtion contains at least 1 `jmp` instrution(5 bytes) </span></span><br><span class="line">						<span class="comment">// so that the offset length should be at least 5. But if we are using 5, we can only override the first line</span></span><br><span class="line">						<span class="comment">// and part of second line.</span></span><br><span class="line">	DWORD hookAddress = <span class="number">0x8d2768</span>;	<span class="comment">// signature if this address: 2B 4D 08 8B 55 F8</span></span><br><span class="line">	jmpBackAddy = hookAddress + hookLength;</span><br><span class="line"></span><br><span class="line">	Hook((<span class="keyword">void</span>*)hookAddress, ourFunct, hookLength);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_ESCAPE)) <span class="keyword">break</span>;</span><br><span class="line">		Sleep(<span class="number">50</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FreeLibraryAndExitThread((HMODULE)param, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, MainThread, hModule, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>We check the length to be at least 5 bytes because this is the smallest relative jmp in x86. The instructions you will be destroying by overwriting will be at least 5 bytes. In a word, we have at least a <code>jmp</code> opcode at that address, and the <code>jmp</code> opcode is going to be at least 5 bytes;</li>
<li>We use VirtualProtect to take permissions of the memory we are overwriting.</li>
<li>We set the memory we’re ovewriting with 0x90 which is the NOP (no operationg) instruction, this is not 100% necessary but is a nice failsafe measure. While you’re debugging it’s also nice to watch the 0x90 get written so you know you’re doing the right thing in the right spot. We NOP the entire instruction by giving it the len argument.</li>
<li>Then we calculate the relative address between the destination and src address by subtracting them, we subtract len. The result of this calculation is the relative offset from the last byte we overwrote to the address of our function we are jumping to. Keep in mind, we are using a relative jump, not an absolute jump so this must be calculated at runtime.</li>
<li>Then we write 0xE9(byte code) which is the relative jmp instruction, then we add 1 byte(0xE9) so we can write the relative offset.</li>
<li>Then we use VirtualProtect to reset the page permissions to what they were before we modified them.</li>
<li>You have to execute your code inside a declspec naked function, you must preserve the registers and the stack so you don’t corrupt the stack of registers and you must execute the stolen bytes. Then you have to jump back to the src+len address.<br>The <code>__declspec(naked)</code> indicates that the function is going to be no epilogue and prologue. And we can write assembly code in it.</li>
<li>The <code>_asm</code> indicates no other assembly code but ours.</li>
<li>This line is our own code, which replaces the original one (<code>subecx, [ebp + 08]</code>) to <strong>add</strong> whole health value while pressing SPACE button;</li>
<li>The <code>hookLength</code> we are using(6) overrides the second assembly line although we don’t need to override to execute our code so that we have to re-write it;</li>
<li>After </li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>GAME HACKING</tag>
        <tag>游戏外挂开发</tag>
        <tag>HOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118.杨辉三角</title>
    <url>/2020/12/06/LeetCode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>简单模拟，简洁为上。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;                </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i ++ ) &#123;                               <span class="comment">// 1</span></span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(i + <span class="number">1</span>)</span></span>;                                         <span class="comment">// 2</span></span><br><span class="line">            row[<span class="number">0</span>] = row[i] = <span class="number">1</span>;                                            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++ ) &#123;                                 </span><br><span class="line">                row[j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];                 <span class="comment">// 4</span></span><br><span class="line">            &#125;           </span><br><span class="line">            res.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>依次处理每一行。</li>
<li>对于某一行，该行下标从 <code>0</code> 到 <code>i</code> ，故总数为 <code>i + 1</code>。</li>
<li>每一行的行首行末均为 <code>1</code> ，事先处理好它们。</li>
<li>根据上一行计算该行，其中，第 <code>0</code> 行和第 <code>1</code> 行因为仅包含行首行末，故不用处理，直接跳过。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">LeetCode 118.杨辉三角（Pascal’s Triangle）</a></p>
          </div>


]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>NowCoder.CD21 计算数组的小和 [程序员代码面试指南]</title>
    <url>/2020/12/06/NowCoder-CD21-%E8%AE%A1%E7%AE%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%8F%E5%92%8C-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>需要review</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组小和的定义如下：<br>例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；<br>在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27<br>给定一个数组s，实现函数返回s的小和<br>[要求]<br>时间复杂度为 <strong><em>O(nlogn)</em></strong>，空间复杂度为 <strong><em>O(n)</em></strong></p>
<p><strong>输入描述:</strong><br>第一行有一个整数N。表示数组长度<br>接下来一行N个整数表示数组内的数</p>
<p><strong>输出描述:</strong><br>一个整数表示答案</p>
<p><strong>示例1</strong></p>
<blockquote>
<p><strong>输入</strong><br>6<br>1 3 5 2 4 6</p>
</blockquote>
<blockquote>
<p><strong>输出</strong><br>27</p>
</blockquote>
<p><strong>备注:</strong></p>
<blockquote>
<p>$ 1 &lt;= N &lt;= 10^5 $,<br>$ -100 &lt;= arr_i &lt;= 100 $</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">209</span>], a, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt+=sum[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;<span class="number">209</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[x] += val;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            ans += getsum(a + <span class="number">102</span>);</span><br><span class="line">            add(a + <span class="number">102</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469?tpId=101&&tqId=33089&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">NowCoder.CD21 计算数组的小和 [程序员代码面试指南]</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>lowbit</tag>
        <tag>树状数组</tag>
        <tag>NowCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 659.分割数组为连续子序列</title>
    <url>/2020/12/04/LeetCode-659-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>利用了贪心的思想。（需要review）</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个按升序排序的整数数组 <code>num</code>（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。<br>如果可以完成上述分割，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入: [1,2,3,3,4,4,5,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3, 4, 5<br>3, 4, 5</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入: [1,2,3,4,4,5]<br>输出: False</p>
</blockquote>
<p><strong>提示：</strong></p>
<ol>
<li>输入的数组长度范围为 [1, 10000]</li>
</ol>
<hr>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>设想一个数组元素 <code>x</code> ，我们有两种选择，一是将 <code>x</code> 放到在以 <code>x - 1</code> 结尾的子序列中，二是新建一个以 <code>x</code> 开头的新序列。由于题干说明子序列长度至少为3，利用贪心的思想，我们尽可能地将 <code>x</code> 放到以 <code>x - 1</code> 结尾的序列中去，除非该序列不存在。那么当该序列不存在时，我们不得已新建一个序列，同时判断有没有 <code>x + 1</code> 和 <code>x + 2</code> 存在于 <code>x</code> 后面的数组中。如果都有，那么这个新序列将被建立，并且以 <code>x + 2</code> 结尾，如果不存在那么整个数组将无法分割。<br>就这样，我们遍历整个数组，对于每一个数 <code>x</code>， 要么加入到以 <code>x - 1</code> 结尾的序列中，要么新建一个新序列并判断 <code>x + 1</code> 和 <code>x + 2</code> 有无剩余。所有的新序列都从长度为3开始，只要出现不满足初始化新序列的情况，直接 <code>return false</code> ，否则遍历完数组均无不满足新序列成立的情况，<code>return true</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; remain;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; endcount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            remain[x] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain[x] &gt; <span class="number">0</span>) &#123;                                        <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">if</span> (endcount[x - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    remain[x] --;</span><br><span class="line">                    endcount[x - <span class="number">1</span>] --;</span><br><span class="line">                    endcount[x] ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (remain[x + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; remain[x + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        remain[x] --;</span><br><span class="line">                        remain[x + <span class="number">1</span>] --;</span><br><span class="line">                        remain[x + <span class="number">2</span>] --;</span><br><span class="line">                        endcount[x + <span class="number">2</span>] ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>因为之前在建立序列时，可能用到了 <code>x</code> ，所以在遍历到 <code>x</code> 时，剩余数量可能不会大于等于1；</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/" target="_blank" rel="noopener">LeetCode 659.分割数组为连续子序列</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>21天影响力倍增的人际沟通术学习笔记</title>
    <url>/2020/12/04/21%E5%A4%A9%E5%BD%B1%E5%93%8D%E5%8A%9B%E5%80%8D%E5%A2%9E%E7%9A%84%E4%BA%BA%E9%99%85%E6%B2%9F%E9%80%9A%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>课程《21天影响力倍增的人际沟通术》学习笔记。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>人际关系</tag>
        <tag>情商</tag>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 868.筛质数</title>
    <url>/2020/12/03/AcWing-868-%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>LeetCode 318.最大单词长度乘积</title>
    <url>/2020/12/02/LeetCode-318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>位运算记录字符串中字符。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>输出: 16<br>解释: 这两个单词为 “abcw”, “xtfn”。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br>输出: 4<br>解释: 这两个单词为 “ab”, “cd”。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: [“a”,”aa”,”aaa”,”aaaa”]<br>输出: 0<br>解释: 不存在这样的两个单词。</p>
</blockquote>
<hr>
<p>这道题的关键在于判断两个字符串有无公共字符。可以想到的方法有哈希集合，计数数组，以及位运算。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>这道题的字符串中仅有26个字母，可以用位运算方法记录下字符串中出现的字符。<br>对于一个字符，我们计算出它和 <code>a</code> 的偏移，将 <code>1</code> 左移这个偏移量，那么得到的二进制数就记录下了当前字符。那么，如何记录整个字符串的所有字符呢？<br>维护一个二进制数 <code>s</code> , 对于字符串中的每一个字符，用上述方法计算出对应的二进制数后，与 <code>s</code> 进行或运算，将每个字符相对 <code>a</code> 的偏移量累加地记录到 <code>s</code> 中。<br>判断两个字符串有无公共字符时，就可以直接让对应下标的二进制数进行与运算，为 <code>0</code> 则无公共字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;                                                                              </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span> : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">                s |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            state.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i ++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((state[i] &amp; state[j]) == <span class="number">0</span>) mx = <span class="built_in">max</span>(mx, (<span class="keyword">int</span>) (words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));     <span class="comment">// 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意在 <code>C++</code> 中 <code>string.size()</code> 返回值为 <code>unsinged long</code>。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/" target="_blank" rel="noopener">LeetCode 318.最大单词长度乘积（Maximum Product of Word Lengths）</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 316.去除重复字母</title>
    <url>/2020/12/02/LeetCode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道贪心题。（需要review）</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br>注意：该题与 1081 <a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：s = “bcabc”<br>输出：”abc”</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：s = “cbacdcbc”<br>输出：”acdb”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^4$</li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<hr>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>首先将每个字符最后出现的位置记录下来，维护一个答案字符串。对于原字符串的每一个字符，判断答案字符串的最后一个字符是否大于它。如果大于它，而且这个字符在后面出现过，那么这个字符就不是最优的，要剔除。如果小于，则直接放入答案字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stk;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; ins;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; last;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) last[s[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ins[s[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (; stk.<span class="built_in">size</span>() &amp;&amp; stk.back() &gt; s[i] &amp;&amp; last[stk.back()] &gt; i;) &#123;</span><br><span class="line">                ins[stk.back()] = <span class="literal">false</span>;</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            &#125; </span><br><span class="line">            stk += s[i];</span><br><span class="line">            ins[s[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">LeetCode 316.去除重复字母（Remove Duplicate Letters）</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 493.翻转对</title>
    <url>/2020/11/29/LeetCode-493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>归并排序模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>nums</code> ，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个重要翻转对。<br>你需要返回给定数组中的重要翻转对的数量。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [1,3,2,3,1]<br>输出: 2</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [2,4,3,5,1]<br>输出: 3</p>
</blockquote>
<p><strong>注意:</strong></p>
<ol>
<li>给定数组的长度不会超过$50000$。</li>
<li>输入数组中的所有数字都在32位整数的表示范围内。</li>
</ol>
<hr>
<h3 id="归并思想"><a href="#归并思想" class="headerlink" title="归并思想"></a>归并思想</h3><p>这道题和 <code>AcWing</code> 归并排序模板题<a href="https://www.acwing.com/problem/content/790/" target="_blank" rel="noopener">AcWing 788.逆序对的数量</a>非常类似，都是利用区间的单调性对pair的比较进行优化。<br>递归地划分整个数组区间。从最小两个数（或一个数）开始「归」或者叫回溯，在回溯过程中对数组当前的两个区间进行排序，维护它们的单调性，为上一层做准备。同时，在这个过程中另行维护两个指针 <code>i</code>, <code>j</code> , 分别处理两个片段。判断条件<code>nums[i] &gt; 2*nums[j]</code>。如果当前<code>nums[i] &gt; 2*nums[j]</code>，由于此时 <code>i</code> 所在区间是单调递增的，所以从 <code>i</code> 到区间结束的地方所有的数都满足这个条件；反之，移动 <code>i</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;                                                              <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.<span class="built_in">size</span>() + <span class="number">10</span>)</span></span>;</span><br><span class="line">        helper(nums, tmp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        helper(nums, tmp, l, mid), helper(nums, tmp, mid + <span class="number">1</span>, r);                   <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// backtrack</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;                                                     <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= r;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; (<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">2</span> * nums[j]) &#123;                                <span class="comment">// 4</span></span><br><span class="line">                res += mid - i + <span class="number">1</span>;                                                 <span class="comment">// 5</span></span><br><span class="line">                j ++;                                                                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i ++;                                                               <span class="comment">// 6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort                                                                     // 7</span></span><br><span class="line">        i = l, j = mid + <span class="number">1</span>;                                             </span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= r;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) tmp[t ++] = nums[j ++];</span><br><span class="line">            <span class="keyword">else</span> tmp[t ++] = nums[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid;) tmp[t ++] = nums[i ++];</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= r;) tmp[t ++] = nums[j ++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l, t = <span class="number">0</span>; i &lt;= r;) nums[i ++] = tmp[t ++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>因为题目给出数组长度不超过$50000$，所以有$49999!$个对数，显然结果最大超过 <code>int</code> 类型范围。</li>
<li>像二叉树遍历一样递归地将原数组一分为二。</li>
<li>维护两个指针分别处理两个片段。</li>
<li>因为 <code>2 * nums[j]</code> 可能会超出 <code>int</code> 类型最大可取值，所以需要强制转换成<code>long long</code>。</li>
<li>如果满足条件，那么由于片段内数组数字是单调递增的，所以从 <code>i</code> 起到片段结束都满足条件。接着移动j，因为j++后对应的数组数字增加，所以需要从 <code>i</code> 起和 <code>j</code> 重新比较。</li>
<li>不满足条件的话，移动 <code>i</code> ，看增加之后是否满足条件。</li>
<li>将两个片段作为一个整体排序，这个整体将作为回溯到上一层的一个片段。</li>
</ol>
</blockquote>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>等我学会之后再来完成。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">LeetCode 493.翻转对 [Reverse Pairs]</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>归并排序</tag>
        <tag>lowbit</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Health</title>
    <url>/2020/11/23/Health/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>About Health</p>
<a id="more"></a>
<p>从今天起，注意身体，保持健康。</p>
<h3 id="肾脏早期损害指标"><a href="#肾脏早期损害指标" class="headerlink" title="肾脏早期损害指标"></a>肾脏早期损害指标</h3><p><strong>肾小球率过滤</strong> 一般都是用内生肌酐清除率代替的，检查方便，经济（血和尿同时检测），但是和真实的GFR还是有差距的，一般人到了四十岁之后，本身GFR是会每年下降的，但是对于有肾小球肾炎、高血压、糖尿病的患者GFR的下降速度比正常人就快了，其实肾内科最主要的目的就是尽可能的减慢这个衰减，要想彻底阻拦他，目前是没有好办法的，因为到了尿毒症期，也就是GFR小于10的时候，就需要血液透析了（对于急性肾损伤的患者不予讨论），<u>所以这个指标对于疾病早期的诊断而言意义可能不是很大，因为肾脏有强大的代偿能力，你看到就算只有一个肾的人也能活的好好的，早期肾脏损伤的时候GFR并不一定有变化，</u>而且对于糖尿病肾病而言，初期GFR可能还会增高。</p>
<p><strong>微球蛋白</strong>，包括a1和β2，血和尿中的意义不太一样，血中的话炎症、肿瘤、系统性疾病都会高，而对于尿液而言，<u>这类的升高可能代表肾小管重吸收功能的损伤</u>，NAG是小管上皮细胞含量多，尿中NAG的增高提示小管上皮细胞的损伤，当然也会影响到了重吸收功能。免疫球蛋白则是大分子蛋白，肾脏科中选择性尿蛋白和非选择性尿蛋白的区分，就是前者是IgG和白蛋白同时在尿中出现，后者则是仅仅有白蛋白，前者的意义是说明肾小球分子屏障已经损伤，后者可能是小球电荷屏障损伤，前者的病情较后者更重。其实还有纤维蛋白降解产物之类的指标，也是表示肾脏高凝及重吸收障碍的。至于24小时尿蛋白定量和微量白蛋白，都是针对肾脏病小球损伤后小便尿蛋白到底有多少的一个定量检测。</p>
<p>所以题主说题主家人如果有高血压、糖尿病的病史，担心累及肾脏而最终导致肾功能不全，其实最最根本的就是控制好原发病，也就是说高血压和糖尿病，他们本身就会对全身多个系统器官造成损伤，需要的是一个综合的治疗。初期检测太多的那些肾脏指标，每次去复诊都做一套又麻烦，性价比又低，所以门诊常规的肾功能、尿常规做一个筛选性质的，发现有问题，再做深入的检查才是遵循了适合的诊疗过程，所以定期随访肾功能、尿常规是有意义的，而进一步的检查等到发现了问题再查好了，你不怕麻烦，那也随你。门诊上很多病人一查肾功能肌酐一千多，尿蛋白4+的，都是没有控制原发病，没有定期随访的，真到了肌酐增高、GFR下降、大量尿蛋白，说到底，那时候查什么指标都是徒劳，肾脏损伤是不可逆的。</p>
<p><em>参考</em></p>
<blockquote>
<p>作者：肖信<br>链接：<a href="https://www.zhihu.com/question/28962085/answer/42803946" target="_blank" rel="noopener">https://www.zhihu.com/question/28962085/answer/42803946</a></p>
</blockquote>
<p><strong>β2微球蛋白</strong><br>1、β2—微球蛋白水平是反映肾小球滤过功能的灵敏指标<br>　　 (1) β2—微球蛋白在体内产生速率恒定，其血浆中含量不受年龄、性别、机体肌肉组织多少等因素的影响；而且β2—微球蛋白相对分子量小，可自由通过肾小球，且仅由肾脏排泄，因此，测定血浆中β2—微球蛋白水平比检测血清肌酐水平用于评价肾功能更加灵敏，β2—微球蛋白可作为反映糖尿病和高血压肾损害的早期指标。(2)血浆中β2—微球蛋白水平升高，可反映肾小球滤过功能受损或滤过负荷增加的情况，而尿液中β2—微球蛋白含量增高，则提示肾小管损害或滤过负荷增加；若血浆中β2—微球蛋白水平升高而尿液中β2—微球蛋白含量正常，则主要由肾小球滤过功能下降所致，常见于急慢性肾炎、肾功能衰竭等；若血浆中β2—微球蛋白含量正常而尿液中β2—微球蛋白含量升高，则主要由肾小管重吸收功能受损所致，多见于先天性近曲小管功能缺陷、科尼综合征、慢性镉中毒、Wilson病、肾移植排斥反应等；若血浆和尿液中β2—微球蛋白含量均升高，则主要由体内某些部位产生β2—微球蛋白过多或肾小球和肾小管均受到损伤所致。<br>　　2、β2—微球蛋白水平是反映肾小管重吸收功能的灵敏指标<br>　　 (1)肾小球滤过率是估价肾功能的一个重要指标，而由肾小球滤过的β2—微球蛋白，约99．9%在近端肾小管被重吸收，并在此全部被分解成氨基酸，若肾小管重吸收功能受损伤，则进入尿液中的β2—微球蛋白必然增多，故尿液中β2—微球蛋白测定是诊断肾小管疾病较灵敏且特异的方法。(2)急慢性肾衰竭患者尿液中β2—微球蛋白含量升高明显，最高可最达40 mg/L，尿液中有如此高水平的β2—微球蛋白，不能单纯解释为滤过负荷增加，其表明了肾小管必然遭受了严重的损害。(3)测定血浆及尿液中β2—微球蛋白含量，对肾脏疾病的鉴别诊断、病情估计及预后判断都能提供有价值的数据。 [1]<br><em>参考</em></p>
<blockquote>
<p>百度百科<br><a href="https://baike.baidu.com/item/%E5%BE%AE%E7%90%83%E8%9B%8B%E7%99%BD/5597230?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%BE%AE%E7%90%83%E8%9B%8B%E7%99%BD/5597230?fr=aladdin</a></p>
</blockquote>
<h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a>生活习惯</h3><p>保持良好生活习惯，减少伤害肾脏的一切行为<br>肾病患者的各项指标经过治疗得到稳定后，一定要保持良好的作息习惯。<br>生活上面——不要通宵熬夜，避免过度抽烟和饮酒，以及剧烈的运动等，要爱惜肾脏，避免复发。<br>饮食上面——注意低盐、低蛋白、低钾、低磷、低脂的饮食原则，食盐摄入量不应超过3克，可以保护血压和蛋白尿的稳定，并同时减少肾功能的负担。<br>情绪上面——保持良好的心态很重要，心情平和，对病情恢复有帮助，要相信自己，通过治疗和调理，是一定可以恢复的。</p>
<h3 id="24-h尿蛋白和尿NAG与尿蛋白-肌酐比值及尿NAG-肌酐比值的相关性研究"><a href="#24-h尿蛋白和尿NAG与尿蛋白-肌酐比值及尿NAG-肌酐比值的相关性研究" class="headerlink" title="24 h尿蛋白和尿NAG与尿蛋白/肌酐比值及尿NAG/肌酐比值的相关性研究"></a>24 h尿蛋白和尿NAG与尿蛋白/肌酐比值及尿NAG/肌酐比值的相关性研究</h3><p>邵天波, 郭翀, 杨兰辉, 石洪琼, 段勇<br>摘要<br>关键词: 总蛋白; 白蛋白; N-乙酰-β-D-氨基葡萄糖苷酶; 肌酐; 尿液<br>中图分类号:R446.1 文献标志码:A 文章编号:1673-8640(2010)05-0385-02<br>Abstract<br>Keyword:<br>尿蛋白和尿N-乙酰-β -D-氨基葡萄糖苷酶(NAG)的检测对指导肾脏疾病的诊断、治疗、疗效评价和预后判断都具有重要意义。长期以来, 24 h尿蛋白的测定是尿蛋白定量的“ 金标准” 。然而对于24 h尿样本, 也常是采用混匀后对部分样本进行检测完成的, 因此留尿后若提取样本时未充分摇匀或尿液浓缩或稀释等均可影响尿蛋白含量。本研究对81例不同肾脏疾病肾功能损伤患者的尿液样本进行24 h尿微量总蛋白(mTP)、尿微量白蛋白(mAlb)、尿NAG和尿肌酐(Cr)定量检测, 分别计算mTP/Cr比值、mAlb/Cr比值、NAG/Cr比值, 探讨他们之间的相关性。</p>
<p><strong>材料和方法</strong><br>一、研究对象<br>患者均为昆明医学院第一附属医院肾内科、糖尿病科的住院患者, 年龄15~77岁。其中各类肾炎及肾病综合征患者55例, 糖尿病肾病患者26例, 共收集尿液样本81份。</p>
<p>二、方法</p>
<ol>
<li>尿液样本采集 选择清洁容器收集24 h尿液, 记录24 h总尿量并将收集的尿液混匀后取4~5 mL送检。</li>
</ol>
<p>2.仪器、试剂和方法 OLYMPUS AU5400全自动生化分析仪。尿液总蛋白液体试剂盒(邻邦苯三酚红/钼酸盐法)由德赛诊断系统(上海)有限公司提供; 尿mAlb试剂(免疫散射比浊法)由芬兰Orion诊断公司提供; NAG试剂(比色法)由金斯尔北京九强生物技术有限公司提供。</p>
<p>三、项目及计算<br>对尿液样本进行24 h尿mTP、mAlb、NAG和Cr定量检测, 分别计算mTP/Cr比值、mAlb/Cr比值、NAG/Cr比值, 并将所得比值与24 h尿mTP、mAlb及NAG定量结果进行比对。</p>
<p>四、统计学方法<br>数据处理采用SPSS 软件进行秩和检验, 检验数据采用为中位数(四分位间距)表示。</p>
<p><strong>结 果</strong><br>24 h尿Cr为0.83(0.63<del>1.08)g/24 h。24 h尿mTP为185.0(40.0</del>987.5)mg/24 h, mTP/Cr比值为154.2(53.5<del>1 348.8)mg/gCr(Z=-2.945, P=0.003); 相关方程Y=0.856X-19.162, r=0.973。 24 h尿mAlb为29.1(8.0</del>197.2)mg/24 h, mAlb/Cr比值为60.1(14.8<del>376.2)mg/gCr(Z=-6.811, P=0.000); 相关方程为Y=0.326X+30.897, r=0.884。24 h尿NAG为20.3(8.837.9)U/24 h, NAG/Cr比值为21.6(11.0</del>47.3)U/gCr(Z=-2.708, P=0.007); 相关方程为Y=0.631X+7.994, r=0.718。</p>
<p><strong>讨 论</strong><br>糖尿病肾病的早期是治疗的关键时期, 通过加强治疗可以延缓糖尿病肾病的发展, 部分病例甚至可以逆转糖尿病肾病的病理改变[1]。但糖尿病肾病早期无明显临床症状, 尿常规、肾功能检查正常, 致使不少患者在出现蛋白尿、肾功能异常时才发现, 因此糖尿病肾病的早期诊断具有重要的意义。</p>
<p>尿mAlb是反映肾小球滤过功能的主要指标。正常情况下, 肾小球滤过膜存在电荷选择性屏障, 在静电同性排斥作用下, 绝大多数的mAlb 不能通过滤过膜。而在糖尿病肾病早期, 由于肾小球滤过膜负电荷的乙酰硫酸肝素、唾液酸等成分减少, 使肾小球滤过膜的电荷选择性降低, 并干扰了蛋白多糖与细胞外基底间亲和力, 致使肾小球滤过膜上滤孔孔径增大以及肾小球滤过膜富含带负电荷的结构成分改变, 从而导致mAlb 在尿中排出增多[2]。因此mAlb对判断肾小球的受损程度有重要价值, 由于其在糖尿病刚开始并发肾损伤时就存在, 所以是用于筛选早期糖尿病肾病的主要指标[3]。</p>
<p>尿NAG 活性测定作为一种新的敏感性较高的无损伤的肾功能试验, 已用于多种泌尿系统疾病的辅助诊断、病情及疗效观察。NAG为高分子糖蛋白, 是来自肾近曲小管溶酶体内的酸性水解酶, 不能由肾小球滤过, 在尿中相对稳定。当肾近曲小管细胞受损时尿NAG 活性明显升高, 且早于尿蛋白及肾功能异常的变化, 是反映肾小管功能的灵敏指标[4, 5]。</p>
<p>本研究结果显示, 24 h尿mTP与mTP/Cr比值、mAlb与mAlb/Cr比值、NAG与NAG/Cr比值的r分别为0.973、0.884和0.718, 三者均呈良好的正相关性。因此, 24 h尿mTP/Cr比值、mAlb/Cr比值和NAG/Cr比值可为肾脏疾病、糖尿病肾病的正确判断提供实验室依据。</p>
<p>The authors have declared that no competing interests exist.</p>
<p><em>参考文献</em> </p>
<blockquote>
<p>[1]    Mogensen CE, Damsgaard EM, Froland A, et al. Microal-buminuria in non-insulin-dependent diabetes[J]. Clin Nephrol, 1992, 38(Suppl 1): S28-S39. [本文引用:1] [JCR: 1.288]<br>[2]    张晓青, 宗成国, 栾旭华, 等. 尿mAlb/Cr、NAG、LAP 检测对早期糖尿病肾病的诊断价值[J]. 中国现代医学杂志, 2009, 19(1): 122-124. [本文引用:1]<br>[3]    胡芳, 王学斌, 饶锦秀. 糖尿病早期肾损伤的实验诊断[J]. 中华医学杂志, 2007, 44(1): 46-47. [本文引用:1]<br>[4]    王艳萍, 苏晓林, 王禹, 等. NAG及β2-微球蛋白联合检测对糖尿病肾病早期诊断的意义[J]. 中国医科大学学报, 2004, 33(1): 93-94. [本文引用:1]<br>[5]    D’Amico G, Bazzi C. Urinary protein and enzyme excre-tion as markers of tubular damage[J] . Curr Opin Nephrol Hypertens, 2003, 12(6): 639-643. [本文引用:1]<br>来源：<a href="http://www.shjyyx.com/article/2010/1673-8640-25-5-385.html" target="_blank" rel="noopener">http://www.shjyyx.com/article/2010/1673-8640-25-5-385.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 5606.具有给定数值的最小字符串 [第216场周赛]</title>
    <url>/2020/11/22/LeetCode-5606-%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AC%AC216%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>力扣第216场周赛第二题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>小写字符</strong> 的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。<br>字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 <code>&quot;abe&quot;</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。<br>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。<br>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p>
<ul>
<li><code>x</code> 是 <code>y</code> 的一个前缀；</li>
<li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：n = 3, k = 27<br>输出：”aay”<br>解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：n = 5, k = 73<br>输出：”aaszz”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n &lt;= 10^5$</li>
<li>$n &lt;= k &lt;= 26 * n$</li>
</ul>
<hr>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>一共 <code>n</code> 位，我们从第 <code>1</code> 位起，依次按字母表顺序尝试字母是否符合要求。<br>由题可知，<code>n</code> 位数值和的范围是：$n &lt;= k &lt;= 26 * n$，即 <code>n</code> 位的数值和最小取到 <code>n</code> ，这是 <code>n</code> 个 <code>a</code> 的情况；最大取到 <code>26 * n</code>，这是 <code>n</code> 个 <code>z</code> 的情况。<br>一个字母符合要求当且仅当使用了它之后，剩余的数值要在后面所有位的数值和规定的范围内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getSmallestString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">1</span> ; i &lt;= n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k - sum - j &gt;= n - i  &amp;&amp; k - sum - j &lt;= <span class="number">26</span> * (n - i)) &#123;</span><br><span class="line">                    res += ((<span class="keyword">char</span>)((<span class="keyword">int</span>)<span class="string">'a'</span> + j - <span class="number">1</span>));</span><br><span class="line">                    sum += j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>模拟</tag>
        <tag>竞赛</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5607.生成平衡数组的方案数 [第216场周赛]</title>
    <url>/2020/11/22/LeetCode-5607-%E7%94%9F%E6%88%90%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0-%E7%AC%AC216%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>力扣第216场周赛第三题，考查前缀和及动态规划。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p>
<p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p>
<p>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。<br>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。<br>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。<br>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。</p>
<p>请你返回删除操作后，剩下的数组 <code>nums</code> 是 平衡数组 的 方案数 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [2,1,6,4]<br>输出：1<br>解释：<br>删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。<br>删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。<br>删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。<br>删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。<br>只有一种让剩余数组成为平衡数组的方案。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [1,1,1]<br>输出：3<br>解释：你可以删除任意元素，剩余数组都是平衡数组。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：nums = [1,2,3]<br>输出：0<br>解释：不管删除哪个元素，剩下数组都不是平衡数组。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$1 &lt;= nums[i] &lt;= 10^4$</li>
</ul>
<hr>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>依次抽出数组每一个数，然后判断抽出之后，数组是不是平衡数组。<br>关键在于怎么判断数组是不是平衡的。暴力的做法是每次抽取之后，计算一下抽取之后的奇数和及偶数和。然而题目给出数据范围是$1 &lt;= nums.length &lt;= 10^5$，复杂度要控制在 <strong><em>O(N)</em></strong> 或者 <strong><em>O(NLogN)</em></strong>，所以暴力行不通。<br>这里涉及到求和，自然而然想到构造前缀和数组，构造前缀和数组需要 <strong><em>O(N)</em></strong> 的复杂度，而查询只需 <strong><em>O(1)</em></strong>。这道题需要分别计算奇数和及偶数和，所以要分别构造奇偶前缀和。<br>仔细观察题目，抽取数字后，该数字前面的所有数字奇偶下标不变，后面的所有数字下标奇偶互换。那么抽取之后数组的奇数和就是该数前面所有奇数和加上后面所有偶数和；对应的，偶数和就是该数前面所有偶数加上后面所有奇数和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();                                <span class="comment">// 1</span></span><br><span class="line">        vector&lt;int&gt; ps1(n + 2), ps2(n + 2);                 // 2</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i ++ ) &#123;                <span class="comment">// 3</span></span><br><span class="line">            ps1[i] = ps1[i <span class="number">-1</span>], ps2[i] = ps2[i <span class="number">-1</span>];         <span class="comment">// 4 从上一位继承</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) ps1[i] += nums[i - <span class="number">2</span>];               <span class="comment">// 5 nums下标从0开始，求前缀和这里要-1</span></span><br><span class="line">            <span class="keyword">else</span> ps2[i] += nums[i - <span class="number">2</span>];                     <span class="comment">// 6 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;                                    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;                     <span class="comment">// 7</span></span><br><span class="line">            <span class="keyword">int</span> odd, even, p = i + <span class="number">2</span>;                       <span class="comment">// 8</span></span><br><span class="line">            odd = ps1[p - <span class="number">1</span>] + ps2[n + <span class="number">1</span>] - ps2[p];         <span class="comment">// 9</span></span><br><span class="line">            even = ps2[p - <span class="number">1</span>] + ps1[n + <span class="number">1</span>] - ps1[p];        <span class="comment">// 10</span></span><br><span class="line">            <span class="keyword">if</span> (odd == even) res ++;                        <span class="comment">// 11</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>review after today</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>前缀和</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 831.KMP字符串</title>
    <url>/2020/11/17/AcWing-831-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>闪耀着人类智慧之光的——KMP算法。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p> 给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。<br>模板串P在模式串S中多次作为子串出现。<br>求出模板串P在模式串S中所有出现的位置的起始下标。</p>
<p><strong>输入格式</strong><br>第一行输入整数N，表示字符串P的长度。<br>第二行输入字符串P。<br>第三行输入整数M，表示字符串S的长度。<br>第四行输入字符串S。</p>
<p><strong>输出格式</strong><br>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p>
<p><strong>数据范围</strong><br>$1≤N≤10^5$, $1≤M≤10^6$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>3<br>aba<br>5<br>ababa</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>0 2</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模式串S<code>______Sa__________N______________</code><br>模板串P<code>######Pa__________N</code><br>假设当 <code>S</code> 和 <code>P</code> 从 <code>a</code> 点开始匹配时，到 <code>N</code> 点恰好发现一个字符不匹配，暴力做法我们是让 <code>P</code> 向右偏移一位，从头开始和 <code>S</code> 一一比对。但是存在一些字符是之前已经比对匹配过的，我们可以跳过它们以达到优化目的。<br>我们现在的目标就变成了： <strong>如何利用已经比对匹配过的字符已达到优化目的？</strong><br>设想如果我们能找到这样一个平移量 <code>x</code> 使得当我们把 <code>P</code> 串向右移动 <code>x</code> 位时：<br>模式串S<code>______Sa___x________N______________</code><br>模板串P<code>######Pa___x________N</code><br>模板串P<code>##########Px________N_____</code>（移动x位后的）<br>恰好使得在 <code>P</code> 串和 <code>S</code> 串中从 <code>x</code> 点到上次出现不同字符的 <code>N</code> 点中所有数相同，那么如果发现了这个 <code>x</code> 值，就可以从这里开始让两串匹配，从而完成优化。<br>即 <code>P</code> 串移动一个 <code>x</code> 使得 <code>P</code> 串的某一前缀与 <code>S</code> 串的后缀完全相等，在移动前， <code>S</code> 串的后缀与 <code>P</code> 串后缀已经比较过，完全相等。那么问题就转化成，能否找到这样一个 <code>x</code> 使得，在 <code>P</code> 串内部， <code>P</code> 串的前缀与后缀完全相等。 <code>x</code> 和前后缀的关系是： <code>x + 前缀或后缀 == Pa_N</code> 。（这里的前后缀是相对 <code>Sa_N</code> 和 <code>Pa_N</code> 而言）。<br>以上叙述可形象的看成：<br>模板串P<code>|___x___|_______suf_______|</code><br>模板串P<code>########|_______pre_______|___x___|</code><br>其中， <code>suf == pre</code> 。<br>当我们找到了这个 <code>x</code> 还远远不够，因为可能存在多个这样的 <code>x</code> ，为了使优化效果最好，我们尽可能地希望这个 <code>x</code> 越小越好（ <code>x</code> 最小可取到 <code>1</code> ，因为后面已经发生不匹配情况，如果取 <code>0</code> 的话造成矛盾）,当 <code>x</code> 取到 <code>1</code> 的时候，事实就是 <code>P</code> 串向后平移一位，恰好可以跳过从此处到上次不匹配的地方所有数，接着在上一次不匹配的地方又发生了不匹配的情况？</p>
<p><strong>next数组：</strong><br>计算next数组的时候，next[j]的值是在p串中，寻找一个值，使得以j为终点的某一段后缀与以这个值为终点的前缀完全相等，并且后缀与前缀要尽可能地长。举例：<br>i: 1 2 3 4 5 6 7 8 9<br>s: a b a b a b c b d<br>p: a b a b a b a b<br>p: # # a b a b a b a b<br>此时，i == 7, j + 1 == 7, j == 6;<br>next[j]的值，应该为让以j为终点的后缀a b a b与以这个值为终点的前缀a b a b相等，这时next[j] = 4.</p>
<p>对于p串，next数组的值为：<br>idx: 1 2 3 4 5 6 7 8<br>nex: 0 0 1 2 3 4 5 6<br>其中，当idx分别取1和2时，即j对应停留在1和2时，next值找不到满足条件的值，取0是为了退到起点让下一位i ++之后，和j + 1也就是 j == 1作比较。<br>idx == 3时，以下标3为后缀的a与以1为后缀的a相等。next[3] = 1;<br>idx == 4时，以下标4为后缀的a b与以2为后缀的a b相等。next[4] = 2;<br>idx == 5时，以下标5为后缀a b a与以3为后缀的a b a相等。next[5] = 3;<br>idx == 6时，以下标6为后缀a b a b与以4为后缀的a b a b相等。next[6] = 4;<br>idx == 7时，以下标7为后缀a b a b a与以5为后缀的a b a b a相等。next[7] = 5;<br>idx == 8时，以下标8为后缀a b a b a b与以6为后缀的a b a b a b相等。next[8] = 6;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;                        <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )                   <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];            <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;                        <span class="comment">// 4</span></span><br><span class="line">        ne[i] = j;                                          <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )                   <span class="comment">// 6</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];            <span class="comment">// 7</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;                        <span class="comment">// 8</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)                                         <span class="comment">// 9</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - n);                           <span class="comment">// 10</span></span><br><span class="line">            j = ne[j];                                      <span class="comment">// 11</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>AcWing</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 154.滑动窗口 [算法竞赛进阶指南]</title>
    <url>/2020/11/16/AcWing-154-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%5B%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%5D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>单调队列的模板题，滑动窗口经典应用。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个大小为 $n≤10^6$ 的数组。<br>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。<br>您只能在窗口中看到k个数字。<br>每次滑动窗口向右移动一个位置。<br>以下是一个例子：<br>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p>
<table>
<thead>
<tr>
<th>窗口位置</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>[1 3 -1] -3 5 3 6 7</td>
<td>-1</td>
<td>3</td>
</tr>
<tr>
<td>1 [3 -1 -3] 5 3 6 7</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>1 3 [-1 -3 5] 3 6 7</td>
<td>-3</td>
<td>5</td>
</tr>
<tr>
<td>1 3 -1 [-3 5 3] 6 7</td>
<td>-3</td>
<td>5</td>
</tr>
<tr>
<td>1 3 -1 -3 [5 3 6] 7</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>1 3 -1 -3 5 [3 6 7]</td>
<td>3</td>
<td>7</td>
</tr>
</tbody></table>
<p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<p><strong>输入格式</strong><br>输入包含两行。<br>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。<br>第二行有n个整数，代表数组的具体数值。<br>同行数据之间用空格隔开。</p>
<p><strong>输出格式</strong><br>输出包含两个。<br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8 3<br>1 3 -1 -3 5 3 6 7</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="comment">// 求每个窗口最小值</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口，如果已经滑出了窗口，队列从hh处弹出一个数</span></span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;</span><br><span class="line">        <span class="comment">// 在i加入到队尾之前，先维护队列的单调递增性</span></span><br><span class="line">        <span class="comment">// 如果a[i]比队尾对应值小的话，那么不能加入队列，否则队列会递减，此时队尾向左移动，直到在队列中找到一个值使得a[i]比它大（或者找完队列也没有找到）。那么这个时候再将i入队的话，对应的值就会单调递增了。</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">        <span class="comment">// 因为i表示窗口末端或者说队尾，而它又是从0开始的，那么在窗口完全进入数组之前，不需要输出最值。</span></span><br><span class="line">        <span class="comment">// 即：i对应的窗口左端为i - k + 1，当i - k + 1 &lt; 0时，是不需要输出最小值的。</span></span><br><span class="line">        <span class="comment">// 但是由于需要从i = 0起开始维护队列的单调性，所以之前过程不能省略。</span></span><br><span class="line">        <span class="comment">// 我们怎么能知道此时队列头对应的数一定是最小的呢？（当队列数量小于k的时候）</span></span><br><span class="line">        <span class="comment">// 因为不管队列长度是刚好等于窗口长度，还是小于窗口长度，最左边的数一定是最小的。妙啊！</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]); <span class="comment">// 因为队列内部元素对应数组汇中的值是单调递增的，所以可以在O                                        // (1)的时间复杂度内找到最小值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求每个窗口最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>对于这种需要维护一个性质的问题，通常可以这样思考：先假设有这样一个性质，再考虑如何构造和维护这个性质。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">AcWing 154.滑动窗口</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>滑动窗口</tag>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Thousands of cars form lines to collect food in Texas [CNN]</title>
    <url>/2020/11/16/Thousands-of-cars-form-lines-to-collect-food-in-Texas-CNN/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>CNN news</p>
<a id="more"></a>
<hr>
<p>(CNN)Thousands of people lined up for <strong>groceries</strong> at a food bank distribution event in Dallas, Texas, this weekend, with organizers saying the Covid-19 <strong>pandemic</strong> has increased need in the city.</p>
<blockquote>
<p>groceries杂货; pan’demic大流行; </p>
</blockquote>
<p>North Texas Food Bank (NTFB) distributed more than 600,000 pounds of food for about 25,000 people on Saturday, according to spokeswoman Anna Kuruan. There were 7,280 turkeys distributed to families, Kuruan told CNN.</p>
<p>Photos provided by NTFB show thousands of cars lined up for NTFB’s Drive-Thru Mobile Pantry at Fair Park. Kuruan said the need for food “has certainly increased” with the pandemic, with Texas last week becoming the first US state to report 1 million cases of coronavirus.</p>
<p>“Forty percent of the folks coming through our partners doors are doing so for the first time,” she said.</p>
<p>“I see blessings coming to us cause we all struggling. And I appreciate North Texas helping us out,” Dallas resident Samantha Woods told CNN affiliate KTVT as she waited in her vehicle.</p>
<p>“It really is amazing and I thank God that I was able to get in the line this morning.”</p>
<p>In another car, one woman told the station she had been struggling: “I haven’t been working since December. I can’t find a job, they cut off my unemployment – it’s a big deal. It’s a real big deal.”</p>
<blockquote>
<p>unemployment失业; </p>
</blockquote>
<p>NTFB President Trisha Cunningham said she is proud of her team and the community “for providing some hope and care during these extraordinary times.”</p>
<blockquote>
<p>extraordinary特殊的，非凡的; </p>
</blockquote>
<p>“It was quite a humbling scene to see so many in need,” she told CNN.</p>
<blockquote>
<p>humbling沮丧;</p>
</blockquote>
<p>NTFB has several mobile pantry events scheduled throughout the week.</p>
<blockquote>
<p>pantry储藏室;</p>
</blockquote>
<div class="note primary">
            <p><strong>OriginalLink:</strong> <a href="https://us.cnn.com/2020/11/15/us/dallas-texas-food-bank-coronavirus/index.html" target="_blank" rel="noopener">Thousands of cars form lines to collect food in Texas</a></p>
          </div>]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>News</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 820.模拟队列</title>
    <url>/2020/11/15/AcWing-820-%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>数组模拟队列模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个队列，队列初始为空，支持四种操作：</p>
<p>(1) “push x” – 向队尾插入一个数x；<br>(2) “pop” – 从队头弹出一个数；<br>(3) “empty” – 判断队列是否为空；<br>(4) “query” – 查询队头元素。<br>现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p>
<p><strong>输出格式</strong><br>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。<br>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示队头元素的值。</p>
<p><strong>数据范围</strong><br>$ 1≤M≤100000 $,<br>$ 1≤x≤109 $,<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>push 6<br>empty<br>query<br>pop<br>empty<br>push 3<br>push 4<br>pop<br>query<br>push 6</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>NO<br>6<br>YES<br>4</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个数组，用于存放队列中的数；维护一个头指针，一个尾指针，分别用于指向队列的头部和尾部。我们在尾部放入元素，在头部取出元素。当头指针位置在尾指针左侧意味着队列非空，可以初始化头指针和尾指针分别为0和-1.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tt &lt; hh;                                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[++ tt] = x;                                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;                                              <span class="comment">// 1         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (; m--;) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"push"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"pop"</span>) &#123;</span><br><span class="line">            hh ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"empty"</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (empty() ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>初始化头指针和尾指针，值不一定非得是<code>0,-1</code>。当我们初始化为<code>0,-1</code>时，头指针在尾指针右边，表明当前队列为空。为什么初始化 <code>hh</code> 要在 <code>tt</code> 右边呢？一般来说，因为考虑队列仅有一个值的情况，此时必须要让 <code>hh</code> 和 <code>tt</code> 指向同一个值（重叠），所以初始化 <code>tt</code> 要在 <code>hh</code> 左边偏移一位，这样我在第一次 <code>push</code> 的时候, <code>tt++</code> ，和 <code>hh</code> 刚好重叠。也正因为如此，可以用 <code>hh</code> 与 <code>tt</code> 的相对位置来判空。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/831/" target="_blank" rel="noopener">AcWing 820.模拟队列</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 830.单调栈</title>
    <url>/2020/11/14/AcWing-830-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的单调栈模板题。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</p>
<p><strong>输入格式</strong><br>第一行包含整数N，表示数列长度。<br>第二行包含N个整数，表示整数数列。</p>
<p><strong>输出格式</strong><br>共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。</p>
<p><strong>数据范围</strong><br>$1≤N≤10^5$<br>$1≤$ 数列中元素 $≤10^9$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>3 4 2 7 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>-1 3 -1 2 2</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和双指针思想类似，我们先想一想暴力算法。可以使用两层循环，外层遍历整个数组，对于每一个数，内层循环向左寻找第一个小于这个数的数。<br>接着我们利用单调栈对暴力算法进行优化，我们可以在外层循环的过程中，维护一个元素大小单调递增的栈。对于原数组的每一个元素，我们将其与栈顶元素进行比较，如果比栈顶元素大，那么栈顶元素就符合要求，另外要将当前数组元素入栈，此时栈内元素保持了递增。<br>否则将栈顶元素弹出，依次比较栈中所有元素，直到找出第一个比当前数组元素小的。由于栈内元素是递增的，所以比较次数一定是最少的，这就实现了优化。在将栈顶元素弹出的过程，栈顶指针是向左移动的，在这个过程中，栈一直在被破坏、被削减，但是我们不必在意，因为之前的栈内元素已经帮助我们找到了之前数组元素的目标值了，我们将栈顶元素弹出，直到找到或者栈为空，此时的栈将保持维护栈的递增特性，继续为我们当前及以后的数组元素服务。<br>真是个美妙的思路。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><blockquote>
<ol>
<li>Q: 为什么要保持栈内元素大小的单调递增特性？<br>A: 由于栈内元素是递增的，所以比较次数一定是最少的，这就实现了优化。</li>
<li>Q: 如何保持栈内元素大小的递增性？<br>A: 在依次出栈比较栈顶元素和当前数组元素大小的时候，如果栈顶元素小，那么找到目标值，将当前数组元素入栈，这样保持了栈内元素大小的递增性；如果栈顶元素大，那么栈顶指针左移，直到找到目标值，再将当前数组元素入栈，这样就保持了栈内元素大小的递增性。我们不必在意这个过程破坏了栈的结构，因为之前的数已经找到之前数组元素对应的目标值了。</li>
</ol>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (; n --;) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (; tt &amp;&amp; stk[tt] &gt;= x;) tt --;      <span class="comment">// 1</span></span><br><span class="line">                                                <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">" "</span>;             </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        stk[++ tt] = x;                         <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>比较栈顶元素和当前元素，栈为空时不必比较。</li>
<li>此时找到目标值，或者栈为空。</li>
<li>入栈保持栈的递增。</li>
</ol>
</blockquote>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>对于这种需要维护一个性质的问题，通常可以这样思考：先假设有这样一个性质，再考虑如何构造和维护这个性质。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/832/" target="_blank" rel="noopener">AcWing 830.单调栈</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 828.模拟栈</title>
    <url>/2020/11/13/AcWing-828-%E6%A8%A1%E6%8B%9F%E6%A0%88/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>数组模拟栈模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个栈，栈初始为空，支持四种操作：</p>
<p>(1) “push x” – 向栈顶插入一个数x；<br>(2) “pop” – 从栈顶弹出一个数；<br>(3) “empty” – 判断栈是否为空；<br>(4) “query” – 查询栈顶元素。</p>
<p>现在要对栈进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p>
<p><strong>输出格式</strong><br>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。<br>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示栈顶元素的值。</p>
<p><strong>数据范围</strong><br>$1≤M≤100000$,<br>$1≤x≤10^9$<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>push 5<br>query<br>push 6<br>pop<br>query<br>pop<br>empty<br>push 4<br>query<br>empty</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5<br>5<br>YES<br>4<br>NO</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个数组和一个指针，数组存储所有入栈的数，指针指向栈顶元素。<br>入栈：指针右移，将数放入新的位置。<br>出栈：指针左移一位。<br>获取栈顶元素：直接返回指针指向的数、<br>判空：如果指针&gt;=0即非空。</p>
<p>以上为数组模拟栈的基本操作，可见数组模拟栈是非常简单的。当然还可以进行很多魔改。比如当前出栈是不返回任何结果的，但是我们可以让它返回出栈的元素；以及各种边界条件判断等等。用C++ STL的栈能实现的，用数组都可以实现，而用数组可以实现更多STL栈所实现不了的。</p>
<p><strong>在算法竞赛中，由于数据量往往很大，用STL容器（包括链表，hashmap等）会很慢。</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;                         <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt--;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tt &gt;= <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stk[tt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    tt = <span class="number">-1</span>;                            <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (; n --;) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"push"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"pop"</span>) &#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"empty"</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (empty() ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// query</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>tt</code>为栈顶指针。</li>
<li>让栈从数组下标为0处放入数据，因为<code>tt</code>是栈顶指针，在<code>push</code>的时候必须先向右移动一位，所以这里初始化为 <code>-1</code> 。当然也可以让<code>tt</code>初始化为  <code>0</code> ，这样从数组下标1处放入数据，在判空的时候可以 <code>tt ? &quot;NO&quot; : &quot;YES&quot;</code> ，看个人习惯吧。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/830/" target="_blank" rel="noopener">828.模拟栈</a></p>
          </div>




]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing 827.双链表</title>
    <url>/2020/11/13/ACWing-827-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>数组模拟双链表模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个双链表，双链表初始为空，支持5种操作：<br>(1) 在最左侧插入一个数；<br>(2) 在最右侧插入一个数；<br>(3) 将第k个插入的数删除；<br>(4) 在第k个插入的数左侧插入一个数；<br>(5) 在第k个插入的数右侧插入一个数<br>现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。</p>
<p><strong>注意：</strong> 题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：<br>(1) “L x”，表示在链表的最左端插入数x。<br>(2) “R x”，表示在链表的最右端插入数x。<br>(3) “D k”，表示将第k个插入的数删除。<br>(4) “IL k x”，表示在第k个插入的数左侧插入一个数。<br>(5) “IR k x”，表示在第k个插入的数右侧插入一个数。</p>
<p><strong>输出格式</strong><br>共一行，将整个链表从左到右输出。</p>
<p><strong>数据范围</strong><br>$1≤M≤100000$<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>R 7<br>D 1<br>L 3<br>IL 2 10<br>D 3<br>IL 2 7<br>L 8<br>R 9<br>IL 4 7<br>IR 2 2</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8 7 7 3 2 9</p>
</blockquote>
<hr>
<h3 id="数组模拟双链表的本质"><a href="#数组模拟双链表的本质" class="headerlink" title="数组模拟双链表的本质"></a>数组模拟双链表的本质</h3><p>双链表包含一个<code>head</code>结点一个<code>tail</code>结点（即使它是一个空链表，可以把<code>head</code>和<code>tail</code>看成是两个哨兵结点）。这两个结点可以看成是始终固定不动的。从双链表初始化起，到进行各种操作后形成最终链表，所有结点的增加和删除等操作均在<code>head</code>和<code>tail</code>中间进行。<br>对于双链表中的每个结点，我们用三个数组同一下标的元素表示。其中，包含一个结点值，一个前置指针（指向了结点前一个结点对应的数组下标），一个后置指针（指向了结点后一个结点对应的数组下标）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为双链表的每个结点可以访问到其前后结点，所以对于这道题的每一个「插入」操作，都可以由一个方法实现。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"L"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            insert(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"R"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            insert(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"D"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"IL"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/829/" target="_blank" rel="noopener">Acwing 827.单链表</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>AcWing</tag>
        <tag>双链表</tag>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 826.单链表</title>
    <url>/2020/11/12/AcWing-826-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>用数组模拟静态链表</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个单链表，链表初始为空，支持三种操作：<br>(1) 向链表头插入一个数；<br>(2) 删除第k个插入的数后面的数；<br>(3) 在第k个插入的数后插入一个数<br>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意：</strong> 题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：<br>(1) “H x”，表示向链表头插入一个数x。<br>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。<br>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。</p>
<p><strong>输出格式</strong><br>共一行，将整个链表从头到尾输出。</p>
<p><strong>数据范围</strong><br>$1≤M≤100000$<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6 4 6 5</p>
</blockquote>
<hr>
<h3 id="何为链表"><a href="#何为链表" class="headerlink" title="何为链表"></a>何为链表</h3><p>首先什么是链表呢，链表是一堆离散的结点，每个结点存了两个值，一个表示结点的数值，一个是next指针，它指向了下一个结点的位置。链表是一个递归的数据结构（俄罗斯套娃），如果给我们一个链表的头结点，我们可以遍历整个链表。可以认为链表某结点的next指针指向了其后面整个链表。<br>一个链表结点可以形象地看成：<br>[value]<br>[next ]<br>用数组模拟链表，一定要理解其本质。</p>
<h3 id="数组模拟链表的本质"><a href="#数组模拟链表的本质" class="headerlink" title="数组模拟链表的本质"></a>数组模拟链表的本质</h3><p>我们用一个数组A来存储数值，一个数组B来存储指针。一个链表结点分别由同一下标的两个数组元素构成。因为是用数组模拟链表，所以结点的指针用数组下标表示。<br>从0开始遍历两个数组，0代表第0次插入操作，每一次向链表中新插入数值，下标后移一位，相当于new一个新的结点。但是当删除操作时，下标不会移动。也就是说，删除结点时，结点依然在数组中，只是链表不会指向它。<br>另外，需要一个下标来表示整个链表的头结点，注意，头结点不一定在0位置（可能会在头结点前面插入新的结点）。<br>为什么要有头结点下标呢？这样可以很方便地对整个链表遍历，也很方便地在头结点出进行插入和删除操作。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p><strong>向链表头插入一个数：</strong> 即更新头结点。在值域数组新的下标处放入插入的数的值，插入的结点指向了头结点位置，数组下标后移一位方便下次操作。<br><strong>删除第k个输入的数后面的数：</strong> 当k为0时，删除头结点，只需将head移动到head指向的结点；k不为0时，删除第k次插入的结点后面的结点，因为题目中描述“第k次插入”是从1开始计算的，所以此处需要删除下标为k-1的结点后面的结点。相当于是链表从k-1结点跳过它后面的结点，指向它后面的后面的结点。<br><strong>在第k个输入的数后面插入一个数：</strong> 题目说明此处k大于0。只需在值域数组新的下标处放入新插入的数的值，在指针域数组新的下标处放入下标为k-1的结点指向的下一个结点下标，再把下标为k-1的结点指向新的下标。另外，数组下标后移一位方便下次插入操作。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;                                             <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;                                                          <span class="comment">// 2</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++ ;                         <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;                       <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];                                                  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'H'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];                                    <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);                                         <span class="comment">// 7</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k - <span class="number">1</span>, x);                                              <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;         <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>e[N]</code> 和 <code>ne[N]</code> 数组分别为链表结点的值域数组和指针域数组， <code>head</code> 为链表头结点下标， <code>idx</code> 为两个数组共用的游标，每当需要往链表中插入值时， <code>idx</code> 后移一位，相当于 <code>new</code> 一个新结点。</li>
<li><code>head</code>初始化为-1，表示初始状态链表头结点为<code>null</code>；<code>idx</code>初始化为0，表示将在两个数组的起始位置添加结点。因为题目的第「<code>k</code>」个数指的是从 <code>1</code> 起 第 <code>k</code> 个操作数，所以如果我们 <code>idx</code> 初始化为 <code>0</code> ，那么 <code>k</code> 和数组下标的对应关系是 <code>k - 1 == idx</code> 。接着我们注意到算法在使用 <code>k</code> 时是直接当数组下标用的，那是因为在 <code>7</code> <code>8</code> 处调用函数时，参数已经做了修正（<code>k - 1</code>）。当然可以让 <code>idx</code> 初始化为 <code>1</code> ，那么 <code>k</code> 和 <code>idx</code> 完全对应，可以直接使用，且调用函数时不需要修正。</li>
<li><code>new</code>一个新的结点，让结点的<code>next</code>指针指向<code>head</code>，游标后移。</li>
<li><code>new</code>一个新的结点，让结点的<code>next</code>指针指向下标<code>k</code>的下一位，游标后移。</li>
<li>跳过下标为<code>k</code>的结点。</li>
<li>注意到题干要求当<code>k</code>为0的情况。</li>
<li>注意题干的第<code>k</code>个结点是从1开始计数的，我们算法实现的<code>k</code>是下标<code>k</code>。</li>
<li>同上。</li>
<li><strong>链表的遍历：</strong> 从头结点下标开始<code>i = head</code>，到<code>null</code>结点结束<code>i == -1</code>。因为第一个操作必然是更新头结点（否则其他操作没法进行），接着将头结点指向 <code>-1(null)</code> ，即第一步必然是 <code>head -&gt; null</code> ，随后所有操作都在 <code>head</code> 和 <code>null</code> 之间进行。那么在所有操作结束之后，遍历链表，一定是以 <code>null</code> 结束。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/828/" target="_blank" rel="noopener">Acwing 826.单链表</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>AcWing</tag>
        <tag>单链表</tag>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 800.数组元素的目标和</title>
    <url>/2020/11/11/AcWing-800-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道双指针题目。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。<br>请你求出满足A[i] + B[j] = x的数对(i, j)。</p>
<p>数据保证有唯一解。</p>
<p><strong>输入格式</strong><br>第一行包含三个整数n，m，x，分别表示A的长度，B的长度以及目标值x。<br>第二行包含n个整数，表示数组A。<br>第三行包含m个整数，表示数组B。</p>
<p><strong>输出格式</strong><br>共一行，包含两个整数 i 和 j。</p>
<p><strong>数据范围</strong><br>数组长度不超过100000。<br>同一数组内元素各不相同。<br>$1≤$数组元素$≤10^9$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>4 5 6<br>1 2 4 7<br>3 4 6 8 9</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>1 1</p>
</blockquote>
<hr>
<h3 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h3><p>类似夹逼准则。充分利用两个数组都是递增的特性。<br>维护两个指针，指针i从数组1的低位向高位遍历，指针j从数组2的高位向低位遍历，一直向正确的数值逼近。<br>j先向左移动，直到找到一个数，使得与i对应的数之和小于目标值，此时排除掉j右侧所有数，正确的i和j应该分别分布在i的右侧和j的左侧。<br>i再向右移动，直到找到一个数，使得与j对应的数之和小于目标值，此时排除掉i左侧所有数，正确的i和j应该分布在i的右侧和j的左侧。<br>A数组：<code>i____________________________________</code><br>B数组：<code>______________________________&lt;-j</code><br>A数组：<code>i____________________________________</code><br>B数组：<code>____________________j_____被排除_____</code><br>A数组：<code>i-&gt;____________________________________</code><br>B数组：<code>____________________j_____被排除_____</code><br>A数组：<code>____被排除____i____________________________</code><br>B数组：<code>____________________j_____被排除_____</code><br>重复上述过程，直到找到正确的i和j。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j -- ;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度： <strong><em>O(N)</em></strong></p>
<h3 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>对于数组1中的每个数，通过目标数计算出应该存在于数组2中的值，再用二分查找的方式在数组2中查找。<br>该方法只利用了一个数组的单调性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l &lt; r;) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[mid] &gt;= t) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[l] != t) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x - a[i];</span><br><span class="line">        <span class="comment">// finds t in b</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">find</span>(t, m);</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：<strong><em>O(NLogN)</em></strong></p>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/description/802/" target="_blank" rel="noopener">AcWing 800.数组元素的目标和</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 795.前缀和</title>
    <url>/2020/11/10/AcWing-795-%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>前缀和模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个长度为n的整数序列。<br>接下来再输入m个询问，每个询问输入一对l, r。<br>对于每个询问，输出原序列中从第l个数到第r个数的和。</p>
<p><strong>输入格式</strong><br>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数数列。<br>接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。</p>
<p><strong>输出格式</strong><br>共m行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong><br>$ 1≤l≤r≤n $,<br>$1≤n$, $m≤100000$,<br>$−1000≤$ 数列中元素的值 $≤1000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3<br>6<br>10</p>
</blockquote>
<hr>
<p>此题考查前缀和数组的构造。对于一个给定数组<code>alls[N]</code>，其前缀和数组<code>s[N]</code>对应着对于<code>alls[N]</code>的每一个元素，其前缀所有元素（包括这一位）之和。<br>前缀和数组的应用一般伴随着一些查询操作，一个查询操作就是给定一个区间范围，让你求该范围内数的和。<br>另外，注意构造前缀和数组是从下标1开始构造，整体数目不变。相当于是数组下标向右偏移一位。这是因为构造前缀和数组的每一位需要依赖其前一位。当构造第1位时，需要依赖第0位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> alls[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">cin</span> &gt;&gt; alls[i];                  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> s[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;                                <span class="comment">// 2</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + alls[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; m -- ;) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;          </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;                            <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>从下标1开始读取数组，整体向右偏移一位方便查询。</li>
<li>从下标1开始构建前缀和数组。</li>
<li>查询时，<code>s[r] - s[l]</code>多减了一个<code>alls[l]</code>，所以要<code>s[r] - s[l - 1]</code>。</li>
</ol>
</blockquote>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/797/" target="_blank" rel="noopener">AcWing 795.前缀和</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 794.高精度除法</title>
    <url>/2020/11/09/AcWing-794-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>高精度除法模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个非负整数A，B，请你计算 A / B的商和余数。</p>
<p><strong>输入格式</strong><br>共两行，第一行包含整数A，第二行包含整数B。</p>
<p><strong>输出格式</strong><br>共两行，第一行输出所求的商，第二行输出所求余数。</p>
<p><strong>数据范围</strong><br>$1≤A$ 的长度 $≤100000$,<br>$1≤B≤10000$<br>$B$ 一定不为0</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>7<br>2</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3<br>1</p>
</blockquote>
<hr>
<p>不考虑负数情况，因为负数除法可以转化为两个正数相除。<br>和高精度加减乘不一样的是，高精度除法是从大整数高位开始的。在复习了小学二年级下册的相关内容后，我觉得算法基本上就是模拟除法竖式。<br>高精度加计算过程会产生进位，减计算过程会产生借位，乘计算过程会产生进位，而高精度除法计算过程会产生余数。<br>余数作为下一位的高位需要乘10进行新一轮的除法运算。<br>以下为我写的代码，和模板可能有略微区别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;                                                         <span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];                                             <span class="comment">// 2</span></span><br><span class="line">        res.push_back(r / b);                                          <span class="comment">// 3</span></span><br><span class="line">        r %= b;                                                        <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());                                   <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">for</span> (; res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();</span><br><span class="line">    b = r;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i ++ ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = div(A, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>初始化余数<code>r</code>aka <code>remain</code>。</li>
<li>对于被除数<code>A</code>的每一位，需要将上一位除法运算产生的余数作为当前数的高位乘10加上当前数。</li>
<li>用当前数作为被除数和除数<code>b</code>进行除法运算，放到结果槽中。</li>
<li>将余数保留给下一位。</li>
<li>首位可能产生0，所以我们将结果数组反转再去除结尾0.</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/796/" target="_blank" rel="noopener">AcWing 794.高精度除法</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 793.高精度乘法</title>
    <url>/2020/11/09/AcWing-793-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>高精度乘法模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个正整数A和B，请你计算A * B的值。</p>
<p><strong>输入格式</strong><br>共两行，第一行包含整数A，第二行包含整数B。</p>
<p><strong>输出格式</strong><br>共一行，包含A * B的值。</p>
<p><strong>数据范围</strong><br>$1≤A$ 的长度 $≤100000$,<br>$0≤B≤10000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>2<br>3</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<hr>
<p>注意这道题是两个正整数，一个超长位数乘一个短位数，在进行高精度乘法运算过程中，我们习惯将短位数和超长位的每一位进行乘法运算。<br>如果换成负数，本质还是一样的，无非就是多一次正负判断。<br>对于最终进位的处理，有两种方式：</p>
<h3 id="方法一：进位依次对十取模放进res数组"><a href="#方法一：进位依次对十取模放进res数组" class="headerlink" title="方法一：进位依次对十取模放进res数组"></a>方法一：进位依次对十取模放进res数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>() || t; i ++ )                       <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m.<span class="built_in">size</span>()) t += m[i] * b;</span><br><span class="line">        res.push_back(t % <span class="number">10</span>);                                      <span class="comment">// 2</span></span><br><span class="line">        t /= <span class="number">10</span>;                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();      <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = mul(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i  -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意1处条件，当<code>m</code>没有遍历完的时候，需要一直和<code>n</code>相乘，更新进位<code>t</code>。当乘完的时候，依然进入处理进位<code>t</code>，只不过此时不需要和<code>n</code>相乘，而是直接模10获得最高位数。</li>
<li>放入slot中的数一直都是对10取模。</li>
<li>去除数组尾部（结果头部）零。</li>
</ol>
</blockquote>
<h3 id="方法二：进位直接放入res数组"><a href="#方法二：进位直接放入res数组" class="headerlink" title="方法二：进位直接放入res数组"></a>方法二：进位直接放入res数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = m[i] * n + t;</span><br><span class="line">        res.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) res.push_back(t);</span><br><span class="line">    <span class="keyword">for</span> (; res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = mul(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i  -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在处理最终进位<code>t</code>的时候，方法一是对<code>t</code>再进入循环处理，这时候如果<code>t &lt; 10</code>的话，只循环一次，但是如果<code>t &gt;= 10</code>的话，需要反复进入循环，依次取模，除10.</p>
<div class="note primary">
            <h4 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h4><p><a href="https://www.acwing.com/problem/content/795/" target="_blank" rel="noopener">AcWing 793.高精度乘法</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 792.高精度减法</title>
    <url>/2020/11/08/AcWing-792-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>高精度减法模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个正整数，计算它们的差，计算结果可能为负数。</p>
<p><strong>输入格式</strong><br>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong><br>共一行，包含所求的差。</p>
<p><strong>数据范围</strong><br>$1≤$ 整数长度$ ≤10^5$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>32<br>11</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>21</p>
</blockquote>
<hr>
<p>注意这道题是两个正整数相减。<br>如果换成带负数的，进行判断正负之后，要么转化为两个正整数相加，要么依旧是两个正整数相减。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i]) <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t += m[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n.<span class="built_in">size</span>()) t -= n[i];</span><br><span class="line">        res.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);                                               <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();                       <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m, n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )  m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )  n.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (cmp(m, n)) res = sub(m, n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = sub(n, m);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>此处<code>t</code>有可能被减成了负数（最低可以取到-10，最高可取到9），此时向后一位借10，于是最低取到0；同时由于借10的时候并没有判断正负，所以+10可能会导致结果高于10。也就是说，此时运算过程放入<code>C</code>中的数可能的取值范围是：<code>(0, 19)</code>。这样我对10取模，即可得到正确的放入<code>C</code>中的数了。<br>注意，在把“优化”后的（指借位模10）运算结果放入<code>C</code>时，并没有把结果赋值给<code>t</code>，因为后面需要判断<code>t</code>的正负，以更新下一轮的<code>t</code>取值。如果赋值了，则<code>t</code>必然为正，无法更新进位信息。</li>
<li>注意当A与B前几位部分相等时，C后面会存在’0’，如<code>123 - 120</code>结果类似<code>003</code>。但在结果仅为1位时，不用考虑。</li>
</ol>
</blockquote>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/794/" target="_blank" rel="noopener">AcWing 792.高精度减法</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 791.高精度加法</title>
    <url>/2020/11/08/AcWing-791-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要；</strong><br>高精度加法。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个正整数，计算它们的和。</p>
<p><strong>输入格式</strong><br>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong><br>共一行，包含所求的和。</p>
<p><strong>数据范围</strong><br>$1 ≤$ 整数长度 $≤ 100000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>12<br>23</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>35</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span>                             <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)                      <span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);                                                  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>以数组引用传入参数，可以避免没必要的数组拷贝。</li>
</ol>
</li>
<li><ol start="2">
<li><code>A</code>或<code>B</code>至少有一个没有遍历完，都需要继续计算。</li>
</ol>
</li>
<li><ol start="3">
<li>注意结束之后进位有可能非0.</li>
</ol>
</li>
</ul>
</blockquote>
<p>模板1可以改写成总是模拟以一个更长的数组加长度较小的数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">size</span>() &lt; n.<span class="built_in">size</span>()) <span class="keyword">return</span> add(n, m);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t += m[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n.<span class="built_in">size</span>()) t += n[i];</span><br><span class="line">        res.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) res.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m, n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) n.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = add(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/description/793/" target="_blank" rel="noopener">AcWing 791.高精度加法</a></p>
          </div>


]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 2767.优秀的拆分 [2020 CCF CSP-J2, NOIP]</title>
    <url>/2020/11/08/AcWing-2767-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86-2020-CCF-CSP-J2-NOIP/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>2020 CCF CSP-J2普及组 aka NOIP</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一般来说，一个正整数可以拆分成若干个正整数的和。<br>例如，$1=1$，$10=1+2+3+4$ 等。<br>对于正整数 $n$ 的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个 <strong>不同</strong> 的 $2$ 的 <strong>正整数</strong> 次幂。<br>注意，一个数 $x$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到。<br>例如，$10=8+2=2^3+2^1$ 是一个优秀的拆分。<br>但是，$7=4+2+1=2^2+2^1+2^0$ 就不是一个优秀的拆分，因为 $1$ 不是 $2$ 的正整数次幂。<br>现在，给定正整数 $n$，你需要判断这个数的所有拆分中，是否存在优秀的拆分。<br>若存在，请你给出具体的拆分方案。<br>本题暂时采用AcWing数据。</p>
<p><strong>输入格式</strong><br>输入文件只有一行，一个正整数 n，代表需要判断的数。</p>
<p><strong>输出格式</strong><br>如果这个数的所有拆分中，存在优秀的拆分。<br>那么，你需要 <strong>从大到小</strong> 输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。<br>可以证明，在规定了拆分数字的顺序后，该拆分方案是 <strong>唯一</strong> 的。<br>若不存在优秀的拆分，输出 “-1”（不包含双引号）。</p>
<p><strong>数据范围</strong><br>对于 $20\%$ 的数据，$n≤10$。<br>对于另外 $20\%$ 的数据，保证 $n$ 为奇数。<br>对于另外 $20\%$ 的数据，保证 $n$ 为 $2$ 的正整数次幂。<br>对于 $80\%$ 的数据，$n≤1024$。<br>对于 $100\%$ 的数据，$1≤n≤1×10^7$。</p>
<p><strong>输入样例1：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<p><strong>输出样例1：</strong></p>
<blockquote>
<p>4 2</p>
</blockquote>
<p><strong>样例1解释</strong><br>$6=4+2=2^2+2^1$ 是一个优秀的拆分。</p>
<p>注意，$6=2+2+2$ 不是一个优秀的拆分，因为拆分成的 $3$ 个数不满足每个数互不相同。</p>
<p><strong>输入样例2：</strong></p>
<blockquote>
<p>7</p>
</blockquote>
<p><strong>输出样例2：</strong></p>
<blockquote>
<p>-1</p>
</blockquote>
<hr>
<p>本质是考二进制。一个奇数不可能存在优秀的拆分；偶数一定存在优秀的拆分。偶数的优秀拆分可表示成其二进制数转十进制时，底数2的次幂。<br>如：<br>十进制10的二进制为1010，转化为十进制即 $2^3 + 2^1$ 。那么10的优秀拆分就是 <code>8 2</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i --) &#123;        <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;&gt; i &amp; <span class="number">1</span>) &#123;                   <span class="comment">// 3</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="number">1</span> &lt;&lt; i);          <span class="comment">// 4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>奇数不存在优秀拆分。</li>
<li>题目限制 <code>n &lt;= 1e7</code>，所以n的二进制数最高位1最高可取到第23位（从0开始）。</li>
<li>判断从二进制最低位起第<code>i</code>位是否为1。</li>
<li>输出第i位为1的十进制数字，可以看成是该位右边全为0时的十进制数，等价于将1左移<code>i</code>位。</li>
</ol>
</blockquote>
<p>我觉得本题重点是能想到用二进制来表示数字，另外就是对数字范围的判断。</p>
<p><strong>原题链接：</strong></p>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/2769/" target="_blank" rel="noopener">AcWing 2767.优秀的拆分</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 803.区间合并</title>
    <url>/2020/11/07/AcWing-803-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的区间合并问题。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。<br>注意如果在端点处相交，也算有交集。<br>输出合并完成后的区间个数。<br>例如：[1,3]和[2,6]可以合并为一个区间[1,6]。</p>
<p><strong>输入格式</strong><br>第一行包含整数n。<br>接下来n行，每行包含两个整数 l 和 r。</p>
<p><strong>输出格式</strong><br>共一行，包含一个整数，表示合并区间完成后的区间个数。</p>
<p><strong>数据范围</strong><br>1≤n≤100000,<br>−1e9≤li≤ri≤1e9</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 2<br>2 4<br>5 6<br>7 8<br>7 9</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<hr>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line">    <span class="keyword">int</span> l = segs[<span class="number">0</span>].first, r = segs[<span class="number">0</span>].second;                  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; segs.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; segs[i].first) &#123;                                <span class="comment">// 3</span></span><br><span class="line">            res.push_back(&#123;l, r&#125;);</span><br><span class="line">            l = segs[i].first, r = segs[i].second;              <span class="comment">// 4</span></span><br><span class="line">        &#125;                                          </span><br><span class="line">        <span class="keyword">else</span> r = <span class="built_in">max</span>(r, segs[i].second);                        <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(&#123;l, r&#125;);                                      <span class="comment">// 6</span></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; segs;</span><br><span class="line">    <span class="keyword">for</span> (; n -- ;) &#123;                                         </span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());                             <span class="comment">// 1  </span></span><br><span class="line">    merge(segs);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>区间按照左端点排序。<code>sort()</code>用于排序<code>pair</code>类时，默认按照左端点升序排序。</li>
</ol>
</li>
<li><ol start="2">
<li>初始化区间左右端点，后面会更新它们。因为题目指出区间数量<code>n &gt;= 1</code>，所以这里是初始化为排序后的第一个区间。</li>
</ol>
</li>
<li><ol start="3">
<li>比较两个区间是否相交。</li>
</ol>
</li>
<li><ol start="4">
<li>不相交情况下更新前置区间左右端点。</li>
</ol>
</li>
<li><ol start="5">
<li>相交情况下更新前置区间左右端点。（此时只需更新右端点）</li>
</ol>
</li>
<li><ol start="6">
<li>处理最后一个前置区间，此时前置区间必然是孤立区间。因为<code>n &gt;= 1</code>且最后一个前置区间没有下一个当前区间。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong><br><a href="https://www.acwing.com/problem/content/805/" target="_blank" rel="noopener">AcWing 803.区间合并</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 802.区间和</title>
    <url>/2020/11/06/AcWing-802-%E5%8C%BA%E9%97%B4%E5%92%8C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的离散化题目。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。<br>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。<br>接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p>
<p><strong>输入格式</strong><br>第一行包含两个整数n和m。<br>接下来 n 行，每行包含两个整数x和c。<br>再接下里 m 行，每行包含两个整数l和r。</p>
<p><strong>输出格式</strong><br>共m行，每行输出一个询问中所求的区间内数字和。</p>
<p><strong>数据范围</strong><br>$−1e9≤x≤1e9$,<br>$1≤n,m≤1e5$,<br>$−1e9≤l≤r≤1e9$,<br>$−10000≤c≤10000$ </p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8<br>0<br>5</p>
</blockquote>
<hr>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;                                           <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> a[N], s[N];                                                 <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;                                               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l &lt; r;) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;                                               <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (; n -- ;) &#123;                                            <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        alls.push_back(x);</span><br><span class="line">        add.push_back(&#123;x, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; m -- ;) &#123;                                            <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">int</span> l, r;   </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());                             <span class="comment">// 6</span></span><br><span class="line">    alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 7</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add) &#123;                                     <span class="comment">// 8</span></span><br><span class="line">        a[<span class="built_in">find</span>(item.first)] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) &#123;                  <span class="comment">// 9</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query) &#123;                                   <span class="comment">// 10</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>add下标最多1e5个，query下标最多2e5个。当最极端的情况出现时，下标总数可达到3e5。</li>
</ol>
</li>
<li><ol start="2">
<li>待离散化数组，存放add下标和query下标。</li>
</ol>
</li>
<li><ol start="3">
<li>为了方便求前缀和，将add每一位映射到a数组向右偏移一位的位置（从1开始）。</li>
</ol>
</li>
<li><ol start="4">
<li>add数据输入。</li>
</ol>
</li>
<li><ol start="5">
<li>query数据输入。</li>
</ol>
</li>
<li><ol start="6">
<li>排序为了方便二分查找映射下标。</li>
</ol>
</li>
<li><ol start="7">
<li>去重为了让所有待离散化数据一一映射自己的下标。</li>
</ol>
</li>
<li><ol start="8">
<li>处理映射数组，所有add下标对应统统加上相应的数；所有query下标对应默认为0。</li>
</ol>
</li>
<li><ol start="9">
<li>求前缀和数组。我们知道求前缀和数组需要从1开始取，但是这里为什么 <strong>可以</strong> 从1开始遍历呢？因为alls数组是从0开始记录的，find方法将坐标映射到下标时已经向右偏移了一位，所以a数组值&gt; 0的位置一定是&gt; 0的。另外注意到这里为什么要用alls.size()呢，那是因为离散化操作将所有的alls数组中的值全部映射到了a数组中，且前缀和数组长度一定和alls一样长。</li>
</ol>
</li>
<li><ol start="10">
<li>输出查询</li>
</ol>
</li>
<li><ol start="11">
<li>当数组范围大的时候一定要在<code>main()</code>函数外面开数组，因为在这里开数组其内存会被分配在数据区，而在<code>main()</code>内开数组其内存你会被分配在代码区，数据量大的话会出错。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>现在我们尝试描述一下a数组：</strong><br>a数组从0开始，到300009位结束。其中，第0位因为映射过程向右偏移一位故为0。从1开始到alls.size()处，其中有一部分值大于0，这些值是add操作增加的值；另一部分值为0，这一部分为查询坐标映射过来的，构建前缀和数组时需要包含在内。从alls.size()起到300009为止全是0.这一部分长度根据测试数据而变化。</p>
<p>本质上，alls数组可以看成是一组映射关系。将可能取到极大或极小但数量有限的坐标和数组下标对应起来。由于vector数组自身的属性，此时是从0开始记录的。由于我们要构建前缀和数组，在处理a数组时要从1开始构建，所以在通过find方法找坐标下标时，要整体向右偏移一位。</p>
<p><strong>举例：</strong><br>现有Add坐标: -314159265358979, -123, -84, -12, 0, 3, 10086, 99999999999999<br>简化一点，分别对应加1。<br>Query坐标：{-314159265358980, -122}, {-13, 5}, {9999, 99999999999999999999}, {-314159265358983, 99999999999999999999}, {0, 0}</p>
<p>alls数组: $$-314159265358983_0, -314159265358980_1, -314159265358979_2, -123_3, -122_4, -84_5, -13_6,\ -12_7, 0_8, 3_9, 5_{10}, 9999_{11}, 10086_{12}, 99999999999999_{13}, 99999999999999999999_{14}$$</p>
<p>a数组：$$0_0, 0_1, 0_2, 1_3, 1_4, 0_5, 0_6, 0_7, 1_8, 1_9, 1_{10}, 0_{11}, 0_{12}, 1_{13}, 1_{14}, 0_{15}, 0_{16}, … , 0_{100009}$$</p>
<div class="note primary">
            <p><strong>原题链接：</strong><br><a href="https://www.acwing.com/problem/content/804/" target="_blank" rel="noopener">AcWing 802.区间和</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>数组排序去重</title>
    <url>/2020/11/04/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一个快速实现数组排序去重的小技巧。</p>
<a id="more"></a>
<p>为什么要记录这个呢，因为算法题中经常用到。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ol>
<li><p>用sort函数配合STL的unique函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());                                 <span class="comment">// 1</span></span><br><span class="line">nums.erase(unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>将原数组排序</li>
</ol>
</li>
<li><ol start="2">
<li>unique函数实现将数组相邻数中重复的移动到函数尾端，返回包含所有重复数字的数组段的起始位置。<br>接下来用erase函数将重复段擦除。</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>自己造轮子<br>维护两个指针i和j，i负责遍历数组，比较每一项与上一项；j负责指向存储不重复元素的位置。当i遇到不重复项时，j跟随i移动；否则j停止，等待i遇到下一个不重复项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) &#123;                     <span class="comment">// 1</span></span><br><span class="line">            a[j ++] = a[i];                               <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unique between 0 and j - 1</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li><code>!i</code>等价于<code>i == 0</code>。当i取首位或者<code>a[i]</code>与上一位相等时，说明<code>a[i]</code>是不重复元素。</li>
</ol>
</li>
<li><ol start="2">
<li>这里体现了 <strong>原地算法思想（in-place algorithm）</strong>。一旦<code>i</code>超过首位且<code>a[i] == a[i - 1]</code>（遇到重复情况），<code>j</code>指针会停留在重复位置，等待<code>i</code>指针找到下一个不重复元素, 直接将不重复元素覆盖掉j指针指向的重复位置。</li>
</ol>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>用到再来写. </p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
        <tag>去重</tag>
        <tag>unique</tag>
        <tag>原地算法</tag>
        <tag>in-place algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈原码、反码和补码</title>
    <url>/2020/11/04/%E6%B5%85%E8%B0%88%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>计算机二进制原码、反码和补码的个人理解。</p>
<a id="more"></a>
<p>首先应该明确一点，原码、反码和补码，它是一套由伟大的计算机前辈们设计出来的系统。目的是适配计算机的正负数表示，和加减运算。<br>当我认真理解了原码、反码和补码这一套系统之后，我深深地觉得如果自己出生于恰当的年代而且恰好也是一位计算机科学家的话，我大概也会这样设计，因为它是那么的和谐且自然————仿佛本就该如此。</p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>一个<code>int</code>型整数的二进制表示为32个0或1，比如10，它的二进制表示为1010（前方的0省略了）。计算机被设计出来的时候，自带了一个加法器的东西。于是，整数的加法运算很简单。例如，10 + 1，它的二进制计算过程是：<br><code>0000 0000 0000 0000 0000 0000 0000 1010   +</code><br><code>0000 0000 0000 0000 0000 0000 0000 0001   =</code><br><code>0000 0000 0000 0000 0000 0000 0000 1011</code><br>-10的原码二进制表示为：<br><code>1000 0000 0000 0000 0000 0000 0000 1010</code><br><strong>这就是原码的定义，最高位是0，表示正数；最高位是1时，表示负数。其他位表示该数绝对值对应的二进制位。</strong><br>两个正数可以直接按照原码进行加法运算，那么减法呢？<br>当进行减法运算时，我们必须考虑用负数代替减法，把减法转化为加法运算。但是直接拿原码进行减法运算显然得出错误结论（即得到的结果值按照原码的表示方法和正确数值不对应）。为了表示负数，和将负数用于加法计算，科学家设计出了反码表示。</p>
<h3 id="反码的由来"><a href="#反码的由来" class="headerlink" title="反码的由来"></a>反码的由来</h3><p>由于需要表示负数，科学家设计了反码。它的设计原则是：<br><code>x + (-x) = 0</code><br>即，一个数的负数加上它本身等于0。<br>看一下这个例子：<br>数字10的负数应该怎么表示？<br>10的原码二进制表示为：<br><code>0000 0000 0000 0000 0000 0000 0000 1010</code><br>-10的原码二进制表示为：<br><code>1000 0000 0000 0000 0000 0000 0000 1010</code><br>当我们运算<code>10 + (-10)</code>时，<br>如果直接拿原码当负数进行加法运算，得到的值是：<br><code>1000 0000 0000 0000 0000 0000 0000 1100</code><br>显然是错的，它并不是0。<br>于是科学家为了适配负数计算，将负数表示为：<br><strong>原码最高位保持不变，其他位每位取反。</strong><br>这就是反码。<br>那么，<code>10 + (-10)</code>就变成了：<br><code>0000 0000 0000 0000 0000 0000 0000 1010   +</code><br><code>1111 1111 1111 1111 1111 1111 1111 0101   =</code><br><code>1111 1111 1111 1111 1111 1111 1111 1111</code><br>注意，负数参与的加法得到的值依然是反码。为什么呢？因为：<br><strong>正数的反码就是其原码</strong><br>两个反码相加，结果当然还表示为反码。这里就很清晰了，上述计算结果最高位1表示负数，其他位取反还原成原码就是：<br><code>1000 0000 0000 0000 0000 0000 0000 0000</code><br>表示成-0。<br>那么，你可以注意到-0的反码表示为：<br><code>1111 1111 1111 1111 1111 1111 1111 1111</code><br>而+0的反码表示为：<br><code>0000 0000 0000 0000 0000 0000 0000 0000</code><br>而<code>+0 == -0 == 0</code><br>当科学家设计到这里的时候，甭提多尴尬了，同一个数居然出现了两种表示方式。于是，闪耀着人类智慧光芒的 <strong>补码</strong> 应运而生。</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>为了让0只有一种表示方式，科学家们大腿一拍，决定：<br><strong>先让0表示为<code>0000 0000 0000 0000 0000 0000 0000 0000</code></strong><br><strong>所有正数原地不动，表示为其原码。</strong><br><strong>再让所有负数向多出来的-0位置移动一位。即所有负数表示为反码+1位偏移</strong><br>这就是补码。<br>为了更好地理解这一块，你可以把0附近的数在计算机中看成是这样排列的：<br><code>-3  -2  -1  -0   +0   +1   +2   +3</code><br>按照反码规则，他们确实是这样排列的。</p>
<p><strong>做个总结：</strong></p>
<blockquote>
<ul>
<li>原码：正数不变，负数最高位取1表示符号，其余位保持和对应的正数相同（给人看的，让你一看就知道是负几）。</li>
<li>反码：正数和原码相同，负数最高位取1，其余位各位取反（给计算机看的，让计算机可以计算负数加法）。</li>
<li>补码：正数和原码相同，负数为原码取反再加1（给计算机看的，让计算机可以处理0）。<br>其中，你如果直接看负数的补码会觉得好奇怪，其实这个只是一种表示方法，一种外在的表现形式。你按照计算机的规则先减1再取反就得到这个负数的原码的。你就能看懂了。</li>
</ul>
</blockquote>
<p><strong>举个例子：</strong><br><code>3 + (-5)</code><br>3的补码为：<br><code>0000 0000 0000 0000 0000 0000 0000 0011</code><br>-5的原码为：<br><code>1000 0000 0000 0000 0000 0000 0000 0101</code><br>反码为：<br><code>1111 1111 1111 1111 1111 1111 1111 1010</code><br>补码为：<br><code>1111 1111 1111 1111 1111 1111 1111 1011</code><br><code>3 + (-5)</code> 计算机的计算过程是这样的：<br><code>0000 0000 0000 0000 0000 0000 0000 0011   +</code><br><code>1111 1111 1111 1111 1111 1111 1111 1011   =</code><br><code>1111 1111 1111 1111 1111 1111 1111 1110</code><br>结果的补码看起来好奇怪，但是记住这是给计算机看的，在补码体系下它就是被设计成用这一串奇奇怪怪的1、0表示-2。我们只需将其减1再取反即可得到结果的原码表示：<br>结果减1当然也是加上1的补码：<br><code>1111 1111 1111 1111 1111 1111 1111 1110   +   //结果补码</code><br><code>1111 1111 1111 1111 1111 1111 1111 1111   =   //-1补码</code><br><code>1111 1111 1111 1111 1111 1111 1111 1101       //临时码</code><br>高位不变其他位取反：<br><code>1000 0000 0000 0000 0000 0000 0000 0010       //结果原码</code><br>一眼就看出这是-2.<br>其实所谓的一眼看出，不过是让最高位符号匹配后面的正数。</p>
<p><em>参考:</em></p>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/105917577" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105917577</a> 【原创】计算机为什么要用补码？ - kaka的文章 - 知乎</li>
<li><a href="https://zh.wikipedia.org/wiki/原码" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/原码</a></li>
<li><a href="https://zh.wikipedia.org/wiki/反码" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/反码</a></li>
<li><a href="https://zh.wikipedia.org/wiki/补码" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/补码</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 801.二进制中1的个数</title>
    <url>/2020/11/04/AcWing-801-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>lowbit的经典应用。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。</p>
<p><strong>输入格式</strong><br>第一行包含整数n。<br>第二行包含n个整数，表示整个数列。</p>
<p><strong>输出格式</strong><br>共一行，包含n个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中1的个数。</p>
<p><strong>数据范围</strong><br>1≤n≤100000,<br>0≤数列中元素的值≤1e9</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 2 3 4 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>1 1 2 1 2</p>
</blockquote>
<hr>
<p>本题考查二进制，运用lowbit可快速得出结果。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请参考：<a href="https://fingerdance.plus/2020/10/25/位运算妙妙屋/" target="_blank" rel="noopener">位运算妙妙屋</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (; n --;) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x) s ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>对于每个数，循环减去最后一个<code>1</code>，直到数字变成<code>0</code>。每次减<code>1</code>，<code>res</code>加<code>1</code>.<br>注意，这里的减<code>1</code>是指减最后一个<code>1</code>包括后面的所有<code>0</code>.</li>
</ol>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>lowbit</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 799.最长连续不重复子序列</title>
    <url>/2020/11/04/AcWing-799-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的双指针题目。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<p><strong>输入格式</strong><br>第一行包含整数n。</p>
<p>第二行包含n个整数（均在0~100000范围内），表示整数序列。</p>
<p><strong>输出格式</strong><br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<p><strong>数据范围</strong><br>1≤n≤100000<br><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 2 2 3 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<hr>
<h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><p>双指针的核心思想，是在暴力求解的基础上，通过已知的某种性质，用两个指针进行优化。<br>维护两个指针<code>i</code>，<code>j</code>，维护一个计数数组，<code>i</code>负责遍历原数组，在此过程中用计数数组计数。当i到某一个位置对应的计数数组数值超过1，则认为从<code>j</code>到<code>i</code> 这一段出现了重复。当前最长不重复段为<code>i - j + 1</code>. 接下来移动<code>j</code>，并通过计数数组最后一个值监控<code>j</code>扫过的让最后一个值超过1的下标，当j到达这个下标时，我们认为找到了和<code>i</code>处重复的值，那么，<code>j + 1</code>的位置到<code>i</code>这一段不可能出现重复，<code>j</code>在此固定不动，<code>i</code>继续向后遍历，直到遍历完所有数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], S[N];                                     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        S[a[i]] ++;                                 <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span> (;S[a[i]] &gt; <span class="number">1</span>;) &#123;                       <span class="comment">// 2</span></span><br><span class="line">            S[a[j]] --;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>每一次<code>i</code>移动，让对应数字对应的计数数组下标+1</li>
</ol>
</li>
<li><ol start="2">
<li>保持计数数组非零值全为1，一旦<code>i</code>移动后造成对应计数数组值<code>&gt; 1</code>，就认为出现了重复<br>  此时移动<code>j</code>，直到找到<code>i</code>对应的数的重复数字，并且将移动前<code>j</code>对应的数字在计数数组中抹去。此时从<code>j</code>到<code>i</code>都是不重复的。</li>
</ol>
</li>
<li><ol start="3">
<li>计数数组之所以和原数组开一样大的空间，是因为根据题意，原数组每个数大小不超过100000。</li>
</ol>
</li>
<li><strong>计数数组维护序列的不重复性。</strong> 这道题还有个亮点就是计数数组的使用。为了监控不重复序列，维护一个数值始终为0或1的计数数组，每一次<code>i</code>移动，更新计数数组的对应值，一旦该值超过了1，我们就知道出现了重复。妙啊，妙。</li>
</ul>
</blockquote>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/801/" target="_blank" rel="noopener">AcWing 799.最长连续不重复子序列</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计数数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题博客的个性化配置</title>
    <url>/2020/10/31/Hexo%20NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录自己使用Hexo-next主题博客过程中的的一些配置。</p>
<a id="more"></a>

<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><blockquote>
<ul>
<li>在要置顶的文章<code>Front-matter</code>中加入<code>top: true</code></li>
<li>打开：\hexo\themes\next\layout\_macro\post.swig ，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code></li>
<li>在其下方添加代码段：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;### 置顶 ###&#125;</span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;font color&#x3D;5d2b90&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;### 置顶 ###&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="更改行内代码样式"><a href="#更改行内代码样式" class="headerlink" title="更改行内代码样式"></a>更改行内代码样式</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css</li>
<li>新建文件夹：_custom</li>
<li>打开_custom文件夹，新建文件：custom.styl</li>
<li>打开custom.styl，添加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#123;</span><br><span class="line">    color: #5d2b90;</span><br><span class="line">    background: rgba(245, 240, 250, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果想要更改边距，边框等等可以加上：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#123;</span><br><span class="line">    color: #5d2b90;</span><br><span class="line">    margin: 2px;</span><br><span class="line">    border: 1px solid #06a2e4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开：\hexo\themes\next\source\css\main.styl</li>
<li>在末尾加上一行：<code>@import &quot;_custom/custom.styl&quot;;</code></li>
</ul>
</blockquote>
<h3 id="侧边栏目录高亮颜色"><a href="#侧边栏目录高亮颜色" class="headerlink" title="侧边栏目录高亮颜色"></a>侧边栏目录高亮颜色</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Colors</span></span><br><span class="line"><span class="comment">// colors for use across theme.</span></span><br></pre></td></tr></table></figure></li>
<li>在其下方添加颜色：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$purple       &#x3D; #7D26CD;</span><br><span class="line">$purple-bright&#x3D; #a442ff;</span><br><span class="line"> $purple-vs    &#x3D; #5d2b90;</span><br></pre></td></tr></table></figure></li>
<li>定位到：<code>$sidebar-highlight                    =</code>，修改为<code>$purple-vs</code></li>
</ul>
</blockquote>
<h3 id="头像边框宽度"><a href="#头像边框宽度" class="headerlink" title="头像边框宽度"></a>头像边框宽度</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css_variables\base.styl</li>
<li>定位到：<code>$site-author-image-border-width       = 2px;</code></li>
<li>修改为<code>0px</code></li>
</ul>
</blockquote>
<h3 id="文章主体文字行高"><a href="#文章主体文字行高" class="headerlink" title="文章主体文字行高"></a>文章主体文字行高</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css_variables\base.styl</li>
<li>定位到：<code>$line-height-base         = 2;</code></li>
<li>修改为<code>1.6</code></li>
</ul>
</blockquote>
<h3 id="页面加载进度条"><a href="#页面加载进度条" class="headerlink" title="页面加载进度条"></a>页面加载进度条</h3><blockquote>
<ul>
<li>定位到目录<code>cd /hexo/themes/next</code></li>
<li>安装进度条依赖：theme-nexr-pace<br><code>git clone https://github.com/theme-next/theme-next-pace source/lib/pace</code></li>
<li>打开安装目录<code>cd themes/next/source/lib/three</code>，执行更新：<code>git pull</code></li>
<li>打开：\hexo\themes\next_config.yml</li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>设置成<code>true</code></li>
</ul>
</blockquote>
<h3 id="配置Google-Analytic"><a href="#配置Google-Analytic" class="headerlink" title="配置Google Analytic"></a>配置Google Analytic</h3><p>GoogleAnalytic改版又适逢hexo-NexT主题更新，故配置过程有所变化，然而网上教程大多过时了。现详细记录一下自己配置Google Analytic的过程：</p>
<blockquote>
<ul>
<li>打开<code>https://analytics.google.com/analytics</code>并登陆自己的谷歌账号</li>
<li>根据步骤注册一个Analytics account，并且拿到自己的<code>MEASUREMENT ID</code>。<code>MEASUREMENT ID</code>就是<code>tracking_id</code>。</li>
<li>拿到<code>MEASUREMENT ID</code>之后，定位到目录：\hexo\themes\next\layout_partials\header，创建一个文件<code>header.swig</code>。如果你用了其他主题，大概位置也是这里，但是文件后缀可能不一样，文件名形如<code>header.xxx</code>。可以自行验证，如果打开文件和下方代码不同则不是我们要找的。在新版NexT主题配置过程中，该文件需要我们手动创建。</li>
<li>打开文件，填入一下代码（<code>MEASUREMENT ID</code>换成自己的）：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;</span><br><span class="line">&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;MEASUREMENT ID&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.dataLayer &#x3D; window.dataLayer || [];</span><br><span class="line">  function gtag()&#123;dataLayer.push(arguments);&#125;</span><br><span class="line">  gtag(&#39;js&#39;, new Date());</span><br><span class="line">  gtag(&#39;config&#39;, &#39;MEASUREMENT ID&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>打开：\hexo\themes\next\_config.yml ，定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: </span></span><br></pre></td></tr></table></figure></li>
<li>在<code>header</code>后添加刚才创建的文件路径，并且取消本行注释：<code>header: T:\Blog\root\hexo\themes\next\layout\_partials\header\header.swig</code></li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Google Analytics</span></span><br><span class="line"> <span class="attr">google_analytics:</span></span><br><span class="line">   <span class="attr">tracking_id:</span></span><br></pre></td></tr></table></figure></li>
<li>在<code>tracking_id:</code>后填上自己的<code>MEASUREMENT ID</code></li>
<li>部署完毕</li>
</ul>
</blockquote>
<h3 id="修复Pjax导致的图片显示异常"><a href="#修复Pjax导致的图片显示异常" class="headerlink" title="修复Pjax导致的图片显示异常"></a>修复Pjax导致的图片显示异常</h3><p>在官方对Pjax插件的说明中，我们可以看到其明确表示启用Pjax插件必须配合文章中的图片使用绝对路径才能让图片正常显示：<br><a href="https://theme-next.js.org/docs/third-party-services/external-libraries" target="_blank" rel="noopener">https://theme-next.js.org/docs/third-party-services/external-libraries</a><br>“Please use the <strong>absolute path</strong> of the image or Hexo asset_img tag in your posts, <strong>otherwise the images may fail to load during Pjax refresh.</strong>“<br>我们使用<code>hexo-asset-image</code>插件后，执行<code>hexo new &quot;new title&quot;</code>新建文章后，会在文章所在_post目录下同时新建一个与文章同名的目录。当需要插入图片时，只需将图片放入该目录中，并且在文章内引用图片即可。</p>
<blockquote>
<ul>
<li>在使用Pjax之前，我们的引用方式为：<br><code>![picture name in post](new title/image.jpg)</code></li>
<li>使用Pjax后，需要改为绝对路径：<br><code>![picture name in post](image.jpg)</code></li>
</ul>
</blockquote>
<h3 id="设置点击头像回到主页"><a href="#设置点击头像回到主页" class="headerlink" title="设置点击头像回到主页"></a>设置点击头像回到主页</h3><blockquote>
<ul>
<li>打开hexo\themes\next\layout_partials\sidebar\site-overview.swig</li>
<li>定位到: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot; alt&#x3D;&quot;&#123;&#123; author &#125;&#125;&quot;</span><br><span class="line">  src&#x3D;&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>更改为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">  &lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot; alt&#x3D;&quot;&#123;&#123; author &#125;&#125;&quot;</span><br><span class="line">    src&#x3D;&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="更改标题悬浮颜色"><a href="#更改标题悬浮颜色" class="headerlink" title="更改标题悬浮颜色"></a>更改标题悬浮颜色</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css_common\components\post\post-header.styl</li>
<li>定位到：<code>.posts-expand .post-title-link {</code>，在其下方：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;:hover::before &#123;</span><br><span class="line">  transform: scaleX(1);</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;:hover&#123;</span><br><span class="line">   color:$purple-vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的颜色<code>$purple-vs</code>在\hexo\themes\next\source\css\_variables\base.styl定义。</li>
</ul>
</blockquote>
<h3 id="更改超链接悬浮颜色"><a href="#更改超链接悬浮颜色" class="headerlink" title="更改超链接悬浮颜色"></a>更改超链接悬浮颜色</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">Global</span> <span class="string">link</span> <span class="string">color.</span></span><br><span class="line"><span class="string">$link-color</span>                   <span class="string">=</span> <span class="string">$black-light;</span></span><br><span class="line"><span class="string">$link-color-dark</span>              <span class="string">=</span> <span class="string">$grey-light;</span></span><br><span class="line"><span class="string">$link-hover-color</span>             <span class="string">=</span> <span class="string">$black-deep;</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>$link-hover-color</code>值更改为<code>$purpl-vs</code></li>
</ul>
</blockquote>
<h3 id="更改导航悬浮颜色"><a href="#更改导航悬浮颜色" class="headerlink" title="更改导航悬浮颜色"></a>更改导航悬浮颜色</h3><blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sidebar-nav-color                    &#x3D; $grey-dim;</span><br><span class="line">$sidebar-nav-hover-color              &#x3D; $whitesmoke;</span><br></pre></td></tr></table></figure></li>
<li>更改<code>sidebar-nav-hover-color</code>的值为<code>purple-vs</code></li>
</ul>
</blockquote>
<h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h3><p>今天，我给自己的博客换上了 <strong>衬线（serif)字体</strong>，没想到效果这么好。<br>中文字体：Noto Serif SC (思源宋体)<br>英文字体：Maitree (跟宋体绝配)<br>要想中英文字体同时更改，需要在两个地方设置。首先设置全局字体为Maitree，再单独修改中文字体为思源宋体。<br>步骤：<br><strong>修改全局英文字体：</strong></p>
<blockquote>
<ul>
<li>打开：\hexo\themes\next\_config.yml ，定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>enable: false</code>改为<code>true</code>。</li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>family: Lato</code>改为<code>Maitree</code>。</li>
</ul>
</blockquote>
<p><strong>修改中文字体：</strong></p>
<blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<br><code>$font-family-chinese      = &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;;</code></li>
<li>修改为：<code>&quot;Noto Serif SC&quot;;</code></li>
<li>打开：..\hexo\themes\next\layout\_partials\header\header.swig</li>
<li>文末添加：<br><code>&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Serif+SC&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;</code></li>
<li>打开：..\hexo\themes\next\_config.yml ，定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br></pre></td></tr></table></figure></li>
<li>head行修改为：</li>
<li><code>head: ..\hexo\themes\next\layout\\_partials\header\header.swig</code></li>
</ul>
</blockquote>
<h3 id="版权声明引用样式更改"><a href="#版权声明引用样式更改" class="headerlink" title="版权声明引用样式更改"></a>版权声明引用样式更改</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css\_common\components\post\post-copyright.styl</li>
<li>修改颜色从<code>$red</code>为<code>$purple-vs</code>，其中，<code>$purple-vs</code>在<br>\hexo\themes\next\source\css\_variables\base.styl中定义。</li>
</ul>
</blockquote>
<h3 id="引用Note颜色更改"><a href="#引用Note颜色更改" class="headerlink" title="引用Note颜色更改"></a>引用Note颜色更改</h3><p>在Markdown中使用Note时：</p>
<div class="note primary">
            <p>whatever</p>
          </div>
<p>会在文章中插入块引用。<br><strong>更改引用边框颜色：</strong></p>
<blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Primary</span><br><span class="line">$note-primary-border        &#x3D; #6f42c1;</span><br></pre></td></tr></table></figure></li>
<li>更改颜色值为：<code>#5d2b90</code></li>
</ul>
</blockquote>
<p><strong>更改引用背景色：</strong></p>
<blockquote>
<ul>
<li>在上文基础上更改<code>$note-primary-bg</code>值为: <code>var(--card-bg-color);</code><br>该颜色为版权声明块背景色，这样可让二者相互适配。</li>
</ul>
</blockquote>
<h3 id="更改分割线样式"><a href="#更改分割线样式" class="headerlink" title="更改分割线样式"></a>更改分割线样式</h3><blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_common\scaffolding\base.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hr &#123;</span><br><span class="line">  background-image: repeating-linear-gradient(-45deg, $grey-lighter, $grey-lighter 4px, transparent 4px, transparent 8px);</span><br></pre></td></tr></table></figure></li>
<li>修改为：<br>background-image: linear-gradient(0deg, $purple-vs, $purple-vs 1px, transparent 1px, transparent 1px);</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>记录对hexo yilia主题的个性定制</title>
    <url>/2020/10/30/%E8%AE%B0%E5%BD%95%E5%AF%B9hexo-yilia%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%AE%9A%E5%88%B6/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录在使用hexo-yilia主题时的一些定制选项。</p>
<a id="more"></a>
<h3 id="1-隐藏多余的「展开更多」"><a href="#1-隐藏多余的「展开更多」" class="headerlink" title="1. 隐藏多余的「展开更多」"></a>1. 隐藏多余的「展开更多」</h3><blockquote>
<ul>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>定位到<code>&lt;a class=&quot;.article-more-a&quot; href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;</code></li>
<li>行内添加<code>style=“display: none;”</code></li>
</ul>
</blockquote>
<h3 id="2-显示文章阅读次数"><a href="#2-显示文章阅读次数" class="headerlink" title="2. 显示文章阅读次数"></a>2. 显示文章阅读次数</h3><blockquote>
<ul>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>定位到<code>&lt;div class=&quot;article-inner&quot;&gt;</code></li>
<li>定位到<code>&lt;header class=&quot;article-header&quot;&gt;</code></li>
<li>在<code>&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;</code>下添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示阅读次数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"cloud-tie-join-count"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">style</span>=<span class="string">"color:gray;font-size:14px;"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-sort"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"color:#696969;font-size:14px;"</span>&gt;</span></span><br><span class="line">           阅读数: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次 <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--显示阅读次数--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="3-添加文章字数统计和阅读时长"><a href="#3-添加文章字数统计和阅读时长" class="headerlink" title="3. 添加文章字数统计和阅读时长"></a>3. 添加文章字数统计和阅读时长</h3><blockquote>
<ul>
<li>安装wordcount插件: <code>npm i –save hexo-wordcount</code></li>
<li>打开theme\yilia\layout_partial\post，创建<code>word.ejs</code>文件</li>
<li>在<code>word.ejs</code>中写入:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:10px;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-keyboard-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>  字数统计: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">wordcount</span>(<span class="attr">post.content</span>) %&gt;</span>字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-hourglass-half"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>  阅读时长: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">min2read</span>(<span class="attr">post.content</span>) %&gt;</span>分<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>在<code>&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;</code>下添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示文章字数统计以及阅读时长--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.word_count</span> &amp;&amp; !<span class="attr">post.no_word_count</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">word</span>') %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--显示文章字数统计以及阅读时长--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="4-添加页面顶部加载条"><a href="#4-添加页面顶部加载条" class="headerlink" title="4. 添加页面顶部加载条"></a>4. 添加页面顶部加载条</h3><blockquote>
<ul>
<li>打开theme\yilia\layout_partial\head.ejs</li>
<li>定位到：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">title</span>)&#123; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span> | <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在其下方添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--顶部加载条--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">background</span>: <span class="selector-id">#6d6d6d</span>; <span class="comment">/*进度条颜色*/</span></span></span><br><span class="line">       height: 2px;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress-inner</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#1E92FB</span>, 0 0 5<span class="selector-tag">px</span>     <span class="selector-id">#6d6d6d</span>; <span class="comment">/*阴影颜色*/</span></span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-activity</span> &#123;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">border-top-color</span>: <span class="selector-id">#6d6d6d</span>;    <span class="comment">/*上边框颜色*/</span></span></span><br><span class="line"><span class="css">       <span class="selector-tag">border-left-color</span>: <span class="selector-id">#6d6d6d</span>;    <span class="comment">/*左边框颜色*/</span></span></span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--顶部加载条--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 788.逆序对的数量</title>
    <url>/2020/10/27/AcWing-788.%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>归并排序模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 <code>n</code> 的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 <code>i</code> 个和第 <code>j</code> 个元素，如果满足 <code>i &lt; j</code> 且 <code>a[i] &gt; a[j]</code>，则其为一个逆序对；否则不是。</p>
<p><strong>输入格式</strong><br>第一行包含整数 <code>n</code> ，表示数列的长度。</p>
<p>第二行包含 <code>n</code> 个整数，表示整个数列。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。</p>
<p><strong>数据范围</strong><br>$1≤n≤100000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>6<br>2 3 4 5 6 1</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5</p>
</blockquote>
<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nums[N];</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    helper(lo, mid), helper(mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid &amp;&amp; j &lt;= hi;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) tmp[t++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid;) tmp[t++] = nums[i++];</span><br><span class="line">    <span class="keyword">for</span> (;j &lt;= hi;) tmp[t++] = nums[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi;) nums[i++] = tmp[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">    helper(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>跑路专用呆湾警署查封页面</title>
    <url>/2020/10/25/%E8%B7%91%E8%B7%AF%E4%B8%93%E7%94%A8%E5%91%86%E6%B9%BE%E8%AD%A6%E7%BD%B2%E6%9F%A5%E5%B0%81%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>显示台湾警察署查封网站的页面html源码。</p>
<a id="more"></a>
<p>效果图：<br><img src="img.jpg" alt="pic0x0"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-TW"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>網站已遭查禁<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Fonts --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span>  <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>  <span class="attr">integrity</span>=<span class="string">"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            font-family: 'Raleway', sans-serif;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">            -webkit-font-smoothing: antialiased;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            h1, h2, h3, h4, h5&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">font-family</span><span class="selector-pseudo">:'Montserrat'</span>, <span class="selector-tag">sans-serif</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="css">            <span class="selector-class">.img-content</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            align-content: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: auto;</span><br><span class="line">            height: 50%;</span><br><span class="line">            top: -50%;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            align-content: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: auto;</span><br><span class="line">            height: 50%;</span><br><span class="line">            top: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:3</span>%;</span></span><br><span class="line">            align-content: center ;</span><br><span class="line">            margin: auto 5% auto 5% ;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">top</span>, <span class="selector-id">#30cfd0</span> 0%, <span class="selector-id">#330867</span> 100%);</span></span><br><span class="line">            border-radius: 20px;</span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 6<span class="selector-tag">px</span> <span class="selector-id">#cccccc</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line">            font-family: "Microsoft JhengHei" ;</span><br><span class="line">            font-size: 50px;   </span><br><span class="line"><span class="css">            <span class="selector-tag">margin-top</span><span class="selector-pseudo">:1</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-bottom</span><span class="selector-pseudo">:3</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: <span class="selector-class">.9</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line">            font-size: 24px;</span><br><span class="line">            padding: 20px 0;</span><br><span class="line">            font-weight: 300;</span><br><span class="line">            width: 70%;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;script async src='/cdn-cgi/bm/cv/2172558837/api.js'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"bg-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:-11%;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://i.niupic.com/images/2020/04/10/7mLl.jpeg"</span> <span class="attr">style</span>=<span class="string">"align-content: center;text-align: center;width: 40%;height: auto; margin: auto auto 1% auto; "</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-12 text-center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:firebrick;"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>網站已經遭到查禁<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>(This Domain Has Been Seized)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>已經違背中華民國著作權法第九十一條及九十二條規範，全部或部分內容涉屬盜版，正進入司法偵查中。<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                        The website is in violation of the Copyright Act of the Republic of China (Taiwan) for its unauthorized use of materials.  Investigation is currently underway.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span>內政部警政署刑事警察局電偵大隊 敬啟 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                        Criminal Investigation Bureau（Taiwan）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">window</span>[<span class="string">'__CF$cv$params'</span>]=&#123;<span class="attr">r</span>:<span class="string">'580bbb10ab56988d'</span>,<span class="attr">m</span>:<span class="string">'89a8a3de2b7eced49bf0d7d5400be20e69b51188-1586346206-1800-AXfMipt69xS9k39OseM0Cvbr0f3Kbs2a6i15NQFaHcJ2EE29f4nRPtpVQp/KgduXqsjmOfivLCxx7gGaor0X8kEbM7J50HQX16lmdjp4bzFe+Nr/xYV+BXL01+ME0Wcofw=='</span>,<span class="attr">s</span>:[<span class="number">0xde0ce21efa</span>,<span class="number">0xa321d7537b</span>],<span class="attr">fb</span>:<span class="number">0</span>,&#125;&#125;)();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
  </entry>
  <entry>
    <title>位运算妙妙屋</title>
    <url>/2020/10/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%A6%99%E5%A6%99%E5%B1%8B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>位运算使用技巧。</p>
<a id="more"></a>
<h3 id="1-int类型利用位运算乘除2的k次幂"><a href="#1-int类型利用位运算乘除2的k次幂" class="headerlink" title="1. int类型利用位运算乘除2的k次幂"></a>1. int类型利用位运算乘除2的k次幂</h3><p>a乘以2的k次幂，相当于a &lt;&lt; k 不管a是否为正数。<br>a除以2的k次幂，相当于a &gt;&gt; k 当且仅当a为正数。<br>注意，其他类型不常用，有的可以有的不可以，故不列出。</p>
<h3 id="2-判断二进制数的第k位"><a href="#2-判断二进制数的第k位" class="headerlink" title="2. 判断二进制数的第k位"></a>2. 判断二进制数的第k位</h3><p>首先明确第k位是指从右边最低位向左边最高位第<code>k</code>位。注意低位是从0开始计算，这样也是方便适配左移右移位数。和循环计数一般从0开始一个道理。<br>代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">m = x &gt;&gt; k &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>右移k位就把第k位移到了最低位，再判断该位置数字。</p>
<h3 id="3-二进制数最后一位1的————lowbit-x"><a href="#3-二进制数最后一位1的————lowbit-x" class="headerlink" title="3. 二进制数最后一位1的————lowbit(x)"></a>3. 二进制数最后一位1的————lowbit(x)</h3><p>这里最后一位1是指从左往右最后一位，函数lowbit()返回的是包含该1与右边所有0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>- x</code> 在计算机内部是以补码方式运算的，即:<br><code>- x = ~ x + 1</code><br>假设一个二进制数为：  0010101…0010100000<br><code>~ x</code>为：            1101010…1101011111<br><code>~ x + 1</code>为：        1101010…1101100000<br>注意到+1操作使得最后一位1及其右边所有数字发生了变化，而左边不变。<br>此时在和原数字进行&amp;运算，它和原数字在最后一位1左侧全部不同，右侧全部相同。</p>
<div class="note primary">
            <p><strong>题目链接：</strong> <a href="https://esp0xa.github.io//2020/11/04/AcWing-801-二进制中1的个数/" target="_blank" rel="noopener">二进制中1的个数</a></p>
          </div>

<h3 id="4-一个获取二进制数中1的个数的轮子"><a href="#4-一个获取二进制数中1的个数的轮子" class="headerlink" title="4. 一个获取二进制数中1的个数的轮子"></a>4. 一个获取二进制数中1的个数的轮子</h3><p><code>__builtin_popcount(unsigned int x)</code><br>用于计算一个32位无符号整数有多少个位为1。<br>类似地，可以用 <code>__builtin_popcountl(unsigned long x)</code> 和 <code>__builtin_popcountll(unsigned long long x)</code> 分别计算无符号 <code>long</code> 和 <code>long long</code> 整数二进制表示中1的位数。</p>
<h3 id="5-二进制数中最高位1距离最低位的距离"><a href="#5-二进制数中最高位1距离最低位的距离" class="headerlink" title="5. 二进制数中最高位1距离最低位的距离"></a>5. 二进制数中最高位1距离最低位的距离</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_len</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; len ++) x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/" target="_blank" rel="noopener">LeetCode 5620.连接连续的二进制数字（Concatenation of Consecutive Binary Numbers）</a></p>
          </div>


<h3 id="6-两个数之间交换位置"><a href="#6-两个数之间交换位置" class="headerlink" title="6. 两个数之间交换位置"></a>6. 两个数之间交换位置</h3><p>我们有<code>int a = 5, int b = 6</code>, 现需要交换二者位置，可以利用异或运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法模板</title>
    <url>/2020/10/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>详尽地记录了各种基础算法模板，以及一些个人理解。</p>
<a id="more"></a>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排最难的地方在于边界问题。边界问题涉及到比较因子的选择以及各种条件判断。建议将模板直接背过。<br>今天看了闫学灿的快排讲解之后，感悟颇多，特地记录下来供以后复习。<br>首先上快排模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//end of recursion</span></span><br><span class="line">    <span class="keyword">int</span> cmp = q[(lo + hi) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = lo - <span class="number">1</span>, j = hi + <span class="number">1</span>; <span class="comment">// 每次指针移动，需要向中间偏移一位，故在这里也初始化设置成lo - 1和hi + 1</span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt; j;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; q[++ i] &lt; cmp; );</span><br><span class="line">        <span class="keyword">for</span> (; q[-- j] &gt; cmp; );</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(q, lo, j); <span class="comment">//                         1</span></span><br><span class="line">    qSort(q, j + <span class="number">1</span>, hi); <span class="comment">//                     2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>j</code> 要么等于 <code>i</code> 要么 <code>j</code> 在 <code>i</code> 左边一位，故其中 <code>1</code> 和 <code>2</code> 可以改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>但是注意，如果 <code>cmp</code> 设置成 <code>q[lo]</code> 的话，则只能是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p>因为如果换成了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>的话会出现死循环问题。<br>举个例子：数组<code>{1, 2}</code>排序，<code>lo = 0, hi = 1, i = -1 , j = 2, cmp = 1</code>.<br>第一轮递归，<code>i = 0, j = 0</code>.<br><code>qSort(q, 0, -1);</code>  直接return.<br><code>qSort(q, 0, 1);</code>   死循环.</p>
<p>同理，如果 <code>cmp</code> 设置成 <code>q[hi]</code> 的话，使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p>也会发生死循环.</p>
<p>所以：<br><strong><code>cmp</code> 设置成 <code>q[lo]</code> 的话，递归调用必须是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p><strong><code>cmp</code> 设置成 <code>q[hi]</code> 的话，递归调用必须是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>为了保险起见，建议将 <code>cmp</code> 设置成中间位置。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是将原数组递归地一分为二，在最短子数组处完成排序，在回溯过程中合并子数组，以完成整个数组的排序。<br>过程感觉很像二叉树的遍历。<br>以下是归并排序模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;                                     <span class="comment">// test data amount range</span></span><br><span class="line"><span class="keyword">int</span> q[N];                                                   <span class="comment">// original array</span></span><br><span class="line"><span class="keyword">int</span> tmp[N];                                                 <span class="comment">// temporary array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;                                   <span class="comment">// end of recursion</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;                               </span><br><span class="line">    merge_sort(q, lo, mid), merge_sort(q, mid + <span class="number">1</span>, hi);     <span class="comment">// recursively divides into two</span></span><br><span class="line">    <span class="comment">// backtrack progress</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;                                 </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;                                              <span class="comment">// index of temporary array            </span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid &amp;&amp; j &lt;= hi;)                             <span class="comment">// puts smaller one into tmp[]</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[t++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[t++] = q[j++]; </span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid;) tmp[t++] = q[i++];                     <span class="comment">// puts remaining array into tmp[]</span></span><br><span class="line">    <span class="keyword">for</span> (;j &lt;= hi;) tmp[t++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi;) q[i++] = tmp[j++];    <span class="comment">// overrides original array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为一分为二的过程一共持续 <strong><em>log(N)</em></strong> 次（以2为底）,把数放入 <code>tmp[]</code> 再覆盖原数组需要 <strong><em>O(N)</em></strong>。<br>故时间复杂度为 <strong><em>ONlog(N)</em></strong> </p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="整数二分查找"><a href="#整数二分查找" class="headerlink" title="整数二分查找"></a>整数二分查找</h3><p>一般涉及到单调性的问题，查找某个边界，可以使用二分查找。但是二分查找不仅仅只适用于单调性问题。<br>即：<br>单调性问题查找一定可以用二分，非单调性问题也有可能可以用二分。<br>二分查找的本质目的是：<br><strong>在一个整数区间上，前一段满足某种性质A，后一段满足另一性质B。使用二分查找找到满足性质A的边界点edgeA或者满足性质B的边界点edgeB。</strong><br><code>____________Satisfied A______________| |___________Satisfied B________________</code><br>整个查找过程围绕“性质”展开，不断更新<code>mid</code>值，从两个方向逼近边界。：<br><strong>找A的边界，mid从A向右更新</strong><br>当<code>mid</code>满足条件A时，A的边界至少可以取到<code>mid</code>；<br><strong>找B的边界，mid从B向左更新</strong><br>当<code>mid</code>满足条件B时，B的边界最多可以取到<code>mid</code>；</p>
<p>整数二分查找模板：<br><strong>查找A边界</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finds edge A</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;lo &lt; hi;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;                      <span class="comment">//  1</span></span><br><span class="line">        <span class="keyword">if</span> (is_satisfied_B(mid)) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找B边界</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finds edge B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;lo &lt; hi;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;                   <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (is_satisfied_A(mid)) lo = mid;</span><br><span class="line">        <span class="keyword">else</span> hi =  mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：2处为了防止边界问题，需要在计算mid的时候加一。</strong></p>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">AcWing 802.区间和</a></p>
</blockquote>
<h3 id="浮点数二分查找"><a href="#浮点数二分查找" class="headerlink" title="浮点数二分查找"></a>浮点数二分查找</h3><h4 id="根据精度迭代"><a href="#根据精度迭代" class="headerlink" title="根据精度迭代"></a>根据精度迭代</h4><p>因为是找浮点数，所以可以不用考虑边界问题。<br><strong>例子：</strong><br>求数字x的开方。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">0</span>, hi = <span class="built_in">max</span>(<span class="number">1</span>, x);                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (;hi - lo &gt; <span class="number">1e-8</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, lo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意1处当<code>x&lt;1</code>时，右边界是1。因为小于1的数，开方比自己大。<code>x&gt;1</code>时，右边界当然可以取到<code>x</code>。<br>题目中一般会给出<code>x</code>的取值范围，如 <code>-10000 &lt; x &lt; 10000</code>，那么<code>lo</code>和<code>hi</code>可以分别初始化为<code>-10000</code>和<code>10000</code>。<br>根据经验，如果题目要求保留<code>n</code>位有效数字，那么一般<code>lo</code>和<code>hi</code>之间判定的精度为<code>1e-(n + 2)</code>。</p>
<h4 id="根据循环次数迭代"><a href="#根据循环次数迭代" class="headerlink" title="根据循环次数迭代"></a>根据循环次数迭代</h4><p>这是浮点数二分的另一种写法，直接循环个<code>100</code>次。<br>如上题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">0</span>, hi = <span class="built_in">max</span>(<span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, lo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这相当于把lo到hi范围缩小2的100次方倍。（100次2分）<br>因为2的100次幂足够大，所以结果是正确的。</p>
<h2 id="高精度四则运算"><a href="#高精度四则运算" class="headerlink" title="高精度四则运算"></a>高精度四则运算</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>两个 <strong>超长位数正整数</strong> 相加，一般是以 <strong>字符串</strong> 形式读取整数，再把整数放入 <strong>数组</strong> 中，进行模拟加法运算。<br><strong>模板1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span>                             <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)                      <span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);                                                  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<blockquote>
<ol>
<li>以数组引用传入参数，可以避免没必要的数组拷贝。</li>
<li><code>A</code>或<code>B</code>至少有一个没有遍历完，都需要继续计算。</li>
<li>注意结束之后进位有可能非0.</li>
</ol>
</blockquote>
<p>该模板可以改写成总是模拟以一个更长的数组加长度较小的数组：<br><strong>模板2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，就可以只考虑遍历较长数组，只进行一次长度判断。</p>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://fingerdance.plus/2020/11/08/AcWing-791-高精度加法/" target="_blank" rel="noopener">AcWing 791.高精度加法</a></p>
</blockquote>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>两个超长正整数相减。因为结果可能为负数，负数的时候输出需要在最前面补<code>&#39;-&#39;</code>。<br><code>A B</code>相减最核心的部分，<code>A</code>总是大于等于<code>B</code>的，这样可以只遍历<code>A</code>，对对应的<code>B</code>有无数字进行判断。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C = A - B， A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return if A &gt;= B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A - B while A &gt;= B</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="comment">// consider if should sub slot of B</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        <span class="comment">// t might be a negative</span></span><br><span class="line">        <span class="comment">// t will be the right slot whatever its negative or positive</span></span><br><span class="line">        <span class="comment">// t + 10 means it will borrow 10 from next slot</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);                                          <span class="comment">//1</span></span><br><span class="line">        <span class="comment">// update t</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;                    </span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there might be some '0' in back of C</span></span><br><span class="line">    <span class="comment">// dont't have to remove while C.size() == 1</span></span><br><span class="line">    <span class="keyword">for</span> (; C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>; ) C.pop_back();                    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B, C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B)) C = sub(A, B);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>此处<code>t</code>有可能被减成了负数（最低可以取到-10，最高可取到9），此时向后一位借10，于是最低取到0；同时由于借10的时候并没有判断正负，所以+10可能会导致结果高于10。也就是说，此时运算过程放入<code>C</code>中的数可能的取值范围是：<code>(0, 19)</code>。这样我对10取模，即可得到正确的放入<code>C</code>中的数了。<br>注意，在把“优化”后的（指借位模10）运算结果放入<code>C</code>时，并没有把结果赋值给<code>t</code>，因为后面需要判断<code>t</code>的正负，以更新下一轮的<code>t</code>取值。如果赋值了，则<code>t</code>必然为正，无法更新进位信息。</li>
<li>注意当A与B前几位部分相等时，C后面会存在’0’，如<code>123 - 120</code>结果类似<code>003</code>。但在结果仅为1位时，不用考虑。</li>
</ol>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://fingerdance.plus/2020/11/08/AcWing-792-高精度减法/" target="_blank" rel="noopener">AcWing 792.高精度减法</a></p>
</blockquote>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><p>一个超长正整数乘一个普通int正整数。模拟相乘过程把普通int整数看成一个整体。<br><strong>模板1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )                       <span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);                                        <span class="comment">//2</span></span><br><span class="line">        t /= <span class="number">10</span>;                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意1处条件，当A没有遍历完的时候，需要一直和b相乘，更新进位t。当乘完的时候，依然进入处理进位t，只不过此时不需要和b相乘，而是直接模10获得最高位数。</li>
<li>放入slot中的数一直都是对10取模。</li>
<li>当小整数为0，而大数不止一位时，结果会产生多个0.此时需要消除多个0.</li>
</ol>
</blockquote>
<p>当然也可以在遍历完A后再处理最终进位问题，即：<br><strong>模板2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] * b + t;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">for</span> (;C.<span class="built_in">size</span>() &gt;  &amp;&amp; C.back() == <span class="number">0</span>;) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在处理最终进位<code>t</code>的时候，模板1是对<code>t</code>再进入循环处理，这时候如果<code>t &lt; 10</code>的话，只循环一次，但是如果<code>t &gt;= 10</code>的话，需要反复进入循环，依次取模，除10.</p>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://fingerdance.plus/2020/11/09/AcWing-793-高精度乘法/" target="_blank" rel="noopener">AcWing 793.高精度乘法</a></p>
</blockquote>
<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><p>一个超长正整数除以一个短正整数。<br>和高精度加减乘不一样的是，高精度除法是从大整数高位开始的。在复习了小学二年级下册的相关内容后，我觉得算法基本上就是模拟除法竖式。<br>高精度加计算过程会产生进位，减计算过程会产生借位，乘计算过程会产生进位，而高精度除法计算过程会产生余数。<br>余数作为下一位的高位需要乘10进行新一轮的除法运算。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;                                                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];                                      <span class="comment">// 2</span></span><br><span class="line">        C.push_back(r / b);                                     <span class="comment">// 3</span></span><br><span class="line">        r %= b;                                                 <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());                                <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();         </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>初始化余数<code>r</code>aka <code>remain</code>。</li>
<li>对于被除数<code>A</code>的每一位，需要将上一位除法运算产生的余数作为当前数的高位乘10加上当前数。</li>
<li>用当前数作为被除数和除数<code>b</code>进行除法运算，放到结果槽中。</li>
<li>将余数保留给下一位。</li>
<li>首位可能产生0，所以我们将结果数组反转再去除结尾0.</li>
</ol>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://fingerdance.plus/2020/11/09/AcWing-794-高精度除法/" target="_blank" rel="noopener">AcWing 794.高精度除法</a></p>
</blockquote>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>对于一个给定数组<code>alls[N]</code>，其前缀和数组<code>s[N]</code>对应着对于<code>alls[N]</code>的每一个元素，其前缀所有元素（包括这一位）之和。<br>前缀和数组的应用一般伴随着一些查询操作，一个查询操作就是给定一个区间范围，让你求该范围内数的和。<br>另外，注意构造前缀和数组是从下标1开始构造，整体数目不变。相当于是数组下标向右偏移一位。这是因为构造前缀和数组的每一位需要依赖其前一位。当构造第1位时，需要依赖第0位。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://fingerdance.plus/2020/11/10/AcWing-795-前缀和/" target="_blank" rel="noopener">AcWing 795.前缀和</a></p>
</blockquote>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针的核心思想，是在暴力求解的基础上，通过已知的某种性质，用两个指针进行优化。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见问题分类：</p>
<blockquote>
<ul>
<li>对于一个序列，用两个指针维护一段区间</li>
<li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://fingerdance.plus/2020/11/04/AcWing-799-最长连续不重复子序列/" target="_blank" rel="noopener">AcWing 799.最长连续不重复子序列</a></p>
</blockquote>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>当有一堆数，总量不多，比如说1e5，不算多，但是每个数可能取到很大值或很小值，比如说最大取到1e10。那么在需要把数值当成数组下标进行操作的时候，比如说计数数组，无法开出如此大空间的数组，这时候就需要离散化操作。<br>离散化：把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line">sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>离散化的映射，主要是将待离散化的数放到容器中，进行排序、去重，再用二分查找找到对应下标，将下标放到一个数组中。</li>
<li>排序：一般是通过二分查找的方式进行下标映射，所以需要对原数据排序。</li>
<li>去重：因为要将待离散化数映射成各自的下标，所以需要对其去重复。</li>
<li>注意离散化操作的重要前提是，原数据本身的值并不重要，我们不感兴趣，重要的是其位置。</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://www.fingerdance.plus/2020/11/06/AcWing-802-区间和" target="_blank" rel="noopener">AcWing 802.区间和</a></p>
</blockquote>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p>现有若干区间，相互之间可能相交。将所有相交的区间合并为一个区间，返回合并后的区间。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    sort(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());                             <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;                                   <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)                                     <span class="comment">// 3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);            <span class="comment">// 4 </span></span><br><span class="line">            st = seg.first, ed = seg.second;                    <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);                          <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);                    <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>segs</code>存放的是所有区间的左右端点构成的<code>pair</code>。<br>算法思想是维护一个前置区间，维护一个当前区间。比较两个区间是否相交，不相交就认为前置区间是一个孤立区间。不管是否相交，更新前置区间的左右端点，在更新当前区间左右端点。当最后一个当前区间与其前置区间比较完毕后，不管二者是否相交，最后一次更新前置区间将不会有新的当前区间。此时新的前置区间将必然是一个孤立区间。</p>
<blockquote>
<ul>
<li><ol>
<li>区间按照左端点排序。<code>sort()</code>用于排序<code>pair</code>类时，默认按照左端点升序排序。</li>
</ol>
</li>
<li><ol start="2">
<li>初始化区间左右端点，后面会更新它们。这里是初始化为无穷小（相对来说），初始化值在不同题目可以按需调整。</li>
</ol>
</li>
<li><ol start="3">
<li>比较两个区间是否相交。</li>
</ol>
</li>
<li><ol start="4">
<li>因为初始化的前置区间是无穷小的一个点，所以当前区间是第一个区间时，必然成立。但我们不能将无穷小点放入<code>res</code>中。只有在前置区间从第一个区间开始时，满足3的条件才可以放入<code>res</code>中。</li>
</ol>
</li>
<li><ol start="5">
<li>不相交情况下更新前置区间左右端点。</li>
</ol>
</li>
<li><ol start="6">
<li>相交情况下更新前置区间左右端点。（此时只需更新右端点）</li>
</ol>
</li>
<li><ol start="7">
<li>处理最后一个前置区间，此时前置区间必然是孤立区间当且仅当区间集合<code>segs</code>非空时（或者说当且仅当前置区间非初始化值时）</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://www.fingerdance.plus/2020/11/06/AcWing-803-区间合并" target="_blank" rel="noopener">AcWing 803.区间合并</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
        <tag>算法模板</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>二分查找</tag>
        <tag>高精度四则运算</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
        <tag>位运算</tag>
        <tag>离散化</tag>
        <tag>区间合并</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>使用youtube-dl下载YouTube频道所有视频</title>
    <url>/2020/10/19/%E4%BD%BF%E7%94%A8youtube-dl%E4%B8%8B%E8%BD%BDYouTube%E9%A2%91%E9%81%93%E6%89%80%E6%9C%89%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>使用youtube-dl一键下载指定YouTube频道所有视频。</p>
<a id="more"></a>
<p><code>youtube-dl -f &quot;bestvideo[width&gt;=&lt;resolution width such as: 3840&gt;]+bestaudio/best&quot; -ciw -o &quot;%(title)s.%(ext)s&quot; -v &lt;channel url like: xxx/channel/xxx&gt; --download-archive downloaded.txt</code></p>
<blockquote>
<p>-f, –format FORMAT<br>    video format code. with adding <code>bestvideo[width&gt;=3840]+bestaudio/best</code> youtube-dl will pick the quality &gt;= 4K</p>
</blockquote>
<blockquote>
<p>-c, –continue<br>    force resume of partially downloaded files</p>
</blockquote>
<blockquote>
<p>-i, –ignore-errors<br>    continue on download errors, for example to skip unavailable videos in a channel </p>
</blockquote>
<blockquote>
<p>-w, –no-overwrites<br>    do not overwrite files</p>
</blockquote>
<blockquote>
<p>-o, –output<br>    Output filename template, this example functions similarly to the old –title option</p>
</blockquote>
<blockquote>
<p>-v, –verbose<br>    print various debugging information</p>
</blockquote>
<blockquote>
<p>with –download-archive download.txt flag you gonna archive all videos’ info so that you can ezlly resume download.<br>-f </p>
</blockquote>
<p><em>reference:</em></p>
<blockquote>
<p><a href="https://askubuntu.com/questions/856911/using-youtube-dl-to-download-entire-youtube-channel" target="_blank" rel="noopener">https://askubuntu.com/questions/856911/using-youtube-dl-to-download-entire-youtube-channel</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>YouTube</tag>
        <tag>youtube-dl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字符串及其指针类型定义</title>
    <url>/2020/10/01/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Meaning in MBCS builds</th>
<th align="center">Meaning in Unicode builds</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WCHAR</td>
<td align="center">wchar_t</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">LPSTR</td>
<td align="center">char*</td>
<td align="center">char*</td>
</tr>
<tr>
<td align="center">LPCSTR</td>
<td align="center">const char*</td>
<td align="center">const char*</td>
</tr>
<tr>
<td align="center">LPWSTR</td>
<td align="center">wchar_t*</td>
<td align="center">wchar_t*</td>
</tr>
<tr>
<td align="center">LPCWSTR</td>
<td align="center">wchar_t*</td>
<td align="center">wchar_t*</td>
</tr>
<tr>
<td align="center">TCHAR</td>
<td align="center">TCHAR char</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">LPTSTR</td>
<td align="center">TCHAR*</td>
<td align="center">TCHAR*</td>
</tr>
<tr>
<td align="center">LPCTSTR</td>
<td align="center">const TCHAR*</td>
<td align="center">const TCHAR*</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 559 N叉树的最大深度（Maximum Depth of N-ary Tree）</title>
    <url>/2020/08/31/LeetCode-559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88Maximum-Depth-of-N-ary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>例如，给定一个 <code>3叉树</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">   &#x2F;   |   \</span><br><span class="line">  3    2    4</span><br><span class="line"> &#x2F; \   </span><br><span class="line">5   6</span><br></pre></td></tr></table></figure>
<p>我们应返回其最大深度，3。<br>说明:</p>
<blockquote>
<p>1.树的深度不会超过 1000。<br>2.树的节点总不会超过 5000。</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>没啥可说的，和「LeetCode-104-二叉树的最大深度（Maximum-Depth-of-Binary-Tree）」对比，无非就是取最大值的不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.children.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; heights = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Node item : root.children) &#123;</span><br><span class="line">        heights.add(maxDepth(item)); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Collections.max(heights) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，亦可维护一个「最大值变量」，children的每个元素，和它作比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本方法参考HJF的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            result = Math.max(result, <span class="number">1</span> + maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>可以由DFS递归改成迭代，同时维护一个最大值变量，每次出队需要将节点的深度信息和最大值变量作比较。所以节点需要携带深度信息。可以借助<code>pair</code>，也可以写一个新的节点类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本方法参考官方题解</span></span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&lt;Node, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;Node, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      <span class="keyword">int</span> current_depth = current.getValue();</span><br><span class="line">      <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        <span class="keyword">for</span> (Node c : root.children) &#123;</span><br><span class="line">          stack.add(<span class="keyword">new</span> Pair(c, current_depth + <span class="number">1</span>));    </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题亦可使用BFS，但是我不想写了。</p>
<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/</a><br><strong>官方题解：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-zui-da-shen-du-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-zui-da-shen-du-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>树</tag>
        <tag>树深度</tag>
        <tag>N叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>爱的魔力转圈圈：仿shell风火轮进度条实现</title>
    <url>/2020/08/22/%E7%88%B1%E7%9A%84%E9%AD%94%E5%8A%9B%E8%BD%AC%E5%9C%88%E5%9C%88%EF%BC%9A%E4%BB%BFshell%E9%A3%8E%E7%81%AB%E8%BD%AE%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>今天在shell上安装Anaconda的时候，发现安装过程中的「风火轮」进度条很有趣，于是就简单实现了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">icon = [<span class="string">'\\'</span>, <span class="string">'-'</span>, <span class="string">'/'</span>]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">    print(<span class="string">'\rAll work and no play make Jack a dull boy: &#123;&#125;'</span>.format(icon[m % <span class="number">3</span>]), end=<span class="string">''</span>)</span><br><span class="line">    time.sleep(<span class="number">0.25</span>)  <span class="comment"># -- control the r.p.m</span></span><br></pre></td></tr></table></figure>
<p>无非就是把<code>print</code>函数的<code>end=&#39;\n&#39;</code>换成<code>end=&#39;&#39;</code>以便每次打印光标可以回到行首。再就是循环<code>icon</code>列表，制造「动画效果」。<br>比如你要倒计时10s，每0.25s输出一帧，那么就要输出40帧。每一帧依次选取列表的下标可以用m对列表长度取余。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>进度条</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102 二叉树的层序遍历（Binary Tree Level Order Traversal）</title>
    <url>/2020/08/21/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Binary-Tree-Level-Order-Traversal%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 111 二叉树的最小深度（Minimum Depth of Binary Tree）</title>
    <url>/2020/08/21/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%EF%BC%88Minimum-Depth-of-Binary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>本题考查树深度，考虑到树结构的递归特性，可以很容易利用递归去计算。</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>当<code>root</code>节点左右孩子都非空时，二叉树深度最小当且仅当<code>root</code>的左右孩子节点深度取最小。另外，<code>root</code>为空或者<code>root</code>的左或右孩子节点为空的情况可以很容易判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(node.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(node.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dfs(node.left), dfs(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们亦可维护一个「最小值变量」，通过不断和其比较最终得出最小深度。该方法参考官方题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>; <span class="comment">//+1为root节点自身深度。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜素"><a href="#广度优先搜素" class="headerlink" title="广度优先搜素"></a>广度优先搜素</h3><p>可以使用「逐层遍历」方法找到树最小深度。树具有最小深度当且仅当某一层的某节点无左右孩子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>) &#123;  <span class="comment">//size &gt; 0保证一行可以被完全访问</span></span><br><span class="line">                TreeNode cur_node = queue.poll();</span><br><span class="line">                size--;</span><br><span class="line">                TreeNode left = cur_node.left;</span><br><span class="line">                TreeNode right = cur_node.right;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//while size == 0, column over</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>亦可自定义包含深度信息的节点类，此方法参考官方题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueueNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueueNode</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;QueueNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;QueueNode&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> QueueNode(root, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            QueueNode nodeDepth = queue.poll();</span><br><span class="line">            TreeNode node = nodeDepth.node;</span><br><span class="line">            <span class="keyword">int</span> depth = nodeDepth.depth;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a><br><strong>官方题解：</strong> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>树深度</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>树结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104 二叉树的最大深度（Maximum Depth of Binary Tree）</title>
    <url>/2020/08/21/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88Maximum-Depth-of-Binary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>注意和「LeetCode-111-二叉树的最小深度（Minimum-Depth-of-Binary-Tree）」比较学习。</p>
<h3 id="递归（DFS）"><a href="#递归（DFS）" class="headerlink" title="递归（DFS）"></a>递归（DFS）</h3><p>和最小深度不同，当节点仅有左孩子或右孩子，可以直接比较取二者最大值。代码更简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>逐层遍历，每层遍历完之后，深度加一，当整个树遍历完，返回深度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>树</tag>
        <tag>树深度</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 110 平衡二叉树（Balanced Binary Tree）</title>
    <url>/2020/08/18/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Balanced-Binary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<pre><code>一个二叉树 _每个节点_ 的左右两个子树的高度差的绝对值不超过1。</code></pre><p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 <code>true</code> 。<br><strong>示例 2:</strong><br>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 <code>false</code> 。</p>
<hr>
<p>本题绕不开树的高度计算，用到了递归思想（DFS）。从<code>root</code>节点开始向下依次计算每个节点高度，高度为左右孩子节点的高度较大的那个加一，当节点为<code>null</code>时，认为高度为零。<br>Binary TreeNode Definition:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>从<code>root</code>节点开始，比较左右孩子高度差，接着递归比较左右孩子的左右孩子。当出现不平衡条件返回<code>false</code>，一旦某一个子节点出现<code>false</code>，则整个结果是<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(p.left), height(p.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到在计算高度时仍然需要递归，所以这种方法会造成重复遍历。</p>
<h3 id="解法二：自底向上（后序遍历）"><a href="#解法二：自底向上（后序遍历）" class="headerlink" title="解法二：自底向上（后序遍历）"></a>解法二：自底向上（后序遍历）</h3><p>在计算高度的同时可以对平衡性进行判断。一旦出现不平衡情况，直接逐层返回一个特殊值。<br>这是我的原始代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height(root) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个<code>return -1</code>的情况可以合并：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span> || height_right == -<span class="number">1</span> || Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以不用以返回特殊值<code>-1</code>的方式判断不平衡状态，而是定义一个全局变量<code>res</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>树的高度</tag>
        <tag>二叉树遍历</tag>
        <tag>先序遍历</tag>
        <tag>后序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶技术学习心得</title>
    <url>/2020/08/17/%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><blockquote>
<p>项目开始前准备：<br>系好安全带，放下手刹，踩下刹车，启动引擎，踩下离合器。</p>
</blockquote>
<hr>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E5%80%92%E8%BD%A6%E5%85%A5%E5%BA%93.png" alt="pic0x0"><br><strong>左倒库：</strong> </p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向左打满。</li>
<li>step 2: 车身垂直于A线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过A线离合刹车踩满停下，准备左倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与A线重合，方向盘向左打满。</li>
<li>step 5: 此时注意左后视镜L1角，当L1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向右回一圈减小转角。</li>
<li>step 6: 此时注意观察右后视镜，观察当R2角出现时，方向盘迅速回正，此时注意到车身和R线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<p><strong>右倒库：</strong></p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向右打满。</li>
<li>step 2: 车身垂直于B线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过B线离合刹车踩满停下，准备右倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与B线重合，方向盘向右打满。</li>
<li>step 5: 此时注意观察右后视镜R1角，当R1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向左回一圈减小转角。</li>
<li>step 6: 此时注意左后视镜，观察当L2角出现时，方向盘迅速回正，此时注意到车身和L线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BE%A7%E6%96%B9%E5%81%9C%E8%BD%A6.png" alt="pic0x1"><br><strong>将车开出车库至准备区域：</strong></p>
<ul>
<li>step 1: 挂1挡，踩离合，打左转向灯，方向盘向左打满。</li>
<li>step 2：注意观察左后视镜，当B角出现时，回正方向盘。</li>
<li>step 3：让车辆继续缓缓行驶，注意观察左后视镜，当左前门门把手与车库虚线重合时，方向盘向右打满。</li>
<li>step 4：观察右后视镜，当车右侧与虚线平行时，车身已正，方向盘回正。</li>
<li>step 5：观察右后视镜，当A角出现时，停车。</li>
</ul>
<p><strong>右侧方停车：</strong></p>
<ul>
<li>step 1：挂倒挡，观察右后视镜，当A直角消失，方向盘又打满。</li>
<li>step 2：注意观察左后视镜，当B直角出现，方向盘回正。</li>
<li>step 3：注意观察左后视镜，当左后轮即将碰到车库虚线时，方向盘左打满。</li>
<li>step 4：注意观察右后视镜，当车右侧与车库边线平行时，车身已正。停车。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾驶技术</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶技术学习心得</title>
    <url>/2020/08/17/%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/repo/2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><blockquote>
<p>项目开始前准备：<br>系好安全带，放下手刹，踩下刹车，启动引擎，踩下离合器。</p>
</blockquote>
<hr>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E5%80%92%E8%BD%A6%E5%85%A5%E5%BA%93.png" alt="pic0x0"><br><strong>左倒库：</strong> </p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向左打满。</li>
<li>step 2: 车身垂直于A线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过A线离合刹车踩满停下，准备左倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与A线重合，方向盘向左打满。</li>
<li>step 5: 此时注意左后视镜L1角，当L1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向右回一圈减小转角。</li>
<li>step 6: 此时注意观察右后视镜，观察当R2角出现时，方向盘迅速回正，此时注意到车身和R线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<p><strong>右倒库：</strong></p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向右打满。</li>
<li>step 2: 车身垂直于B线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过B线离合刹车踩满停下，准备右倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与B线重合，方向盘向右打满。</li>
<li>step 5: 此时注意观察右后视镜R1角，当R1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向左回一圈减小转角。</li>
<li>step 6: 此时注意左后视镜，观察当L2角出现时，方向盘迅速回正，此时注意到车身和L线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BE%A7%E6%96%B9%E5%81%9C%E8%BD%A6.png" alt="pic0x1"><br><strong>将车开出车库至准备区域：</strong></p>
<ul>
<li>step 1: 挂1挡，踩离合，打左转向灯，方向盘向左打满。</li>
<li>step 2：注意观察左后视镜，当B角出现时，回正方向盘。</li>
<li>step 3：让车辆继续缓缓行驶，注意观察左后视镜，当左前门门把手与车库虚线重合时，方向盘向右打满。</li>
<li>step 4：观察右后视镜，当车右侧与虚线平行时，车身已正，方向盘回正。</li>
<li>step 5：观察右后视镜，当A角出现时，停车。</li>
</ul>
<p><strong>右侧方停车：</strong></p>
<ul>
<li>step 1：挂倒挡，观察右后视镜，当A直角消失，方向盘又打满。</li>
<li>step 2：注意观察左后视镜，当B直角出现，方向盘回正。</li>
<li>step 3：注意观察左后视镜，当左后轮即将碰到车库虚线时，方向盘左打满。</li>
<li>step 4：注意观察右后视镜，当车右侧与车库边线平行时，车身已正。停车。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾驶技术</tag>
      </tags>
  </entry>
  <entry>
    <title>沟通的艺术</title>
    <url>/2020/08/01/%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="沟通的基本功"><a href="#沟通的基本功" class="headerlink" title="沟通的基本功"></a>沟通的基本功</h3><blockquote>
<ul>
<li>聪明的脑子和活跃的思维<blockquote>
<p>十八核大脑不是盖的，你能透彻地理解对方说的意思，甚至包括言外之意；你能清晰地明白对方语句间的逻辑关系，哪怕他的逻辑存在漏洞你也能够指出；你能设身处地地理解周围所有人的感受，无缝切换各个角色轻松地实现换位思考；你能一定程度上预判对面将要说的话，从而为将来的谈话提前做好准备；</p>
</blockquote>
</li>
<li>敏锐的洞察力（察言观色）</li>
<li></li>
</ul>
</blockquote>
<h3 id="话题穿插切换"><a href="#话题穿插切换" class="headerlink" title="话题穿插切换"></a>话题穿插切换</h3><p>如果对方对和你要聊的话题并无兴趣的话，这时就需要切换话题，把话题转移到另一个方向去。<br><strong>常见话题切换语句</strong></p>
<blockquote>
<ul>
<li>你知道么，其实。。。<blockquote>
<p>举例：你知道么，今天你跟平常不太一样。。。</p>
</blockquote>
</li>
<li>我觉得。。。</li>
<li>对了。。。</li>
</ul>
</blockquote>
<h3 id="1个核心思维模式：「把对方当主角」"><a href="#1个核心思维模式：「把对方当主角」" class="headerlink" title="1个核心思维模式：「把对方当主角」"></a>1个核心思维模式：「把对方当主角」</h3><p>把对方当成聊天的主角，每一步聊天，都围绕着对方，使其感受到「主角」般的爽感，谁都是希望自己被重视，被宠着的。<br>现在，请你在心里默念三遍：<br><strong>TA才是聊天的主角，我要宠着惯着！</strong><br><strong>TA才是聊天的主角，我要宠着惯着！</strong><br><strong>TA才是聊天的主角，我要宠着惯着！</strong></p>
<h3 id="打招呼"><a href="#打招呼" class="headerlink" title="打招呼"></a>打招呼</h3><blockquote>
<p>当然首先还是吸引对方的注意，不然的话，你跟对方打招呼结果他没注意到，那就尴尬了哈哈。<br>其次呢，神情自然大方地去释放你阳光的情绪吧。<br>微笑是最能感染人的，但是别皮笑肉不笑那种。用你的眼神去“微笑”，一个温柔的眼神胜过千言万语。眼睛一定要看着对方哦，瞳孔适当放大。<br>打招呼也有intro和outro的，outro可以用关怀的态度，还是把对方当主角宠。比如：注意安全喔、玩的开心喔，等等，当然，最简单的还是拜拜。</p>
</blockquote>
<h3 id="怎样说话让对面很容易接下去"><a href="#怎样说话让对面很容易接下去" class="headerlink" title="怎样说话让对面很容易接下去"></a>怎样说话让对面很容易接下去</h3><p><strong>在对方给的回答上做文章，谈谈自己的感受，并抛出一个或多个话题。</strong><br>其实如果你是个接话高手，那么只需要在接住话之后稍加 <strong>感受</strong>，再次将话题回到对方身上即可。</p>
<h3 id="沟通前的准备"><a href="#沟通前的准备" class="headerlink" title="沟通前的准备"></a>沟通前的准备</h3><blockquote>
<p><strong>step 1:</strong> 观察。我认为，沟通之前应该迅速判断对面有没有和你沟通的意愿。所以沟通前第一件事，就是用眼观察对方。这一步需要在一瞬间内完成。<br><strong>step 2:</strong> 观察。对的，第二步还是观察，只不过这一步观察对方的状态，根据这一状态可以自然而然开启沟通。<br><strong>step 3:</strong> 营造氛围。这一步开始营造聊天氛围。和人聊天，过了很久之后，具体说些啥，对方可能不会再记起，但是你们聊天的氛围、双方的感受是很难忘却的，特别是当这是一种特别舒服或者特别尴尬的时候。两人见面，不管是两者关系如何，这都不重要，重要的是你对氛围的把控。即便是双方不熟，只要把握好聊天氛围，一样可以有话聊。<br>聊天氛围客观描述：</p>
<blockquote>
<ul>
<li>你自己在即将展开的聊天中扮演什么样的角色，塑造什么样的形象。<br>例1：<strong>自己处于弱势时，可以塑造大方乐观的形象。</strong> 今天和对方在家乐福门口见面，我俩都是从健身房出来，他带了伞，我没带伞，外面下着雨。他有伞我没有，自己处于弱势地位（这里的地位强弱不是说要去竞争什么），这时候你可以营造出一种自己乐观大度的形象：这些雨不算什么，我等会儿再走即可。这样聊天的基调就有了，你对将要发生的谈话已经有了一个非常十足的把握。和谐的氛围油然而生。具体说些啥，这些都不是很重要了。无非就是先寒暄，再顺着你准备的氛围说下去。<br>例2：<strong>塑造赞美者的形象</strong> 今天遇到同事或者同学或者一起健身的朋友，你发现对面穿了一件骚气的衣服，你可以把自己塑造成一个赞美者的形象，其实赞美是一门很深的学问，力度不够，会让人觉得肤浅做作；力度太大会变成讥笑，中国人是最敏感的；力度更大，就成了马屁精，或者舔狗。夸细节啊真诚啊啥的，这些都是最基本的东西，所有人都知道。<br>夸得别人舒服，营造马屁味道，这是需要长期磨炼反思的。人情练达即文章，我现在也不是很在行，以后慢慢补充。<br>例3：____</li>
<li></li>
<li><strong>step 4:</strong> 寒暄。此时开始聊天，在正式聊天前，会有一个intro，这是从不说话到正式聊天之间的一个平稳的过度，让对面做好准备，意思是说，我们要开始聊天了，双方都准备一下。<br>寒暄嘛，都是些无关痛痒的废话。它是根据两人 <strong>关系</strong> 来的。<br>中国人寒暄的时候，关系一般或者不熟可以问对方刚发生的事情。你可以问对方吃了吗？刚健完身啊？刚放学啊？刚下班啊？等等<del>我们一般寒暄的时候会根据对方的状态问一下刚发生的事情，这些事情必须是无关痛痒的。但你不要哪壶不开提哪壶，揭人伤疤啥的。一般也不要问对方将要去做什么，因为有些人很在意这些，你问他要去做啥，他可能不想告诉你，会认为你居心叵测，打探隐私。<br>例1： 噫</del>你也从这边走 or 噫<del>好巧啊，在这遇到你 or 噫</del>你也刚下来么 or 噫~很少在这碰到你等等。<br>关系是熟人或者很好，这个时候你再像上面这样寒暄就会拉开距离，千万注意。这时候，你就单刀直入，可以从 <strong>关怀</strong> 的角度入手。不管关系好坏，关怀可以通吃。<br>例2：</li>
</ul>
</blockquote>
</blockquote>
<h3 id="话轮技术"><a href="#话轮技术" class="headerlink" title="话轮技术"></a>话轮技术</h3><p>话轮技术：一个原则，三条注意事项<br>效果：一个人掌握话轮，就可以让交谈的双方获益<br>一、相当原则：双方说话时长相当，注意力投入相当，地位相当。<br>（一）第一不要说太多也不要听太多，公式化表达：表述自身资源和观点，再以好奇心抛出一个半开放性问题。<br>（二）第二不要高姿态也不要低姿态。减少那些只能靠“是、否”就能回答的问题，不要让人觉得你太强势，姿态高。交流时也不要让出所有的选择权，适当表达是礼貌，但过度就是姿态低。有时候“我不这么想”可以进一步让沟通继续。<br>（三）第三保持高投入，也引导对方高投入。有资源的炫耀和没资源的胡扯都会让人反感。请注意在你的话里表达观点，而不是太多内容。<br>二、注意避免话轮被打断。<br>请尽量减少外界的干扰和潜在的干扰：约会环境要单一，不要嘈杂；选择无意识加工就能完成的事情，比如一起吃个饭、散个步。约会时请把手机收起来。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>人际关系</tag>
        <tag>情商</tag>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>fix Intellj IDEA git pust rejected</title>
    <url>/2020/07/25/fix-Intellj-IDEA-git-pust-rejected/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>git</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>曾仕强「圆通的人际关系」节目笔记</title>
    <url>/2020/06/30/%E6%9B%BE%E4%BB%95%E5%BC%BA%E3%80%8C%E5%9C%86%E9%80%9A%E7%9A%84%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E3%80%8D%E8%8A%82%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一集"><a href="#第一集" class="headerlink" title="第一集"></a>第一集</h3><ul>
<li><p>很多人用西方的标准去看中国的一切，所以在他看来中国人士乱七八糟的。更有趣的是，自五四运动以来，他们用中国的缺点和西方的优点去比，那当然中国人更糟糕。全世界它要比较的话，应该以一个较持平的标准。</p>
</li>
<li><p>西方和中国的人际关系是截然不同的。西方人与人是平等的，中国是不平等的。在中国，人人平等那就叫没大没小。</p>
</li>
<li><p>现在很多人看书，是越看越困惑越看越倒霉。是因为他们看的都是西方的书，西方的技术是可以学的，因为科学无国界。可是跟文化有关的书，你就要十分小心，一不注意就会掉到坑里去。</p>
</li>
<li><p>西方社会是「神本位」，而中国是「人本位」。西方人认为神是一切的主宰，解释一切都离不开神。而伏羲氏认为天底下最了不起的不是神，而是人。你为什么一定要把一个神弄在你上面当你的主宰呢？</p>
</li>
<li><p>中国是没有宗教的，你看所有宗教他都是外来的。中国人崇拜祖宗，叫做「祖宗崇拜」。很多人说不对呀，你看很多人在拜。你要小心了，那不是「拜神」，那是「理神」。</p>
</li>
<li><p>「神本位」必然走向个人主义（人都是上帝的子民，所以人是个人的、平等的）。西方人经常讲，这是我个人意见blabla。在中国我劝你不要这样讲，你一这样讲，人家就开始不听了。你算老几，你有什么意见？西方人说我个人意见表示我负责，在中国你说你负责你就更惨了，人家就怀疑，你能负什么责？——讲太多西方的话，吃亏的是你自己。</p>
</li>
<li><p>中国人认为人生而不平等。人生下来之前是平等的，人死了之后也是平等的，只要你活着你就不平等。中国人接受 <strong>合理的不平等</strong> ，不接受 <strong>过分的不平等</strong> ，<strong>完全的平等</strong> 我们是完全不相信的。 </p>
</li>
<li><p>中国人认为人与人之间相当地不平等，那才叫 <strong>伦理</strong> 。他是你爸爸，就永远是你爸爸，你永远讲不过他。他是你的领导就永远是你的领导，你就是讲不过他。然后你骗自己说我跟他是平等的，何必呢？</p>
</li>
<li><p>西方有人际关系，而中国有人伦关系，我们本没有人际关系，现在说人际关系其实是很勉强。中国人认为人际关系加上伦理就成了人伦关系。你看两个人在谈话，只要有第三个人插进来，我们马上就会调整，中国人的警觉性很高，还要装得没调整一样。全世界找不到像我们这样的人。</p>
</li>
<li><p>中国人都是双重标准。别人遇到什么事，他都会说，怕什么？不用怕！轮到自己，哎呀我要小心一点。</p>
<blockquote>
<p>郭德纲说：劝人大度遭雷劈。我的理解其中的一方面就是对这种双重标准的反击：哼，你自己遇到事儿怎么不大度了？</p>
</blockquote>
</li>
<li><p>中国的法律、规定都是有弹性的，没有弹性就没办法执行。所以中国人遇到事情就会讲一大堆道理，然后大事化小小事化了，小到不知道怎么办才好。</p>
</li>
<li><p>西方人与人之间，它是好奇，但他不会去关心你。在中国人与人之间，它不好奇，没有什么好好奇的，我们是 <strong>关怀</strong> 。你看西方男人和女人他们互相好奇，很快就同居，发生关系。人与人之间如果不能关怀，那产生什么关系又怎么样呢？西方人见面，Hi, Hello, GoodMorning，很有礼貌但一点也不关心你。你看中国人见面，—— 噫，你嘴巴怎么破了？ —— 上火。 二话不说把药给你吃。西方人之间的这种好奇而不关心产生了人与人之间的 <strong>距离感</strong> 。</p>
</li>
<li><p>西方才讲利害。大到国与国之间，小到人与人之间，完全讲利害关系，没有什么道义可言。真正了解中国人说我们很 <strong>势利</strong> ，我们不讲利害。这件事搞不好就让他走，这就是利害。而中国人，这件事搞不好是搞不好，但他后面有背景，我得罪他，上面会找我。我不是喜欢他，我是看到他不敢动他。上面一旦完了，我第一个动他。这就是 <strong>势利</strong> 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>曾仕强</tag>
        <tag>哲学</tag>
        <tag>人际关系</tag>
        <tag>情商</tag>
      </tags>
  </entry>
  <entry>
    <title>圣经本土化翻译片段</title>
    <url>/2020/06/30/%E5%9C%A3%E7%BB%8F%E6%9C%AC%E5%9C%9F%E5%8C%96%E7%BF%BB%E8%AF%91%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<p>裆里搁裆，裆里搁裆，裆里搁 裆里搁 裆里搁裆… </p>
<p>闲言碎语不要讲，表一表大卫家的小木匠。 </p>
<p>木匠名叫约瑟夫，手巧人帅脾气好，忠厚之名传家乡。</p>
<p>媒婆纷纷来拜访，许了个妹子做新娘。</p>
<p>姑娘叫做玛利亚，温柔美丽人人夸，种田做饭样样强。</p>
<p>两人恩爱深似海，订婚一年却未圆房。</p>
<p>这一天，两人约会去逛街，玛利亚却穿上了防辐射的孕妇装。</p>
<p>约瑟夫见了心不爽：莫非我娘子不贤良，暗自让我把王八当？</p>
<p>玛利亚见状忙解释：“昨晚天使托梦道端详，说我清纯美丽无人及，贞洁贤良远名扬，上帝见了心欢喜，选我做了圣子的娘 ，此儿本是上帝的种，长大必做世人的王”。</p>
<p>未出一力喜当爹，约瑟夫闻言心花放。</p>
<p>十月怀胎匆匆过，一朝分娩苦难当。</p>
<p>马槽呱呱一声啼，天使降临显圣光。</p>
<p>木匠抱起了小宝贝儿，喜上眉梢眼放光：“耶，媳妇卧槽生了个孩儿，萌的为父心酥痒，赐你小名【处生】好养活，大名【 耶稣】亮堂堂，今晚吃饱你娘的奶，明天带你拜谒祖坟烧高香~”</p>
<p>这便是：天父恩泽齐浩荡，处女生子世无双，便宜当爹约瑟夫，万古流芳绿帽王。</p>
<blockquote>
<p>作者：张寒生<br>链接：<a href="https://www.zhihu.com/question/403728436/answer/1307927525" target="_blank" rel="noopener">https://www.zhihu.com/question/403728436/answer/1307927525</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>圣经</tag>
        <tag>段子</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/2020/06/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>淫字论事不论心，论心千古无完人。孝字论心不论事，论事千古无孝子。</p>
</li>
<li><p>肉体才是人的神殿，不管里面供奉的是什么，都应该好好保持它的强韧、美丽和清洁。  ——《1Q84》村上春树</p>
</li>
<li><p>真诚感谢四步法：</p>
<blockquote>
<p>说明行为：就是说清楚对方具体帮你做了什么事；<br>说清影响：说明他帮你的这件事，为你解决了什么问题；<br>分享感受：表达受到帮助后的真实感受；<br>投桃报李：表明对方有需要的话，你也愿意尽力帮忙。</p>
</blockquote>
</li>
<li><p>彭林教授（清华大学人文学院历史系）反对父亲节、母亲节等西方节日。因为中国人是有孝道的，一年四季没有哪一天不孝，君子有终身之孝。而西方人它是没有孝道的，所以他们要找出一天来表示一下。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #238 除自身以外数组的乘积（Product of Array Except Self）</title>
    <url>/2020/06/04/LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%88Product-of-Array-Except-Self%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的整数数组 <code>nums</code>，其中 n &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p>
</blockquote>
<p><strong>提示：</strong> 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong> 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<hr>
<h3 id="左右乘积数组"><a href="#左右乘积数组" class="headerlink" title="左右乘积数组"></a>左右乘积数组</h3><p>维护两个数组，分别存放<code>nums[i]</code>左右乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == len - <span class="number">1</span>) &#123;</span><br><span class="line">                right[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right[j] = right[j + <span class="number">1</span>] * nums[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">            output[k] = left[k] * right[k];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：<strong><em>O(N)</em></strong> 其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。预处理 <code>left</code> 和 <code>right</code> 数组以及最后的遍历计算都是 <strong><em>O(N)</em></strong> 的时间复杂度。</li>
<li>空间复杂度：<strong><em>O(N)</em></strong> 其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。使用了 <code>left</code> 和 <code>right</code> 数组去构造答案，<code>left</code> 和 <code>right</code> 数组的长度为数组 <code>nums</code> 的大小。</li>
</ul>
<h3 id="进一步优化-O-1-的空间复杂度"><a href="#进一步优化-O-1-的空间复杂度" class="headerlink" title="进一步优化 O(1) 的空间复杂度"></a>进一步优化 <strong><em>O(1)</em></strong> 的空间复杂度</h3><p>可以使用答案数组来替代 <code>left</code> 数组，从右向左遍历，动态更新 <code>nums[i]</code> 右侧乘积。<br>也可以使用答案数组来替代 <code>right</code> 数组，从左向右遍历，动态更新 <code>nums[i]</code> 左侧乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        output[len -<span class="number">1</span> ] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            output[i] = output[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) left = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = left * nums[j - <span class="number">1</span>];</span><br><span class="line">            output[j] = left * output[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：<strong><em>O(N)</em></strong>，其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。分析与方法一相同。</li>
<li>空间复杂度：<strong><em>O(1)</em></strong>，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</li>
</ul>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1431 拥有最多糖果的孩子（Kids With the Greatest Number of Candies）</title>
    <url>/2020/06/01/LeetCode-1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%88Kids-With-the-Greatest-Number-of-Candies%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>candies</code>和一个整数<code>extraCandies</code>，其中<code>candies[i]</code> 代表第 <code>i</code>个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<p><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [2,3,5,1,3], extraCandies = 3<br><strong>输出：</strong> [true,true,true,false,true]<br><strong>解释：</strong><br>孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。<br>孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。<br>孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。<br>孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。<br>孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [4,2,1,1,2], extraCandies = 1<br><strong>输出：</strong> [true,false,false,false,false]<br><strong>解释：</strong> 只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [12,1,12], extraCandies = 10<br><strong>输出：</strong> [true,false,true]</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= candies.length &lt;= 100</li>
<li>1 &lt;= candies[i] &lt;= 100</li>
<li>1 &lt;= extraCandies &lt;= 50</li>
</ul>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>没啥好说的，儿童节快乐！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = candies.length;</span><br><span class="line">        <span class="keyword">int</span> max = candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            max = Math.max(max, candies[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to Anaconda</title>
    <url>/2020/06/01/Welcome-to-Anaconda/</url>
    <content><![CDATA[<h3 id="为什么要用Anaconda"><a href="#为什么要用Anaconda" class="headerlink" title="为什么要用Anaconda"></a>为什么要用Anaconda</h3><p>Anaconda解决了官方Python的两大痛点。</p>
<ul>
<li>提供了包管理功能，Windows平台安装第三方包经常失败的场景得以解决。</li>
<li>提供环境管理的功能，功能类似Virtualenv，解决了多版本Python并存、切换的问题。</li>
</ul>
<h3 id="下载安装conda"><a href="#下载安装conda" class="headerlink" title="下载安装conda"></a>下载安装conda</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2019.07-Linux-x86_64.sh</span><br><span class="line">bash  Anaconda3-2019.07-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<h3 id="把conda加入PATH"><a href="#把conda加入PATH" class="headerlink" title="把conda加入PATH"></a>把conda加入PATH</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; conda init &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !! Contents within this block are managed by <span class="string">'conda init'</span> !!</span></span><br><span class="line">__conda_setup="$(CONDA_REPORT_ERRORS=false '/root/anaconda3/bin/conda' shell.bash hook 2&gt; /dev/null)"</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    \eval "$__conda_setup"</span><br><span class="line">else</span><br><span class="line">    if [ -f "/root/anaconda3/etc/profile.d/conda.sh" ]; then</span><br><span class="line">        . "/root/anaconda3/etc/profile.d/conda.sh"</span><br><span class="line">        CONDA_CHANGEPS1=false conda activate base</span><br><span class="line">    else</span><br><span class="line">        \export PATH="/root/anaconda3/bin:$PATH"</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;&lt; conda init &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>

<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/58033789" target="_blank" rel="noopener">https://www.zhihu.com/question/58033789</a></li>
<li><a href="https://www.bobobk.com/32.html" target="_blank" rel="noopener">https://www.bobobk.com/32.html</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #101 对称二叉树（Symmetric Tree）</title>
    <url>/2020/05/31/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Symmetric-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，检查它是否是镜像对称的。<br>例如，二叉树<code>[1,2,2,3,4,4,3]</code>是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong><br>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们可以将对整个二叉树是否对称的判断拆分成对若干节点对是否对称的判断。这是递归思想。<br>具体地，从root节点的左右孩子节点开始，进行一次判断。条件满足的话，再深入到node1的left与node2的right、node1的right与node2的left。依次递归下去。<br>注意回溯的情况，当node1和node2都为空时，即该节点对为对称的且为末端节点，<code>return true</code>。<br>不满足上面条件时，当node1和node2有一个为空或者<code>node1.val != node2.val</code>时，必然非对称，<code>return false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">     * 内存消耗 :37.9 MB, 在所有 Java 提交中击败了31.25%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//递归到头了，必须回溯。 不能在满足条件(node1 != null &amp;&amp; node2 != null &amp;&amp; node1.val == node2.val)时return true，因为此时需要继续向下递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//此时必然非对称</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> cmp(node1.left, node2.right) &amp;&amp; cmp(node1.right, node2.left); <span class="comment">//向下递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们可以引入一个队列，迭代判断所有节点对。<br>第一代poll root节点的左右孩子节点，判断节点状态。<br>往后每一代（如果有的话）保留了上一代判断条件得出的信息，poll出两个节点，再进行下一个判断。<br>一次又一次，迭代地进行判断。只要中间出现了一个不满足对称的情况：<br><code>node1 == null || node2 == null || node1.val != node2.val</code>，直接<code>return false</code>。<br>当所有节点入队出队迭代判断完毕均为出现非对称情况，那么可以认为二叉树是对称的。<br>注意到null节点的情况，队列应该使用LinkedList而非ArrayDeque——前者支持null元素，而后者不支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *执行用时 :1 ms, 在所有 Java 提交中击败了37.93%的用户</span></span><br><span class="line"><span class="comment">     *内存消耗 :39.8 MB, 在所有 Java 提交中击败了5.00%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = queue.poll();    </span><br><span class="line">            TreeNode node2 = queue.poll();  </span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">continue</span>; <span class="comment">//继续迭代判断</span></span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//必然非对称</span></span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//当所有节点入队出队结束，均未出现非对称情况，结果显然是对称的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #200 岛屿数量（Number of Islands）</title>
    <url>/2020/04/21/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%88Number-of-Islands%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。<br><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>{<br>   {‘1’, ‘1’, ‘1’, ‘1’, ‘0’},<br>   {‘1’, ‘1’, ‘0’, ‘1’, ‘0’},<br>   {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>   {‘0’, ‘0’, ‘0’, ‘0’, ‘0’}<br>}<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>{<br>  {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>  {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>  {‘0’, ‘0’, ‘1’, ‘0’, ‘0’},<br>  {‘0’, ‘0’, ‘0’, ‘1’, ‘1’}<br>}<br><strong>解释：</strong> 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
</blockquote>
<hr>
<p>一看就是搜索题，已经遇到多次类似的。</p>
<h3 id="广度优先搜素"><a href="#广度优先搜素" class="headerlink" title="广度优先搜素"></a>广度优先搜素</h3>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>深度优先搜素</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Shell命令</title>
    <url>/2020/04/18/%E5%B8%B8%E7%94%A8Shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>查找当前目录及子目录特定文件（夹）并删除</strong><br><code>find . -name &quot;*.zip&quot; -type f -print -exec rm {} \;</code></p>
<ul>
<li><code>.</code>即从当前目录递归查找</li>
<li><code>-name &#39;*.zip&#39;</code>查找以<code>.zip</code>文件名结尾的对象</li>
<li><code>-type f</code>该对象为文件</li>
<li><code>-print</code>屏幕输出</li>
<li><code>-exec</code>查找之后执行</li>
<li><code>rm</code>删除<br>如果希望删除目录，可以<code>-type d</code>，其表示对象为目录。另外如果希望递归删除，可以<code>rm -r</code>。如果希望递归强制删除，可以<code>rm -rf</code>。</li>
</ul>
<p><strong>查找当前目录及子目录特定文件并移动到目标目录</strong><br><code>find . -name &quot;*.mp4&quot; -type f -print -exec mv -t /home/AriaGo/ {} +;</code></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows同一台计算机不同用户之间转移hexo运行环境</title>
    <url>/2020/04/15/Windows%E5%90%8C%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E8%BD%AC%E7%A7%BBhexo%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><strong>部署hexo的用户：A</strong><br><strong>新用户：B</strong></p>
<p>在Windows平台由A切换B之后，A配置的hexo没法直接使用。</p>
<p><strong>解决方法</strong></p>
<blockquote>
<ul>
<li>将<code>C:\Users\A\AppData\Roaming</code>下的<code>npm</code>目录拷贝到<code>C:\Users\B\AppData\Roaming</code>。<blockquote>
<p>这里是hexo的安装目录，在新用户下不用重新安装。</p>
</blockquote>
</li>
<li>将<code>C:\Users\A</code>下的<code>.ssh</code>目录拷贝到<code>C:\Users\B</code>。<blockquote>
<p>这里存放着用于连接Github的ssh公钥和私钥。</p>
</blockquote>
</li>
<li>将<code>C:\Users\A</code>下的<code>node_modules</code>目录拷贝到<code>C:\Users\B</code>。<blockquote>
<p>这里是安装node之后用来存放<code>npm</code>下载的各种包的地方，我们不用重新执行<code>npm install</code>，直接拷贝即可。</p>
</blockquote>
</li>
<li>将<code>C:\Users\B\AppData\Roaming\npm</code>添加到B的用户环境变量。<blockquote>
<p>这一步可以让我们在新用户B下直接执行<code>hexo</code>命令。</p>
</blockquote>
</li>
<li>将<code>T:\Git\root\Git\cmd</code>添加到B的用户环境变量。<blockquote>
<p>这样可以在B下执行<code>git</code>命令。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>同一台计算机不同不同用户之间转移hexo运行环境要比不同计算机之间更加方便。</p>
<h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br><a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35668237</a><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a><br><a href="https://m.html.cn/qa/node-js/12146.html" target="_blank" rel="noopener">https://m.html.cn/qa/node-js/12146.html</a><br><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/01/npm-install.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌云（GCP）给给未分配实例的外部IP地址分配实例</title>
    <url>/2020/04/13/%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>为了给未分配实例的外部IP地址分配实例，必须要保证新的实例与该IP地址在同一地区。<br><img src="2020-04-13-%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/0x0.png" alt="pic0x0"></p>
<p>直接在新的实例中选择保留的IP地址。<br><img src="2020-04-13-%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/0x1.png" alt="pic0x1"></p>
<p>这样当我们删除一个实例，但希望把保留的IP地址应用到新的实例时，就可以很方便地操作。</p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>谷歌云</tag>
        <tag>GCP</tag>
        <tag>GCE</tag>
        <tag>VM</tag>
        <tag>外部IP地址</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS测速</title>
    <url>/2020/04/13/VPS%E6%B5%8B%E9%80%9F/</url>
    <content><![CDATA[<blockquote>
<p> <strong>speedtest-cli</strong></p>
<blockquote>
<ul>
<li>下载speedtest-cli<br><code>wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</code></li>
<li>添加可执行权限<br><code>chmod +x speedtest-cli</code></li>
<li>以默认的Mbps为单位测速<br><code>./speedtest-cli</code></li>
<li>以MB为单位测速<br><code>./speedtest-cli --byte</code></li>
<li>查看可用测速服务器<br><code>./speedtest-cli --list</code></li>
<li>选择指定服务器测速<br><code>./speedtest-cli --server NumberOfServer</code></li>
<li>获取帮助<br><code>./speedtest-cli --help</code></li>
</ul>
</blockquote>
<p> <strong>superspeed</strong></p>
<blockquote>
<ul>
<li>下载superspeed<br>. <code>wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh</code></li>
<li>添加可执行权限<br><code>chmod +x superspeed.sh</code></li>
<li>测速<br><code>./superspeed.sh</code></li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>测速</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用Screen命令</title>
    <url>/2020/04/13/Linux%E5%B8%B8%E7%94%A8Screen%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在使用过程中可以退出screen，甚至可以关掉登录窗口，下次再进去重新挂上screen会话，所有工作全部都会恢复。</p>
<blockquote>
<ul>
<li><p><strong>安装</strong><br><code>sudo apt install screen</code></p>
</li>
<li><p><strong>创建新会话</strong><br><code>screen -S 0x0</code><br>创建一个名为「0x0」的会话，可以在其中执行任务。</p>
</li>
<li><p><strong>让会话独立（Detached）</strong><br>在当前会话中按住<code>Ctrl + A + D</code>，即可让其独立。此时我们可以在终端执行其他任务或退出终端。</p>
</li>
<li><p><strong>重新连接会话</strong><br><code>screen -r 0x0</code><br>回到名为「0x0」的会话中。</p>
</li>
<li><p><strong>查看会话列表</strong><br><code>screen -ls</code></p>
</li>
<li><p><strong>结束会话</strong><br><code>screen -X -S 0x0 quit</code>强制结束「0x0」会话。<br>在「0x0」会话中按住<code>Ctrl + D</code>结束当前会话。</p>
</li>
<li><p><strong>清除死亡会话</strong><br><code>screen -wipe</code></p>
</li>
</ul>
</blockquote>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/40133139" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40133139</a><br><a href="https://www.cnblogs.com/xinzaibing/archive/2012/04/08/2437431.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinzaibing/archive/2012/04/08/2437431.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Screen</tag>
      </tags>
  </entry>
  <entry>
    <title>PanDownload远程Aria2下载恢复连接数</title>
    <url>/2020/04/12/PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h3><p>什么是连接数？如图：<br><img src="2020-04-12-PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/0x0.png" alt="pic0x0"><br>对应PanDownload下载列表的连接数。</p>
<p>这个参数在AriaNg面板中是这样的：<br><img src="2020-04-12-PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/0x2.png" alt="pic0x1"><br>通常情况下，连接数越大，速度越快。Aria2默认可设置单服务器最大连接数是16，可以重新编译Aria2设置更高的连接数。但过高的连接数对于百度云下载无显著意义，因为百度云单方面对连接数和对应速度做出了限制。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>在使用PanDownload远程Aria2下载过程中，会出现连接数缓慢递减，从而造成速度下降甚至是下载骤停。<br>查了很久没有找到对应的配置设置，不过笔者摸索出了一个土办法，可以在连接数下降之后手动重置连接数。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><blockquote>
<ul>
<li>首先让PanDownload与AriaNg面板的显示失去同步。<blockquote>
<p>解释：PanDownload调用远程Aria2下载时，PanDownload和AriaNg会同步显示下载进度。<br>在任意端直接点击暂停都会让二者同时暂停。<br>把PanDownload退出可让二者的显示信息失去同步。</p>
</blockquote>
</li>
<li>打开PanDownload，此时任务在远程服务器仍在进行。AriaNg显示进度而PanDownload则显示暂停。</li>
<li>在AriaNg面板中将所要重置连接数的任务暂停。<blockquote>
<p>此时所要重置连接数的任务会被移动到「正在等待」选项中。</p>
</blockquote>
</li>
<li>在Pandownload中让目标任务继续下载。<blockquote>
<p>若任务消失可以重新下载，不会对已下载的所需要重置连接数的任务造成影响，因为这相当于另一个任务，待会可以删除。</p>
</blockquote>
</li>
<li>在AriaNg面板中发现「正在下载」中出现恢复最大连接数的对应任务。<blockquote>
<p>如果上一步是“暂停 - 下载”，那么这一步恢复的任务会接着暂停的进度继续下载，而「正在等待」中会有相应的重复任务，将其删除即可；<br>如果上一步是重新下载，那么此处恢复最大连接数的任务会从零开始，不用慌，我们将其删除，从「正在等待」中将对应的任务恢复下载，此时目标任务连接数已恢复最大值。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>特别是在下载大文件的时候，掉连接数会造成下载失败。只能通过人工干预来解决了，希望以后Aria2会对此进行优化。</p>
<h1 id="R-I-P-PanDownload"><a href="#R-I-P-PanDownload" class="headerlink" title="R.I.P PanDownload"></a>R.I.P PanDownload</h1><p><strong>2020年4月15日，希望作者渡过这道坎</strong><br><img src="2020-04-12-PanDownload%E8%BF%9C%E7%A8%8BAria2%E4%B8%8B%E8%BD%BD%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%E6%95%B0/0x2.jpg" alt="pic0x2"></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
        <tag>AriaNg</tag>
        <tag>PanDownload</tag>
        <tag>远程Aria2下载</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux平台解压缩</title>
    <url>/2020/04/11/Linux%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="7z-zip格式"><a href="#7z-zip格式" class="headerlink" title="7z/zip格式"></a>7z/zip格式</h3><p><strong>安装</strong><br>安装p7zip<br>debian可以直接安装，其他系统可以使用相应命令。<br><code>sudo apt-get install p7zip-full</code></p>
<p><strong>保留完整目录结构解压7z/zip文件</strong><br><code>7z x name.7z</code></p>
<p><strong>解压带密码7z/zip文件</strong><br><code>7z x -p&quot;passwordGo&quot; name.7z</code><br>支持<code>utf-8</code>编码的中文密码，而在Windows平台压缩包其中文密码一般是<code>gbk</code>编码。</p>
<p><strong>解压<code>gbk</code>编码密码的7z/zip文件</strong><br>现有密码为<code>中文密码</code>的压缩包<code>name.7z</code>。<br>直接执行<code>7z x -p&quot;&quot; name.7z</code>报密码错，因为shell输入的<code>中文密码</code>是<code>utf-8</code>编码。<br>需要有一个编码转换的过程，可以执行命令行：<br><code>7z x -p&quot;$(echo -n 中文密码|iconv -f utf-8 -t gbk)&quot; name.7z</code><br>shell会首先执行<code>$()</code>中的命令，不换行打印中文密码<code>中文密码</code>，再将<code>uft-8</code>编码的密码转换成<code>gbk</code>编码。最后执行解压缩命令，即可成功解压。</p>
<p><strong>解压密码带有特殊字符的7z/zip文件</strong><br>现有密码为<code>letsgo!-pipixia#hahaha%wow$thatwasepic!</code>的压缩包。<br>直接执行<code>7z x -p&#39;letsgo!-pipixia#hahaha%wow$thatwasepic!&#39; name.7z</code><br>注意到<code>-p</code>后密码引号为<code>&#39;&#39;</code>。</p>
<p><strong>解压分卷7z/zip文件</strong><br>split files:    </p>
<ul>
<li>name.7z.001</li>
<li>name.7z.002</li>
<li>name.7z.003</li>
</ul>
<p>不用合并后再解压缩，任选一个解压即可。<br><code>7z x name.7z.001</code></p>
<p><strong>解压带密码分卷7z/zip文件</strong><br><code>7z x -p&quot;passwordGo!&quot; name.7z.001</code></p>
<p><strong>批量解压各自独立的7z/zip文件</strong><br><code>for i in *.7z; do 7z x -p&quot;passwordGo&quot; $i; done</code></p>
<p><strong>解压目录下所有7z/zip文件</strong><br>先使用<code>find</code>找出压缩文件，再执行解压。<br><code>find /home/AriaGo *.7z -exec 7z x -p&#39;passwordGo&#39; {} \;</code></p>
<p><strong>加密压缩</strong><br><code>7z a dstname.7z * -p&#39;password&#39;</code><br><code>*</code>是目录或文件，如<code>./image/homeland</code>,<code>./image/homeland/skyline.jpg</code></p>
<h5 id="更多详情，请参考："><a href="#更多详情，请参考：" class="headerlink" title="更多详情，请参考："></a>更多详情，请参考：</h5><blockquote>
<p><a href="https://www.cnblogs.com/itech/archive/2009/08/31/1555835.html" target="_blank" rel="noopener">https://www.cnblogs.com/itech/archive/2009/08/31/1555835.html</a><br><a href="https://blog.csdn.net/qq_28050861/article/details/103255120" target="_blank" rel="noopener">https://blog.csdn.net/qq_28050861/article/details/103255120</a></p>
</blockquote>
<h3 id="rar格式"><a href="#rar格式" class="headerlink" title="rar格式"></a>rar格式</h3><p><strong>安装</strong><br>安装unrar<br>debian可以直接安装，其他系统可以使用相应命令。<br><code>sudo apt-get install unrar</code></p>
<p><strong>按源目录结构解压</strong><br>保留源目录结构解压到工作目录。<br><code>unrar x name.rar</code></p>
<p><strong>不保留目录结构解压</strong><br>不保留源目录结构解压到工作目录。<br><code>unrar e name.rar</code></p>
<p><strong>不保留目录结构解压到指定目录</strong><br><code>unrar e name.rar /home/level1/level2</code> </p>
<p><strong>解压带密码rar文件</strong><br><code>unrar e -p&quot;passwordGo&quot; name.rar</code></p>
<p><strong>列出文件列表</strong><br><code>unrar l name.rar</code></p>
<h5 id="更多详情，请参考：-1"><a href="#更多详情，请参考：-1" class="headerlink" title="更多详情，请参考："></a>更多详情，请参考：</h5><blockquote>
<p><a href="https://www.tecmint.com/how-to-open-extract-and-create-rar-files-in-linux/" target="_blank" rel="noopener">https://www.tecmint.com/how-to-open-extract-and-create-rar-files-in-linux/</a></p>
</blockquote>
<h3 id="tar-gz格式"><a href="#tar-gz格式" class="headerlink" title="tar.gz格式"></a>tar.gz格式</h3><p><strong>压缩</strong><br><code>tar -czvf ./dstfilename.tar.gz ./srcfilname.format</code></p>
<hr>
<p><em>未完待续</em></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>解压缩</tag>
        <tag>7z</tag>
        <tag>zip</tag>
        <tag>rar</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #151 翻转字符串里的单词「Reverse Words in a String」</title>
    <url>/2020/04/11/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%8CReverse-Words-in-a-String%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #22 括号生成「Generate Parentheses」</title>
    <url>/2020/04/10/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E3%80%8CGenerate-Parentheses%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>玩转rclone</title>
    <url>/2020/04/09/%E7%8E%A9%E8%BD%ACrclone/</url>
    <content><![CDATA[<h3 id="名词详解"><a href="#名词详解" class="headerlink" title="名词详解"></a>名词详解</h3><p><strong><code>remote</code></strong></p>
<blockquote>
<p><code>remote</code>可以理解成rclone程序「可操作」的对象。通常，一个remote在配置的时候会被分配：<br>一个API接口<code>client_id</code>和<code>client_secret</code>，可以默认rclone官方接口，也可以自己指定接口；<br>一个rclone权限<code>scope</code>，一共5种权限，通常我会选第1个Full access；<br>一个根目录ID<code>root_folder_id</code>，它指定了rclone程序可操作的源在什么地方，通常我会设置成网盘根目录，即对整个网盘可操作；<br>一个服务账号文件<code>service_account_file</code>，它可指定rclone使用真实或服务账号。</p>
</blockquote>
<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><p><strong><code>copy</code></strong></p>
<blockquote>
<p><code>rclone copy remoteA:srcDir remoteB:dstDir</code></p>
<p><code>copy</code> 适用于从一个地方「拷贝」到另一个地方，不管是从本地到网盘还是网盘到网盘。需要注意的是，Rclone绑定的账号至少需要对源有「读取」权限，对目标有「写入」权限。</p>
<p><strong>举例：</strong><br>假设我们配置4个remote：remoteA为网盘A；remogteB为网盘B；remoteC为团队盘C；remoteD为团队盘D；<br>从remoteA的目录”/GdTemp”到remoteA的目录”/Movies/2020”：<br><code>rclone copy remoteA:/GdTemp remoteA/Movies/2020</code><br>从remoteA的目录”/GDTemp” </p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Rclone</tag>
        <tag>GoogleDrive</tag>
      </tags>
  </entry>
  <entry>
    <title>LeecCode #面试题13 机器人的运动范围「」</title>
    <url>/2020/04/08/LeecCode-%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%8C%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #面试题01.07 旋转矩阵「Rotate Matrix LCCI」</title>
    <url>/2020/04/07/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%8CRotate-Matrix-LCCI%E3%80%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？<br><strong>示例1：</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
</blockquote>
<hr>
<h3 id="原地旋转方法"><a href="#原地旋转方法" class="headerlink" title="原地旋转方法"></a>原地旋转方法</h3><p>先将数组按对角线翻折：<br><img src="2020-04-07-LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%8CRotate-Matrix-LCCI%E3%80%8D/Rotate_Matrix_LCCI_0x0.png" alt="pic0x0"><br>此时得到的数组每行和目标数组相反，只需要再将每行数组按中轴线翻折。<br>注意两次翻折的起始和终止，切记不能重复翻折（会折回去）。<br>比如第一次翻折不能写成<code>for (int j = 0; j &lt; len; j++)</code>。如果这样，在<code>i</code>向下遍历过程中，会将之前折的折回去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 0ms</span></span><br><span class="line"><span class="comment">     * 39.7MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//切莫从0开始，否则当遍历j时又换回去了</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++) &#123; <span class="comment">//到中线结束，否则过中线又换回去了</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][len - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][len - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借用临时N-N数组（需额外空间）"><a href="#借用临时N-N数组（需额外空间）" class="headerlink" title="借用临时N * N数组（需额外空间）"></a>借用临时N * N数组（需额外空间）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 0ms</span></span><br><span class="line"><span class="comment">     * 40.2MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                temp[j][len - <span class="number">1</span> - i] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            System.arraycopy(temp[i], <span class="number">0</span>, matrix[i], <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #42 接雨水（Trapping Rain Water）</title>
    <url>/2020/04/04/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88Trapping-Rain-Water%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="2020-04-04-LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88Trapping-Rain-Water%EF%BC%89/%E9%A2%98%E7%9B%AE.png" alt="pic0x0"></p>
<center><font size=1>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</font></center>

<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6 </p>
</blockquote>
<hr>
<h3 id="按列计算（动态规划计算最值）"><a href="#按列计算（动态规划计算最值）" class="headerlink" title="按列计算（动态规划计算最值）"></a>按列计算（动态规划计算最值）</h3><p>遍历每列，判断要不要计算列上的积水。<br>如何判断？计算出该列左侧最高列高度，计算右侧最高列高度。<br>若该列比二者都小，则该列需要计算;否则不需计算。<br>如何分别计算某列两侧最值？<br>可维护两个数组分别存储每列左右两侧最值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * [列解法, 动态规划]</span></span><br><span class="line"><span class="comment">     * 1ms</span></span><br><span class="line"><span class="comment">     * 39.3MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] leftSideMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] rightSideMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//第一列和最后一列不需要计算两侧最值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            leftSideMax[i] = Math.max(leftSideMax[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightSideMax[i] = Math.max(rightSideMax[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minimum = Math.min(leftSideMax[j], rightSideMax[j]);</span><br><span class="line">            <span class="keyword">if</span> (height[j] &lt; minimum) &#123;</span><br><span class="line">                res += (minimum - height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>核心思想是先降后增必有积水。<br>这个就有点像有效括号，一对儿。<br>维护一个单调递减的栈，栈中存入柱子下标。（为什么存入下标而不直接存入高度？因为我们可能会计算两个相隔若干柱子之间的距离。）<br>入栈：栈为空时；当前柱子低于栈顶柱子。<br>出栈：当前柱子高于栈顶柱子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 单调栈 简化代码</span></span><br><span class="line"><span class="comment">     * 4ms - 29.81%</span></span><br><span class="line"><span class="comment">     * 39.5MB, 11.78%</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123; <span class="comment">//有可能可计算体积</span></span><br><span class="line">                <span class="keyword">int</span> heightInfoBeforePop = stack.peek();</span><br><span class="line">                stack.pop(); <span class="comment">// 当前柱子高于栈顶柱子时，出栈。记得出栈前先保存栈高数据。</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>; <span class="comment">//不可计算体积</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> stackTop = stack.peek();</span><br><span class="line">                    res += ((i - stackTop - <span class="number">1</span>) * (Math.min(height[i], height[stackTop]) - height[heightInfoBeforePop]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i); <span class="comment">// 栈空或当前柱子小于等于于栈顶柱子高度时，入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读代码的一点心得</title>
    <url>/2020/04/04/%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>阅读代码时，要先看整体架构，再看局部细节。<br>明确哪里没变，哪里会变，怎么变的。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1111 有效括号的嵌套深度「Maximum Nesting Depth of Two Valid Parentheses Strings」</title>
    <url>/2020/04/02/LeetCode-1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%E3%80%8CMaximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode #20 有效的括号「Valid Parentheses」</title>
    <url>/2020/04/02/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E3%80%8CValid-Parentheses%E3%80%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入: “()”<br>输出: true</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入: “()[]{}”<br>输出: true</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p>输入: “(]”<br>输出: false</p>
</blockquote>
<p><strong>示例4：</strong></p>
<blockquote>
<p>输入: “([)]”<br>输出: false</p>
</blockquote>
<p><strong>示例5：</strong></p>
<blockquote>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<hr>
<h3 id="HashMap辅助的栈解法"><a href="#HashMap辅助的栈解法" class="headerlink" title="HashMap辅助的栈解法"></a>HashMap辅助的栈解法</h3><p>构建一个key为开括号<code>&#39;(&#39;,&#39;[&#39;,&#39;{&#39;</code>value为闭括号<code>&#39;)&#39;&#39;]&#39;&#39;}&#39;</code>的HashMap。<br>遍历String字符串，当遇到开括号，由于将来有机会遇到与之对应的闭括号，故将其入栈。<br>当遇到闭括号，一旦它和栈顶的括号不匹配，可断言整体不是有效括号。（栈为空时，遇到的第一个若为闭括号也可看成与栈顶不匹配，但需做特殊处理）<br>当遍历完String字符串，中途没出现闭括号和栈顶字符不匹配的情况，此时若栈为空，则可断言之前入栈的开括号全部被匹配移除；若栈非空，可断言之前入栈的开括号没有找到匹配的闭括号，整体不属于有效括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cha = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(cha)) &#123;</span><br><span class="line">                stack.push(cha); <span class="comment">//开括号入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 栈为空时，必然return false，但为了用相同的方法让cha能和栈顶元素比较，push一个随便啥的字符</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.isEmpty() ? <span class="string">'!'</span> : stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (map.get(cha) != top) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，判断栈的状态</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯栈解法"><a href="#纯栈解法" class="headerlink" title="纯栈解法"></a>纯栈解法</h3><p>基本思路与上述方法一致，只是在判断闭括号栈顶元素时用一个小技巧代替<code>HashMap</code>。<br>遍历字符串，当遇到开括号时，把相对应的闭括号入栈。比如遇到<code>(</code>，把<code>)</code>入栈。这样，当下一个若是闭括号我们要那它和栈顶元素比较的话，可以不查<code>HashMap</code>而是直接比较是否相等。若相等，则是一对。继续循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cha = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cha == <span class="string">'('</span>) stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cha == <span class="string">'['</span>) stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cha == <span class="string">'&#123;'</span>) stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || cha != stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//此时遇到闭括号且栈为空，则必然无效，或者闭括号与栈顶元素不匹配，必然无效</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a><br><strong>参考题解：</strong> <a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转ffmpeg</title>
    <url>/2020/03/30/%E7%8E%A9%E8%BD%ACffmpeg/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>FFmpeg的使用技巧。</p>
<a id="more"></a>
<h3 id="合并分段视频"><a href="#合并分段视频" class="headerlink" title="合并分段视频"></a>合并分段视频</h3><p><strong>方法1：txt文件保存视频文件名</strong></p>
<blockquote>
<p><code>ffmpeg -f concat -safe 0 -i files.txt -c copy &quot;merge.MP4&quot;</code></p>
</blockquote>
<p>其中files.txt中写入分段视频文件名</p>
<blockquote>
<p>file  name0x0.ts<br>file  name0x1.ts<br>file  name0x2.ts<br>file  name0x3.ts<br>file  name0x4.ts<br>file  name0x5.ts</p>
</blockquote>
<p><strong>方法2：直接写入各个视频文件名</strong></p>
<blockquote>
<p><code>ffmpeg -i &quot;concat:name0x0|name0x1|name0x2|name0x3&quot; -c copy &quot;merge.mp4&quot;</code></p>
</blockquote>
<h3 id="视频转换格式"><a href="#视频转换格式" class="headerlink" title="视频转换格式"></a>视频转换格式</h3><blockquote>
<p><code>ffmpeg -i &quot;video.ts&quot; -vcodec copy -acodec copy &quot;video.mp4&quot;</code></p>
</blockquote>
<h3 id="截取一段视频"><a href="#截取一段视频" class="headerlink" title="截取一段视频"></a>截取一段视频</h3><p>从第12秒截取到294秒：<br><code>ffmpeg  -i 0x0.mkv -ss 12 -c copy -to 294 0x1.mp4</code></p>
<h3 id="提取视频中的音频"><a href="#提取视频中的音频" class="headerlink" title="提取视频中的音频"></a>提取视频中的音频</h3><p><code>ffmpeg -i xxx.mp4 -f mp3 -ar 16000 xxx.mp3</code><br>其中：<br>xxx.mp4 视频文件<br>-f mp3 mp3编码<br>-ar 16000 音频采样率<br>xxx.mp3输出的音频文件</p>
<p><strong>未完待续</strong></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode # 10 卡牌分组（X of a Kind in a Deck of Cards）</title>
    <url>/2020/03/29/LeetCode-10-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84%EF%BC%88X-of-a-Kind-in-a-Deck-of-Cards%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>计数数组</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #9 两数相加（Add Two Numbers）</title>
    <url>/2020/03/29/LeetCode-9-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add%20Two%20Numbers%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<p><strong>示例：</strong></p>
<blockquote>
<p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong> 7 -&gt; 0 -&gt; 8<br><strong>原因：</strong> 342 + 465 = 807</p>
</blockquote>
<hr>
<h3 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h3><p>我们需要创建一个新的链表作为相加后的返回对象，而且在新的链表构造过程中，其头结点需要不断移动，从而导致无法返回整个链表。</p>
<p>我们可以定义独立于新链表的一个 <strong>超级头结点</strong> ，让其指向新的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//超级头结点</span></span><br><span class="line">        ListNode cur = pre; <span class="comment">//超级头结点指向新的链表</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> value2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = value1 + value2 + carry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) carry = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.next; <span class="comment">//返回超级头结点的后面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>超级头结点</tag>
      </tags>
  </entry>
  <entry>
    <title>求最大公约数（gcd）的一点心得</title>
    <url>/2020/03/27/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%88gcd%EF%BC%89%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h3 id="求两个数的最大公约数"><a href="#求两个数的最大公约数" class="headerlink" title="求两个数的最大公约数"></a>求两个数的最大公约数</h3><p>在《算法 第4版》中，给出迭代求最大公约数的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，这里用到了迭代的思想。两数相除，再拿被除数除余数，如此辗转，直到余数为零，返回此时的被除数 。<br>上述代码可简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q == <span class="number">0</span> ? p : gcd(q, p % q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个非迭代版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (y != <span class="number">0</span>) &#123; </span><br><span class="line">         <span class="keyword">int</span> temp = y;</span><br><span class="line">         y = x % y; <span class="comment">// 余数变被除数</span></span><br><span class="line">         x = temp; <span class="comment">//被除数变除数</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="n个数求最大公约数"><a href="#n个数求最大公约数" class="headerlink" title="n个数求最大公约数"></a>n个数求最大公约数</h3><p>一个常见的求法就是设置一个初始的gcd，求它和第一个数的gcd。再将该gcd和第二个数求它们的gcd，如此辗转，直到求第n个数和前n-1个数的gcd。复杂度是O(N)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GcdN</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcdN</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gcd = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> each : arr) </span><br><span class="line">            gcd = gcd(gcd, each);</span><br><span class="line">        <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="number">0</span> ? p : gcd(q, p % q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>About me</title>
    <url>/2020/03/27/About-me/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"zhangxy"</span>; <span class="comment">// Well, good name.</span></span><br><span class="line">    <span class="keyword">char</span> sex = <span class="string">'male'</span>; <span class="comment">// A tough man.</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">25</span>; <span class="comment">// Grasping the little tail of youth.</span></span><br><span class="line">    <span class="keyword">int</span> hight = <span class="number">170</span>; <span class="comment">// Enough to me.</span></span><br><span class="line">    <span class="keyword">float</span> weight = <span class="number">73.7f</span>; <span class="comment">// Emm, a little bit overweight, but everyday going to gym. Gym is second home. </span></span><br><span class="line">    String edu = <span class="string">"UESTC"</span>; <span class="comment">// Where the water tastes like wine. </span></span><br><span class="line">    String pro = <span class="string">"SE"</span>; <span class="comment">// Making cool stuff.</span></span><br><span class="line">    String marriage = <span class="string">"Single"</span>; <span class="comment">// I'm trying...emm...how to be more attractive ?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wish</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"春日宴，浊酒一杯歌一遍。再拜陈三愿：</span></span><br><span class="line"><span class="string">                    一愿父母身体常健，</span></span><br><span class="line"><span class="string">                    二愿自己珍惜时间，</span></span><br><span class="line"><span class="string">                    三愿如同梁上燕，</span></span><br><span class="line"><span class="string">                    岁岁年年，快乐无边！"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moreInfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Stay tuned:)"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>生活</category>
        <category>me</category>
        <category>About me</category>
      </categories>
  </entry>
  <entry>
    <title>方便调试的链表类实现</title>
    <url>/2020/03/26/%E6%96%B9%E4%BE%BF%E8%B0%83%E8%AF%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>链表是一种特殊的数据结构：<br><img src="2020-03-26-%E6%96%B9%E4%BE%BF%E8%B0%83%E8%AF%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="pic0x0"><br>它包含了两部分：<br>$$ListNodePtr<br>\begin{cases}{value} \\<br>{next}\begin{cases}{value} \\<br>                    {next}\begin{cases}{value} \\<br>                                       {next…}<br>                                       \end{cases}<br>                    \end{cases}<br>\end{cases}<br>$$<br>在《算法 第4版》中是这样描述的：</p>
<blockquote>
<p>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>
<p>在我看来，因为链表是一种递归的数据结构，故不要把“结点”看成一个“点”。而应该看成是一个<code>value</code> + 该<code>value</code>后的全部链表———它是全部链表的一部分。<br>关于这个<code>value</code>，它可能是任意数据类型。</p>
<p>一般来说链表类可以写成如下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了在调试代码的时候直观地看到链表形如<code>7 -&gt; 0 -&gt; 8 -&gt; null</code>，链表类可以写成如下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"arr can not be empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        val = nums[<span class="number">0</span>];</span><br><span class="line">        ListNode curr = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(nums[i]); <span class="comment">//创建ListNode实例，调用前面的构造方法</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ListNode cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.append(cur.val);</span><br><span class="line">            s.append(<span class="string">" -&gt; "</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">"null"</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调试的时候，比如向<code>SolutionMe0x0</code>类的<code>testListNode</code>方法中传递链表<code>ListNode lx, ListNode ly</code>，我们可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span>[] test1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] test2 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] test1 = &#123;6, 7, 8, 3, 2, 7&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test2 = &#123;9, 7, 6, 6&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test1 = &#123;2&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test2 = &#123;5&#125;;</span></span><br><span class="line">        ListNode lx = <span class="keyword">new</span> ListNode(test1);</span><br><span class="line">        ListNode ly = <span class="keyword">new</span> ListNode(test2);</span><br><span class="line">        System.out.println(SolutionMe0x0.testListNode(lx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #8 车的可用捕获量（Available Captures for Rook）</title>
    <url>/2020/03/26/LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白&gt; 色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，<br>“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西&gt; 和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动&gt; 到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白&gt; 色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><p><img src="2020-03-26-LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/%E7%A4%BA%E4%BE%8B1.png" alt="pic0x0"></p>
<blockquote>
<p><strong>输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'R'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 3<br><strong>解释：</strong> 在本例中，车能够捕获所有的卒</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><p><img src="2020-03-26-LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/%E7%A4%BA%E4%BE%8B2.png" alt="pic0x1"></p>
<blockquote>
<p><strong>输入：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'R'</span>,<span class="string">'B'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 0<br><strong>解释：</strong> 象阻止了车捕获任何卒</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><p><img src="2020-03-26-LeetCode-8-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F%EF%BC%88Available-Captures-for-Rook%EF%BC%89/%E7%A4%BA%E4%BE%8B3.png" alt="pic0x2"></p>
<blockquote>
<p><strong>输入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'p'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'R'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'B'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'B'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'p'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>,<span class="string">'.'</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 3<br><strong>解释：</strong> 车可以捕获位置 b5，d6 和 f5 的卒</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ol>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] 可以是 ‘R’，’.’，’B’ 或 ‘p’</li>
<li>只有一个格子上存在 board[i][j] == ‘R’</li>
</ol>
</blockquote>
<hr>
<p>题目所求即白车<code>rock(R)</code>一次移动击杀小卒<code>pawn(p)</code>所有可能的情况。<br>读懂题意后，先找白车<code>R</code>，以<code>R</code>为起点，分别往四个方向寻找<code>p</code>。<br>注意可能会遇到<code>Bishop(B)</code>，表示此路不通。另注意范围。</p>
<h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> y = i, x = j;</span><br><span class="line">                    <span class="comment">//纵上</span></span><br><span class="line">                    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//纵下</span></span><br><span class="line">                    i = y; <span class="comment">//i归位</span></span><br><span class="line">                    <span class="keyword">while</span> (++i &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//横左</span></span><br><span class="line">                    i = y;<span class="comment">//i归位</span></span><br><span class="line">                    <span class="keyword">while</span> (--j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//横右</span></span><br><span class="line">                    j = x;<span class="comment">//j归位</span></span><br><span class="line">                    <span class="keyword">while</span> (++j &lt;=<span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维方向数组"><a href="#二维方向数组" class="headerlink" title="二维方向数组"></a>二维方向数组</h3><p>依然是先找到<code>R</code>，定义方向数组<code>[[-1, 0], [1, 0], [0, 1], [0, -1]]</code>，循环该方向数组可表示依次走一个方向。<br>走其中某个方向时，用<code>i, j</code>分别加方向数组即可完成行走动作，注意在行走时要判断棋盘范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为题目已经明确给出 board.length == board[i].length == 8，所以不做输入检查</span></span><br><span class="line">        <span class="comment">// 定义方向数组，可以认为是四个方向向量，在棋盘问题上是常见的做法</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (burnout(board, i, j, direction)) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代码不会走到这里，返回 0 或者抛出异常均可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * burnout 横冲直撞的意思（来自欧路词典）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board     输入棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x         当前白象位置的横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y         当前白象位置的纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 方向向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消灭一个 p，就返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">burnout</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[] direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x;</span><br><span class="line">        <span class="keyword">int</span> j = y;</span><br><span class="line">        <span class="keyword">while</span> (inArea(i, j)) &#123;</span><br><span class="line">            <span class="comment">// 是友军，路被堵死，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是敌军，拿下一血（不知道一血这个词是不是这么用的）</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += direction[<span class="number">0</span>];</span><br><span class="line">            j += direction[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前位置横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 当前位置纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在棋盘有效范围内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="number">8</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<blockquote>
<ul>
<li>时间复杂度：(N^2)，这里 NN 是输入棋盘的长（宽）。找到白色车，最差情况下需要遍历完整个数组。题目固定了输入是 8 \times 88×8 规格的棋盘，认为是 O(1)O(1) 也是没有问题的。</li>
<li>空间复杂度：O(1)，只使用到常数个临时变量。</li>
</ul>
</blockquote>
<h5 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook/</a></p>
</blockquote>
<h5 id="参考题解："><a href="#参考题解：" class="headerlink" title="参考题解："></a>参考题解：</h5><blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/available-captures-for-rook/solution/mo-ni-ti-an-zhao-ti-mu-yi-si-shi-xian-ji-ke-java-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook/solution/mo-ni-ti-an-zhao-ti-mu-yi-si-shi-xian-ji-ke-java-b/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>方向数组</tag>
        <tag>棋盘</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode # 7 三维形体的表面积（Surface Area of 3D Shapes）</title>
    <url>/2020/03/25/LeetCode-7-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF%EF%BC%88Surface-Area-of-3D-Shapes%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</p>
<p>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</p>
<p>请你返回最终形体的表面积。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入：[[2]]<br>输出：10</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入：[[1,2],[3,4]]<br>输出：34</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><blockquote>
<p>输入：[[1,0],[0,2]]<br>输出：16</p>
</blockquote>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><blockquote>
<p>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32</p>
</blockquote>
<h3 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h3><blockquote>
<p>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
</blockquote>
<hr>
<p>用示例5举例，二维数组<code>[[2,2,2],[2,1,2],[2,2,2]]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] grid = &#123;</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表明一个3*3网格，每个格子分别放置对应数字的方块。<br>那么，表面积 = 总数 * 6 - 2(x + y + z)，其中x, y, z分别表示x, y, z方向重叠面数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this surface means hidden surface</span></span><br><span class="line">        <span class="keyword">int</span> surfaceZ = <span class="number">0</span>, surfaceY = <span class="number">0</span>, surfaceX = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// value count</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> raw = <span class="number">0</span>; raw &lt; grid.length; raw++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; grid[raw].length; column++) &#123;</span><br><span class="line">                <span class="comment">// count value</span></span><br><span class="line">                value += grid[raw][column];</span><br><span class="line">                <span class="comment">// for each X, Y ,Z count hidden surface</span></span><br><span class="line">                <span class="keyword">if</span> (raw &lt; grid.length - <span class="number">1</span>)</span><br><span class="line">                    surfaceX += Math.min(grid[raw][column], grid[raw+<span class="number">1</span>][column]);</span><br><span class="line">                <span class="keyword">if</span> (column &lt; grid[raw].length - <span class="number">1</span>)</span><br><span class="line">                    surfaceY += Math.min(grid[raw][column], grid[raw][column+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (grid[raw][column] &gt; <span class="number">0</span>)</span><br><span class="line">                    surfaceZ += (grid[raw][column] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this surface is real "surface"</span></span><br><span class="line">        <span class="keyword">int</span> surface = <span class="number">0</span>;</span><br><span class="line">        surface = value * <span class="number">6</span> - surfaceX * <span class="number">2</span> - surfaceY * <span class="number">2</span> - surfaceZ * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> surface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N^2)，其中 NN 是 grid 中的行和列的数目</li>
<li>空间复杂度：O(1)</li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-surface-area-of-3d-shapes"><a href="#题目链接https-leetcode-cn-com-problems-surface-area-of-3d-shapes" class="headerlink" title="题目链接https://leetcode-cn.com/problems/surface-area-of-3d-shapes/"></a>题目链接<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes/</a></h5>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #6 按摩师（The Masseuse LCCI）</title>
    <url>/2020/03/24/LeetCode-6-%E6%8C%89%E6%91%A9%E5%B8%88%EF%BC%88The-Masseuse-LCCI%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或&gt; 不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。&gt; 给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>注意</strong>：本题相对原题稍作改动</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 &gt; = 12。</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><blockquote>
<p>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = &gt; 2 + 4 + 3 + 3 = 12。</p>
</blockquote>
<hr>
<h3 id="一维状态数组"><a href="#一维状态数组" class="headerlink" title="一维状态数组"></a>一维状态数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];<span class="comment">//or i-1 because i++ in last step</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)O(N)，NN 是数组的长度；</li>
<li>空间复杂度：O(N)O(N)，状态数组的大小为 N</li>
</ul>
<h3 id="一维状态数组-「滚动数组」"><a href="#一维状态数组-「滚动数组」" class="headerlink" title="一维状态数组+「滚动数组」"></a>一维状态数组+「滚动数组」</h3><p>使用 3 个变量滚动完成计算，将空间优化到常数级别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionSO1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre = <span class="number">0</span>, cur = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            cur = Math.max(pre, pre2 + num);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)，N是数组的长度；</li>
<li>空间复杂度：O(1)，状态数组的大小为 3，常数空间。</li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-the-masseuse-lcci"><a href="#题目链接https-leetcode-cn-com-problems-the-masseuse-lcci" class="headerlink" title="题目链接https://leetcode-cn.com/problems/the-masseuse-lcci/"></a>题目链接<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/</a></h5><h5 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #5 链表的中间结点（Middle of the Linked List）</title>
    <url>/2020/03/23/LeetCode-5-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%EF%BC%88Middle-of-the-Linked-List%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 1 和 100 之间。</li>
</ul>
<hr>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>定义一个快指针，定义一个慢指针。其中快指针每个循环走两部，慢指针走一步。这样，当快指针走慢整个链表，由于其速度是慢指针的二倍，故慢指针停留的位置即为链表的中间结点。</p>
<p>注意到，当链表结点个数为偶时，即链表有两个中间结点。此时，题干要求返回第二个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">            <span class="keyword">else</span> fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若题干要求返回第一个结点，应该这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return secondary node while we got a even node linkedList</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表类数组"><a href="#链表类数组" class="headerlink" title="链表类数组"></a>链表类数组</h3><p>换个思路，当我们知道链表结点个数，个数/2即为中间结点位置。我们可以创建一个链表类数组（记得曾经用过的计数数组吗？数组是个好东西，我们要把它玩坏！）循环链表每个结点，把它放在数组里。</p>
<p>注意到，由于题干给出当有两个中间结点取其第二个，我们正好可以利用整形变量特征————int a = 5 / 2，则a被强制转换向下取整为2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode[] arr = <span class="keyword">new</span> ListNode[<span class="number">100</span>]; <span class="comment">//we have restriction about length of linkedList</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr[i++] = head;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[count / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用ArratList可以稍微稍微节省点空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;ListNode&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr.add(head);</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.get(arr.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #4 使数组唯一的最小增量（Minimum Increment to Make Array Unique）</title>
    <url>/2020/03/22/LeetCode-4-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F%EF%BC%88Minimum%20Increment%20to%20Make%20Array%20Unique%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p>
<p>返回使 A 中的每个值都是唯一的最少操作次数。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入：[1,2,2]<br>输出：1<br>解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入：[3,2,1,2,1,7]<br>输出：6<br>解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。<br>可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ul>
<li>0 &lt;= A.length &lt;= 40000</li>
<li>0 &lt;= A[i] &lt; 40000</li>
</ul>
</blockquote>
<hr>
<h3 id="先排序再遍历"><a href="#先排序再遍历" class="headerlink" title="先排序再遍历"></a>先排序再遍历</h3><p>首先将数组进行排序，然后从左到右遍历数组：</p>
<ul>
<li>如果当前元素大于上一个元素，保持不变；</li>
<li>如果当前元素小于等于上一个元素，就需要增加当前元素，直到大于上一个元素。<br>例如输入 <code>[3, 2, 1, 2, 1, 7]</code>，排序后为<code>[1, 1, 2, 2, 3, 7]</code>。遍历数组的过程如下图所示：<br>![pic0x0](2020-03-22-LeetCode-4-使数组唯一的最小增量（Minimum Increment to Make Array Unique）/使数组唯一的最小增量 先排序再遍历.gif)<br>写成代码，只需要用一个变量保存当前的最大值即可。题解代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//排序再遍历计数，最基础的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="comment">//下个数不比当前数大，则计算下个数需要加的次数res，同时</span></span><br><span class="line">        <span class="comment">//由于每次move操作+1，故下个数+res刚好大于当前数</span></span><br><span class="line">        <span class="comment">//注意此时数组排序会被打乱，不能认为判断条件仅是相等情况.</span></span><br><span class="line">        <span class="comment">//另外，注意边界，最多判定到lengh - 2位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i+<span class="number">1</span>] &lt;= A[i])&#123;</span><br><span class="line">                res += (A[i] - A[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                A[i+<span class="number">1</span>] += (A[i] - A[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="构建计数数组"><a href="#构建计数数组" class="headerlink" title="构建计数数组"></a>构建计数数组</h3><p>上面方法中，排序需要 O(n \log n)O(nlogn) 的时间，比较昂贵。我们尝试不进行排序的方法。</p>
<p>例如输入 <code>[3, 2, 1, 2, 1, 7]</code>，计数之后有两个 1 和两个 2。我们先看最小的数，两个 1 重复了，需要有一个增加到 2，这样 2 的数量变成了三个。在三个 2 中，又有两个需要增加到 3，然后又出现了两个 3…… 以此类推，可以计算出需要增加的次数。</p>
<p>我们可以用 map（如 C++ 的 <code>unordered_map</code>，Java 的 <code>HashMap</code>）来做计数。不过既然题目中说明了整数的范围在 0 到 40000 之间，我们不妨直接用一个大小为 40000 的数组做计数。</p>
<p>需要注意的是，虽然整数的范围是 0 到 40000，但是由于整数还会因为增加而变大，超出 40000 的范围。例如极端的情况：所有数都是 39999。所以需要对整数中最大的数单独处理。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计数数组（有序）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//核心思想，是record数组的构建</span></span><br><span class="line">        <span class="comment">//record数组是有序数组，index表示A数组中的值，value表示A数组中数值出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40000</span>];</span><br><span class="line">        <span class="keyword">int</span> max= A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            record[a]++;</span><br><span class="line">            max = Math.max(max, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A数组中最大数max一定在record数组最后面，等下要加以特殊处理</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += (record[i] -<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//record是动态的</span></span><br><span class="line">                <span class="comment">//如果当前位置数值&gt;1，说明下个位置数值会增加当前位置数值-1</span></span><br><span class="line">                record[i+<span class="number">1</span>] += (record[i] -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A数组最大值max在record数组中特殊处理</span></span><br><span class="line">        <span class="comment">//max位于record右边界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (record[max] &gt; <span class="number">1</span>) &#123; <span class="comment">//否则不用担心越界</span></span><br><span class="line">            <span class="keyword">int</span> plus = record[max] - <span class="number">1</span>; <span class="comment">//首项（尾项1）</span></span><br><span class="line">            res += (plus + <span class="number">1</span>) * plus / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性探测法O-N-（含路径压缩）"><a href="#线性探测法O-N-（含路径压缩）" class="headerlink" title="线性探测法O(N) （含路径压缩）"></a>线性探测法O(N) （含路径压缩）</h3><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h5 id="题目链接https-leetcode-cn-com-problems-minimum-increment-to-make-array-unique"><a href="#题目链接https-leetcode-cn-com-problems-minimum-increment-to-make-array-unique" class="headerlink" title="题目链接https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/"></a>题目链接<a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/</a></h5><h5 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h5><blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>计数数组</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #3 水壶问题（Water and Jug Problem）</title>
    <url>/2020/03/21/LeetCode-3-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88Water-and-Jug-Problem%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
</blockquote>
<h3 id="示例-1-From-the-famous-“Die-Hard”-example"><a href="#示例-1-From-the-famous-“Die-Hard”-example" class="headerlink" title="示例 1: (From the famous “Die Hard” example)"></a>示例 1: (From the famous “Die Hard” example)</h3><blockquote>
<p>输入: x = 3, y = 5, z = 4<br>输出: True</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><blockquote>
<p>输入: x = 2, y = 6, z = 5<br>输出: False</p>
</blockquote>
<hr>
<h3 id="贝祖定理方法"><a href="#贝祖定理方法" class="headerlink" title="贝祖定理方法"></a>贝祖定理方法</h3><p>关键在于划分成功条件。<br>题干默认z &gt;= 0，首先当z = 0 时，x和y取任意值，一定成功。<br>当z &gt; 0时：</p>
<ul>
<li>当x + y &lt; z时，即使两盏杯子装满水，依然不可能成功。</li>
<li>当x + y = z时，x, y, z取任意值，一定成功。</li>
<li>当x + y &gt; z时，不一定。问题的核心在此，用贝祖定理判定成功条件。<br>由贝祖定理可知，对任何整数x、y和它们的最大公约数gcd(x, y)，对于它们的的任意整数倍数a,b,c，都有<br>ax + by = c·gcd(x, y)恒成立。<br>由题干给出的几种操作，要完成目标，一定有ax + by = z。<br>和贝祖定理完美锲合，那么，只要z % (gcd(x, y)) = 0为真，则一定成功。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//贝祖定理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认z &gt;= 0</span></span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//z&gt;0</span></span><br><span class="line">        <span class="keyword">if</span> (x +y &lt;z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x + y == z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//only x!=0,y!=0; x!=0,y==0; x==0,y!=0</span></span><br><span class="line">            <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123; <span class="comment">//辗转相除法</span></span><br><span class="line">            <span class="keyword">int</span> temp = y;</span><br><span class="line">            y = x % y;</span><br><span class="line">            x = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3></li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-water-and-jug-problem"><a href="#题目链接https-leetcode-cn-com-problems-water-and-jug-problem" class="headerlink" title="题目链接https://leetcode-cn.com/problems/water-and-jug-problem/"></a>题目链接<a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/</a></h5>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>贝祖定理</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #2 最小的k个数「TopK」 0x1</title>
    <url>/2020/03/20/LeetCode-2-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E3%80%8CTopK%E3%80%8D%200x1/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br><strong>示例2：</strong><br>输入：arr = [0,1,2,1], k = 1<br>输出：[0]<br><strong>限制：</strong><br>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p>
</blockquote>
<hr>
<h3 id="快速查找方法-分治法，快速排序思想"><a href="#快速查找方法-分治法，快速排序思想" class="headerlink" title="快速查找方法(分治法，快速排序思想)"></a>快速查找方法(分治法，快速排序思想)</h3><p><img src="2020-03-20-LeetCode-2-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%EF%BC%88TopK%EF%BC%89/quickSort.png" alt="pic0x0"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getTopK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= arr.length)</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length -<span class="number">1</span>;</span><br><span class="line">        partitionArray(arr, low, high, k);</span><br><span class="line">        <span class="comment">//copy array</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> copy = <span class="number">0</span>; copy &lt; k; copy++)&#123;</span><br><span class="line">            result[copy] = arr[copy];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span> (k == m) <span class="comment">//as we expect，反复递归，k会在m左右两侧摇摆，直到恰好等于m</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m)</span><br><span class="line">            partitionArray(arr, low, m -<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            partitionArray(arr, m + <span class="number">1</span>, high, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = arr[low];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == high) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == low) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123; <span class="comment">//碰头了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆方法"><a href="#堆方法" class="headerlink" title="堆方法"></a>堆方法</h3><p>维护一个大顶堆，堆中始终保持当前状态最小k个数。<br><img src="2020-03-20-LeetCode-2-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%EF%BC%88TopK%EF%BC%89/%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E5%A4%A7%E9%A1%B6%E5%A0%86.gif" alt="pic0x1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆,or we can do it like this:</span></span><br><span class="line">        <span class="comment">// Collections.reverseOrder()</span></span><br><span class="line">        <span class="comment">//PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">            <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123; <span class="comment">//Queue.peek()返回堆顶最大元素（不删除），空堆返回null</span></span><br><span class="line">                heap.offer(e); <span class="comment">//Queue.offer()插入元素e，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll(); <span class="comment">// Queue.poll()推出堆顶最大元素作为返回值，空堆返回null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123; <span class="comment">//遍历堆</span></span><br><span class="line">            res[j++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>TopK</tag>
        <tag>快速选择</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1 两数之和「twoSum」 0x0</title>
    <url>/2020/03/19/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%8CtwoSum%E3%80%8D%200x0/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。而且，你不能重复利用这个数组中同样的元素。</p>
</blockquote>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<hr>
<h3 id="Java-HashMap-method"><a href="#Java-HashMap-method" class="headerlink" title="Java HashMap method"></a>Java HashMap method</h3><p>key: target - nums[v]<br>value: v<br>每次迭代，判断nums[v]在不在hashmap中。<br>如果在，则nums[v]一定是之前target - nums[index_before]的值。此时返回{index_before, v}；<br>如果不在，则把key: target - nums[v]和value: v放到hashmap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Java HashMap method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; nums.length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.get(nums[v]) != <span class="keyword">null</span>) &#123; <span class="comment">//found value what is index v</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashMap.get(nums[v]), v&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(target - nums[v], v); <span class="comment">//found nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-time-for-loop"><a href="#2-time-for-loop" class="headerlink" title="2 time for loop"></a>2 time for loop</h3><p>注意到数组中同样元素不可重复利用，意思是某元素不能和自己相加和target比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   2 7 11 15</span><br><span class="line">2  x</span><br><span class="line">7    x</span><br><span class="line">11     x</span><br><span class="line">15        x</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i] + nums[j] == target) &amp;&amp; (i != j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈java的static关键字</title>
    <url>/2020/03/14/%E6%B5%85%E8%B0%88java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><h3 id="Why-we-have-to-use-a-static-key-word"><a href="#Why-we-have-to-use-a-static-key-word" class="headerlink" title="Why we have to use a static key word?"></a>Why we have to use a <code>static</code> key word?</h3><p>一般来说，要想引用类成员变量、使用类方法或者分配存储空间，需要创建一个对象。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用类变量，注意到st1.i和st2.i指向同一存储空间，具有相同值47</span></span><br><span class="line">Class StaticTest &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">st1.i</span><br><span class="line">st2.i</span><br><span class="line"><span class="comment">//使用类方法</span></span><br><span class="line">Class Incrementable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Incrementable sf = <span class="keyword">new</span> INcrementable();</span><br><span class="line">sf.increment;</span><br></pre></td></tr></table></figure>
<p>那么，如果我们遇到特殊需求。比如我们希望为特定域（field）分配单一存储空间，而不去考虑究竟需要创建多少对象，甚至不用创建对象；再比如我们希望某个方法不与包含它的类的对象相关联，就是说，可以不用创建对象而使用方法。</p>
<p>此时，我们可以使用<code>static</code>关键字。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="How-do-we-use-static"><a href="#How-do-we-use-static" class="headerlink" title="How do we use static"></a>How do we use <code>static</code></h3><p>当声明一个事物是static时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起。</p>
<p>回顾上述两个类，我们可以声明类变量<code>i</code>和类方法<code>increment()</code>是<code>static</code>，再直接使用类名引用它们:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class StaticTest &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不必创建对象而使用i</span></span><br><span class="line">StaticTest.i++</span><br><span class="line"><span class="comment">//不必创建对象而使用方法</span></span><br><span class="line">Class Incrementable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Incrementable <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//另一个广为人知的例子  wow, that was epic.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><blockquote>
<ul>
<li>类中<code>static</code>方法不能访问非<code>static</code>变量。</li>
<li>类中<code>static</code>方法不能使用<code>this</code>关键字。<br>原因就是<code>Static</code>方法是类方法，先于任何的实例（对象）存在。即<code>Static</code>方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成。</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li>声明为<code>static</code>的事物也可以用前文所述常规方法引用。</li>
<li>通过类名直接引用是引用<code>static</code>事物的首选方式，这不仅是因为它强调了事物的<code>static</code>结构，而且在某些情况下它还为编译器进行优化提供了更好的机会。</li>
</ul>
</blockquote>
<p><em>总结自《Thinking in Java 4th edition》P29 - P30</em></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>Trump address sparks chaos as coronavirus crisis deepens[CNN]</title>
    <url>/2020/03/12/Trump-address-sparks-chaos-as-coronavirus-crisis-deepens%5BCNN%5D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>CNN news</p>
<a id="more"></a>
<hr>
<p>(CNN)President Donald Trump set out to steady a rattled nation and a diving economy in a solemn Oval Office address, but instead sowed more confusion and doubts that he is up to handling the fast-worsening coronavirus crisis.</p>
<ul>
<li>set out to着手；steady稳定；rattled nation摇摇欲坠的；solemn庄严的；sowed引起了；fast-worsening快速恶化的</li>
</ul>
<p>Trump spoke to the nation at a fearful moment, when the rhythms of everyday American life are starting to shut down – with schools closing, the NBA suspended, hospitals on high alert and movie icon Tom Hanks saying he and his wife have the disease.</p>
<ul>
<li>rhythms节奏</li>
</ul>
<p>“The virus will not have a chance against us. No nation is more prepared or more resilient than the United States,” the President said, before painting a rosy picture of an economy that is already taking a beating from the virus fallout. </p>
<ul>
<li>resilient弹性的；before painting a rosy picture of an economy在描绘经济乐观的面纱之前；beating打击；fallout辐射，影响</li>
</ul>
<p>The New York Stock Exchange halted trading for 15 minutes after the S&amp;P 500 fell 7% on Thursday morning.</p>
<ul>
<li>stock证券，股票；halt停止</li>
</ul>
<p>The President unveiled several measures to help on that score, to help workers who lack sick pay but have to self-isolate and are hard-hit by shutdowns, though his call for a payroll tax cut is not popular in Congress.</p>
<ul>
<li>unveil公布，揭幕；measure措施；on that score实现那目标；sick pay病假工资；self-isolate自我隔离；shutdown停工；payroll工资单；congress国会</li>
</ul>
<p>Trump’s big announcement for keeping the virus at bay – what he said was a 30-day ban on travel to the US by Europeans and restrictions on cargo – was immediately engulfed in confusion.</p>
<ul>
<li>bay绝路；engulf吞噬</li>
</ul>
<p>The President later rushed to clarify on Twitter that he was stopping travel and not trans-Atlantic trade in goods, and officials said his plan did not apply to Americans or US permanent residents – though such travelers would face mandatory quarantines.</p>
<ul>
<li>apply to适用于；mandatory强制性的；quarantine隔离检疫</li>
</ul>
<p>“The restriction stops people not goods,” Trump tweeted after his speech.</p>
<p>Trump also caused a muddle when he said he had convinced health insurance providers to waive all copayments for coronavirus treatments.</p>
<ul>
<li>muddle混乱；convince说服；waive放弃；copayment自付费用</li>
</ul>
<p>A White House official later said the President had meant to say that the copayments would be waived for coronavirus tests – but would still apply to treatments for the disease.</p>
<p>On Thursday morning, Vice President Mike Pence defended Trump’s presentation.</p>
<ul>
<li>Vice President副总统；defend辩护</li>
</ul>
<p>“I don’t think there’s confusion,” Pence said on CNN’s “New Day,” praising the President for taking another historic step to suspend all travel from Europe … for the next 30 days.</p>
<ul>
<li>praise称赞</li>
</ul>
<p>Pence then announced that “Americans coming home will be funneled through 13 different airports,” and would be screened at those airports.</p>
<ul>
<li>funnel [v]漏进 [n]漏斗；screen[v]遮掩</li>
</ul>
<p>“Then we’re going to ask every American and legal resident returning to the United States to self-quarantine for 14 days,” he said.</p>
<p>European Union leaders said Thursday they disapprove of Trump’s decision.</p>
<ul>
<li>disapprove不赞同</li>
</ul>
<p>In a statement, the Presidents of the European Council and the European Commission, Charles Michel and Ursula von der Leyen, respectively, said that the outbreak is a “global crisis, not limited to any continent and it requires cooperation rather than unilateral action.”</p>
<ul>
<li>respectively分别地；outbreak[n]发病；continent大陆；’u[ju]nilateral单方面的</li>
</ul>
<p>“The European Union disapproves of the fact that the US decision to impose a travel ban was taken unilaterally and without consultation,” the statement read.</p>
<ul>
<li>impose强加；consultation协商</li>
</ul>
<h4 id="Sowing-confusion"><a href="#Sowing-confusion" class="headerlink" title="Sowing confusion"></a>Sowing confusion</h4><p>The confusion was symptomatic of an administration that has often struggled to frame detailed policies and present them coherently. Trump’s top assignment on Wednesday was to show that he was in charge and that he appreciated, finally, the grave nature of the weeks that lie ahead. But the confusion over the travel ban turned his speech into something of a debacle and may up exacerbating uncertainty over his leadership.</p>
<ul>
<li>symptonatic征兆；administration行政部门；struggle努力；frame[v]制定；co’he[i]rently连贯地；assignment任务，分配；grave严重；nature性质；weeks lie ahead未来几周；de[i]’ba[a]cle崩溃；e’xacerbate加剧，恶化；</li>
</ul>
<p><u>And his travel ban announcement was made apparently without consultation with the travel industry or US allies and seems set to cause massive disruption that will deepen already cascading economic damage unleashed by the crisis.</u></p>
<ul>
<li>disruption破坏；deepen加深；cascading一系列的，级联；unleash发动</li>
</ul>
<p>The move could cause mass cancellation of trans-Atlantic flights, which could throw the aviation industry into a moment of existential challenge. Trump acted after Italy, which has now recorded over 12,000 cases, experienced <u>a record jump in confirmed infections with 2,313 on Wednesday.</u></p>
<ul>
<li>aviation航空；infection感染；a record jump in confirmed infection with 2,313 on Wednsday周三确认感染病例达到创纪录的2313例</li>
</ul>
<p>US Travel Association President and CEO Roger Dow called on Trump to <u>match his aggressive action with equally bold moves</u> to shore up the travel industry.</p>
<ul>
<li>call on呼吁；aggressive积极的；bold大胆的；shore up支撑</li>
</ul>
<p>“Temporarily shutting off travel from Europe is going to exacerbate the already-heavy impact of coronavirus on the travel industry and the 15.7 million Americans whose jobs depend on travel,” Dow said in a statement. The Association said that 850,000 international visitors flew to the US from parts of Europe other than the UK in March 2019 and spent around $3.4 billion in this country.</p>
<ul>
<li>other than以外</li>
</ul>
<p>Such figures will do nothing to quell investor panic after Wall Street on Wednesday dipped into a bear market. For example, Dow Futures plunged more than 1,000 points after Trump’s speech, despite the President’s arguments the strong US economy will emerge from the crisis unscathed.</p>
<ul>
<li>figures数字；quell平息；dip into浸入；bear market熊市; plung[dʒ]e暴跌；despite尽管；argument观点；emerge摆脱困境，出现；unscathed毫发无损地</li>
</ul>
<p>“This is not a financial crisis. This is just a temporary moment of time that we will overcome together as a nation and as a world,” Trump said in his address.</p>
<ul>
<li>address讲话</li>
</ul>
<p>US stocks sold off sharply for the second straight day on Thursday, after Trump’s announcement. Wall Street investors are worried about the scale of the coronavirus pandemic and its economic consequences.</p>
<ul>
<li>sold off跌价；second straight day连续第二天；pan’demic（全球性的）流行病；concequence后果</li>
</ul>
<p>On a more fundamental level, the travel ban plan raised basic questions about the President’s understanding of a crisis he has minimized, blamed on Democrats and predicted will just go away soon.</p>
<ul>
<li>fundamental根本的；raise提出；blamed on归咎于；’Demo[ə]crats民主党人；predict预计</li>
</ul>
<p>Department of Homeland Security guidance suggested the restrictions exempted US nationals and permanent residents, who would face quarantine when they came home. And the President did not explain why his ban did not include citizens of the UK – where the virus has also taken root.</p>
<ul>
<li>guidance指导；restriction限制；exempt豁免；</li>
</ul>
<p><u>But the biggest problem facing the US is not more cases of coronavirus coming from Europe</u> – it is that the disease has taken root on US soil itself by community spread.</p>
<p>Pressing issues now revolve around how Americans should respond to the situation and to what extent they should change their daily patterns. Trump did advise halting nonessential visits to care homes for the elderly – the highest risk group from the virus.</p>
<ul>
<li>pressing issue紧迫的问题；revolve围绕；respond to应对；extent程度；pattern模式；daily pattern生活习惯；nonessential不必要的；</li>
</ul>
<p><u>But he didn’t explain how he would alleviate what health officials fear will be a crowding of hospitals</u>, the continuing lack of proper testing or the coming strain on resources such as breathing machines needed to keep the sickest patients alive.</p>
<ul>
<li>alleviate缓解；the continuing lack持续缺乏；proper合适的；strain紧张，压力</li>
</ul>
<p>He argued that the threat was still “very low” for all but the old and infirm, on a day when one of his top public health officials, Dr. Anthony Fauci, predicted the current scenario – with more than 1,200 people sick in the US and 38 dead, is “going to get worse.”</p>
<ul>
<li>infirm体弱的；predict预测；sce[ə]’na[æ]rio情景；</li>
</ul>
<p>Local officials in some hard-hit areas are meanwhile warning that failures in the federal response are making the situation worse.</p>
<ul>
<li>hard-hit area重灾区；federal联邦政府；response应对措施；</li>
</ul>
<p><u>The mayor of Seattle, Jenny Durkan, said that a lack of testing kits earlier in the pandemic that continues to this day was preventing patients getting the treatment they needed and officials from understanding the community spread of the disease.</u> She told CNN’s Don Lemon that stringent measures to restrict public gatherings and close schools were therefore vital to saving lives.</p>
<ul>
<li>mayor市长；prevent阻止；stringent严格的；measure措施；vital重要的</li>
</ul>
<p>“By doing some modeling and looking at the tests, (scientists) calculate that if we didn’t take the kind of actions that the governor and I and the executives announced today, that by April 7th, we would have over 25,000 cases in the city of Seattle in this region. And 400 deaths,” Durkan said.</p>
<ul>
<li>executive高管</li>
</ul>
<h4 id="Trump-speech-likely-to-split-the-nation"><a href="#Trump-speech-likely-to-split-the-nation" class="headerlink" title="Trump speech likely to split the nation"></a>Trump speech likely to split the nation</h4><p>To Trump’s supporters, his address likely came across as a decisive and bold move to face up to a national challenge.</p>
<ul>
<li>come across给人以印象；de’ci[aɪ]sive果断的；bold大胆的；</li>
</ul>
<p>But to critics it followed a familiar playbook – as he blamed others for the crisis, basked in self-congratulation and xenophobia, and misled the country about his actions so far.</p>
<ul>
<li>critic批评者；playbook剧本；bask沐浴阳光；xe[ze]no’phobia排外主义；mis’led误导</li>
</ul>
<p>“This is the most aggressive and comprehensive effort to confront a foreign virus in modern history,” Trump said, misrepresenting his own and his administration’s catalog of missteps.</p>
<ul>
<li>comprehensive全面的；confront对抗；misrepresent歪曲；catalog of missteps让自己处于尴尬境地的list</li>
</ul>
<p>The President did not mention, for example, the shortage of testing kits, which means officials cannot even get a strong read on how far the disease has spread across the nation.</p>
<ul>
<li>get a strong read好好理解一下</li>
</ul>
<p>Presidents use Oval Office addresses in moments of extremis, to bind Americans together to confront a challenge that threatens their collective security.</p>
<ul>
<li>in extremis | in an extremely difficult situation；bind捆绑；collective集体的</li>
</ul>
<p>But Trump’s toneless, almost resentful address as he faces a challenge from outside that could threaten his reelection hopes is unlikely to fulfill the soaring mission of the presidency.</p>
<ul>
<li>toneless无言；resentful不满的；reelection连任；full’fill完成；soaring高涨的；presidency任期</li>
</ul>
<p>His central remedy – blaming China, where the crisis was spawned, and Europe for becoming afflicted with it – was consistent with his political mantra of demonizing foreigners.</p>
<ul>
<li>re[e]me[ə]dy补救方法；afflict折磨；consistent一致的；mantra口头禅；’de[i]monize妖魔化</li>
</ul>
<p><u>The idea that a virus that affects all humans and is a naturally occurring force was some kind of foreign-brewed threat sent to attack Americans is in itself staggering in its conception.</u></p>
<ul>
<li>brew酿造；in itself本身，本质上；staggering相当震惊；</li>
</ul>
<p>The President did announce a raft of measures to support businesses and individuals with tax relief and low interest rates as the virus tightens its grip on the US.</p>
<ul>
<li>raft一系列的；measure措施；individual个体；relief救济；tighten束紧；grip | [n]a tight hold on something or someone</li>
</ul>
<p>But Trump’s plan to self-isolate the US from Europe appears to be a case of closing the stable door after the horse has bolted – the virus is already here and infecting more Americans by the day.</p>
<ul>
<li>bolt闩上</li>
</ul>
<div class="note primary">
            <p><strong>OriginalLink:</strong> <a href="https://www.cnn.com/2020/03/12/politics/donald-trump-coronavirus-europe-travel/index.html" target="_blank" rel="noopener">Trump address sparks chaos as coronavirus crisis deepens</a></p>
          </div>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2020/03/12/Test-0/</url>
    <content><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="emmm-this-is-a-test-too"><a href="#emmm-this-is-a-test-too" class="headerlink" title="emmm this is a test , too."></a>emmm this is a test , too.</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/03/12/test/</url>
    <content><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="this-is-a-test"><a href="#this-is-a-test" class="headerlink" title="this is a test."></a>this is a test.</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>给您拜个晚年，祝您新的一年心明眼亮，百毒不侵</title>
    <url>/2020/03/07/%E7%BB%99%E6%82%A8%E6%8B%9C%E4%B8%AA%E6%99%9A%E5%B9%B4%EF%BC%8C%E7%A5%9D%E6%82%A8%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4%E5%BF%83%E6%98%8E%E7%9C%BC%E4%BA%AE%EF%BC%8C%E7%99%BE%E6%AF%92%E4%B8%8D%E4%BE%B5/</url>
    <content><![CDATA[<h1 id="给您拜个晚年，祝您新的一年心明眼亮，百毒不侵"><a href="#给您拜个晚年，祝您新的一年心明眼亮，百毒不侵" class="headerlink" title="给您拜个晚年，祝您新的一年心明眼亮，百毒不侵"></a>给您拜个晚年，祝您新的一年心明眼亮，百毒不侵</h1><h2 id="一点感悟"><a href="#一点感悟" class="headerlink" title="一点感悟"></a>一点感悟</h2><h3 id="知乎有提问，新冠蔓延能带来哪些正面意义。"><a href="#知乎有提问，新冠蔓延能带来哪些正面意义。" class="headerlink" title="知乎有提问，新冠蔓延能带来哪些正面意义。"></a>知乎有提问，新冠蔓延能带来哪些正面意义。</h3><h3 id="当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？"><a href="#当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？" class="headerlink" title="当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？"></a>当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？</h3><h3 id="这他妈是灾难-ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。"><a href="#这他妈是灾难-ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。" class="headerlink" title="这他妈是灾难,ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。"></a>这他妈是灾难,ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。</h3><h3 id="惊蛰刚过，我仿佛已经看见万物复苏。祝好！"><a href="#惊蛰刚过，我仿佛已经看见万物复苏。祝好！" class="headerlink" title="惊蛰刚过，我仿佛已经看见万物复苏。祝好！"></a>惊蛰刚过，我仿佛已经看见万物复苏。祝好！</h3>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>新冠</tag>
      </tags>
  </entry>
</search>
